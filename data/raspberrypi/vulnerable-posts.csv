PostId,Body
111719,"My understanding so far is that (as has been stated) the sysfs interface is deprecated. 
There are at least two relatively new C APIs in user space (apologies to WiringPi and PiGpio). One or both seem to have the label libgpiodThey can be installed on buster (but not jessie) with: Not sure about stretch.
Also not sure which API requires which installs. 1) The first C API relies on /usr/include/linux/gpio.h which holds data structures and defines used with system calls to interact with the gpios. This is written by Linus Walleij. An example of this API is shown below, and is derived from a talk by Linus Walleij indicated in the code comments. Programs using this API must have the #includes shown in the example below but don't need to be compiled with any libraries (AFAIK). 2) The second C API relies on /usr/include/gpiod.h which provides a simplified interface that abstracts setup and handles and allows contextless reads, writes, and other functions. This is maintained by Bartosz Golaszewski. An introduction to the API is given in some slides by Bartosz which can be found at:https://ostconf.com/system/attachments/files/000/001/532/original/Linux_Piter_2018_-_New_GPIO_interface_for_linux_userspace.pdf?1541021776Some good examples using this API can be found at: https://framagit.org/cpb/example-programs-using-libgpiod/-/tree/master/Note that programs using this API must:and be compiled with the -lgpiod library (for example):I've successfully compiled and run some of the examples.  **
There is a C++ API also provided by Bartosz Golaszewski that depends on /usr/include/gpiod.hpp.  It is a C++ a wrapper based on the C API and depends on the C++11 standard. Programs using this API must:An example of using this API is found in the same slides as the C API.https://ostconf.com/system/attachments/files/000/001/532/original/Linux_Piter_2018_-_New_GPIO_interface_for_linux_userspace.pdf?1541021776 I have yet to get these examples to compile, but suspect there is a library inclusion I have yet to discover.Below is an example gpio read program using the C API number 1 from above (the one authored by Linus Walleij). It repeatedly reads gpio 4 on /dev/gpiochip0 and prints it's value. Compile with Execute:This will show the value of the specific gpio offset every 0.25 seconds."
113154,I am not impressed with libgpiod.  Frankly it seems to be a retrograde step compared to sysfs.Here is some partial code which calls up other not included code.  It should give you enough of an idea to get your own code working.
113177,"btw:   this is a code ""example"" I saw ..  it looks very simple (as working with libgpiod is said to be, but doesn't work).  There is also a regular input source file, which also doesn't work.  There is a pin out put file, that I did get to work.here's is an event example I found a few days back:"
12087,"There are two basic ways to run another executable using C on linux: system() and exec(), although exec() isn't really a function, it's a group of functions, execl(), execv() etc.  They all have the same man page, so you can see the list via e.g. man execl.system() is fine if what you want to do is launch another application and wait for it to finish, and you don't need to interact with or gather output from the other process.If the context is that you don't want to wait for the other process to finish -- i.e., you want your program to go on running and RaspiStill to work in the background -- you need to combine exec() and fork().  The exec() functions replace the current process with a new one.  In other words, exec() never returns; it's the last line of your code that will execute.This is why you want to  combine it with fork(), which creates a child process.  You then call exec() in the child (note there is no main function here yet):If you haven't used fork() before, you need to understand that because it literally forks the program into two, after fork() you have TWO programs running, the parent and the child.  In the parent program, fork() will have returned the PID of the child process (if it returns -1, it failed, and there is no child; this shouldn't normally happen).  In the child program, it will have returned 0.  So you can use this to create two diverging branches of execution -- the parent does one thing while the child does another:What will probably happen when you run this is something like:Notice ""Hello world"" appeared first, then the program seemed to end (which is why the prompt came back), then the output from ls appeared.  I said this is probably what will happen because it could have been the other way around -- those are two programs running simultaneously, so who does what first is indeterminate (but in this case the parent will probably be quicker to output).Note it is generally not good to have the parent finish before a child does, if that is a concern see man 2 waitpid.Two things I want to point out about the use of exec();The first arg to those functions is always the path to the executable.  Since ls is probably in $PATH, I just used ""ls"".  The next arg (or in the case of execvp, the first element in the 2nd arg array) should be the name of the executable.  This is actually the same as the first arg in the arg array passed to a program's main() function -- it's always the name of the program executable itself.  Most programs don't make any use of this, so it can probably be anything; I used ""ls"" again:So using, e.g., execl();If the executable isn't in $PATH, put the path in the first arg (""/bin/ls"") but not in the second. exec() doens't return unless it fails, which can happen if it can't find the path you've specified.  That's why there's an exit() in the last if clause of forkAndExecute().If you want to send data to the child process's standard input, or read from its output, you need to use fork(), exec(), and pipe() to connect the child's file descriptors to something the parent can read from/write to.BTW, general C questions are better off on Stack Overflow.  fork() and execute() actually aren't standard C, they're POSIX (hence, unistd.h), but any C programmer who didn't grow up in a cave is probably aware of them."
12106,"There are multiple approaches to accomplish what you want.  They way I am going to describe is probably going to have a learning curve though, because I used C.  Most of the information I used came from this very helpful guide.With this method, you are going to need a client and a server to communicate between the two Raspberry Pis.  The exchange of information between client and server is summarized in this diagram:                                 Here is some C code for a server and client.  All this server does is send the string ""Hello, World!\n"" out over a stream connection. All you need to do to test this server is run it in one window, and telnet to it from another with:(where remotehostname is the name of the machine you're running it on)Here is the server.c code:Here is the client.c code:You can read further into that guide I linked to learn how to develop more advanced communication between clients and servers."
122067,I have some pigpio example code to generate a pulse per second.It's some time since I have tested it.http://abyz.me.uk/rpi/pigpio/examples.html#C_pps_cIt generates a pulse on the wall time second.If the Pi is connected to a time source (i.e. it is networked) it will use that as wall time.
124243,"""The output I receive is serial test start ...
What am I doing wrong?""You should use /dev/serial0There seems to be nothing wrong with the program, it is probably doing what you instructed it to do
i.e. Send a line; then read input and resend the characters over serial, presumably producing an infinite loop.What do you expect it to do?Incidentally WiringPi is deprecated. You should look into other tools, as it is unlikely to be included in the next Raspberry Pi OSThe following code is a program I used to read strings (in the days when I used WiringPi) - this was 7 years ago before /dev/serial0, but there are plenty of code samples in other languages or using other libraries."
127938,I can't see anything obviously wrong.  Perhaps the peripheral base is different for the Pi3B+.Here is some code to compare against.
130530,"I wrote programs for a number of libraries, both c and python.
These just toggle a GPIO pin as fast as possible.NOTE In case anyone misunderstands I am aware this is an artificial test with no real world use and there are far better (and faster) ways of generating a ""square"" wave. It is indicative of the response to programmed GPIO commands.pigpio is quite slow; this is to be expected due to the socket interface which has significant overhead.WiringPI is extremely fast (I would expect the BCM2835 to perform similarly although I did not test). This is expected as they directly access GPIO registers.RPi.GPIO is very fast - the underlying /dev/gpiomem code is written in c  to directly access GPIO registers.lgpio C library allows control of the GPIO pins through the gpiochip kernel interface is also very fast.This post has been referenced elsewhere and (as I feared) misinterpreted. If I wanted a program which runs as fast as possible I would not use any library.Joan has pointed out pigpiod uses a client server model and each toggle requires a couple of network messages which accounts for the dramatic performance difference. It would be more sensible to compare against pigpio.I did not include pigpio for the simple reason that I do not use it. It is incompatible with pigpiod (which I do use) and only allows a single program to run at a time.I have added pigpio code which is much faster (even when run on a different model Pi).The code is listed below:-I was asked what Pi I used. I can't remember, as I ran this code on a number of Pi (including a Pi3+ running Bullseye). The results above were probably on a Pi 4 Model B Rev 1.1, but there wasn't much difference.While investigating GPIO hysteresis I ran a program which used the GPIO as a Schmitt trigger Hysteresis - on or off?.This produced erratic results and was quite slow, indicating significant overhead in pigpiod. I wrote an assembler program to do similar.I then decided to investigate the overheads of various libraries and the results are above.The faster results were quite erratic (as expected) and depended more on what else the OS was doing."
132367,Here's my complete code for checking a 26bit rfid card to grant or deny access for a control access system.
19767,My pigpio library will let you generate repeating waveforms with a resolution of microseconds.  If you need less than microseconds you'll need to find another solution.PythonC
22057,"Reading the DHT22 sensor is pretty tough from userland.  You have made it even tougher by using usleep to perform timing.  Most userland attempts use busy waits to accumulate the bits of the DHT22 message.The 40 bits message takes about 4ms to complete.  A 0 bit is roughly 25 us long, a 1 bit is roughly 75 us long.  If any one of the usleeps cause a reschedule the message will be read incorrectly.I'd dump the usleeps and use busy waits.Even if you get it to work you'll find that circa 50% of the reads are unsuccessful.  Fortunately, for temperature/humidity readings, you can probably live with that error rate.There are a couple of ways to get low error rates.  One technique uses SPI to read the bits.  The other uses my pigpio library.  There is a Python example here.Another method of reading the DHT22 which works quite well but isn't 100% reliable."
22683,"For starters, you only posted half your code. Since you are trying to communicate between the 2, both codes are helpful. Nevertheless, try the below code. This code will communicate between the Arduino and Raspberry Pi. The Pi is the sender (Transmitter) and the Arduino is the receiver. You might need to adjust the import paths as your code is most likely in a different location.This code was taken from the examples provided in the github repo and the examples directory of the source code:Pin out:Arduino:Raspberry Pi:"
23767,I use the following code to extract the board revision.See http://elinux.org/RPi_HardwareHistory for the meaning of the returned numbers.There are three different pinouts according to the revision.
24890,"I have experimented and have a sort of solution to sending 9-bit data at 1.25 Mbps.It involves modifications to my pigpio library.I've added a gpioWaveAddSerialX() function which extends the gpioWaveAddSerial() function to allow for setting the number of data bits.  This function constructs a waveform representing the serial data to be transmitted.This also required an update to the internal waveBitDelay() function to allow for a variable number of data bits.The other needed change was to change the base clock from 1 MHz to 1.25 MHz by changing clkDivI = 50 * micros to clkDivI = 40 * micros in the internal initClock() function.The manifest constant  PI_WAVE_MAX_BAUD in pigpio.h was changed to 1000000.
waveBitDelaygpioWaveAddSerialXTest program."
26217,"You seem to be creating then sending 1000 waveforms.  There will be jitter between each waveform.Try generating one big waveform and sending that.Basically de-indent the linesso that they are executed after the for loop (just the once rather than repeatedly).EDITED TO ADDThis code is intended to demonstrate what we talked about in the comments.EDITED TO ADD C EXAMPLEThis shows the patching of the last few DMA control blocks to
repeat the final step.Waveform overview
Waveform transition detail
"
26746,"I must admit I wasn't aware of the 2Gb limitation in the stock build of raspivid (mentioned in Linus' answer). An alternative (if you don't fancy recompiling userland) would be to use picamera (Python supports 64-bit file pointers out of the box). For example, the following should record a wide-screen 360p video in H.264 happily for 24 hours:The next part of the question is whether that will fit on a 64Gb SD card. My hunch is ""probably"", but let's verify that...The Pi's H.264 encoder can be given a bitrate limit with the bitrate parameter in picamera's start_recording method, or the --bitrate parameter in raspivid. In both raspivid and picamera this defaults to 17Mbps (megabits per second) so theoretically a 24-hour video recorded with the default setting couldn't be larger than:Hmm ... that's larger than I was expecting, but okay. One thing to bear in mind is that the default of 17Mbps is meant to be useful at the default recording resolution, which is full 1080p in the case of raspivid (although picamera defaults to the display resolution or 720p in the case of no display as that seemed ""friendlier"" when I wrote it). If you're only recording at 360p you can probably get away with a much lower bitrate limit.The other thing to bear in mind is that the bitrate limit is just that: an upper limit. If the encoder doesn't need all 17 million bits to produce a good enough representation of one second's worth of motion, it won't use that many. By fiddling with the encoder's quantization (which is the quality parameter in picamera, and the --qp parameter in raspivid) we can also adjust the encoder's idea of what ""good enough"" means. The quality is represented by a value between 0 and 40. Lower values mean better quality, so 1 is insanely good, and 40 is ridiculously bad. Typical ""good enough"" values are around 20-25. The value 0 (which is also the default) appears to be special; I'm not sure exactly what it means to the encoder (you'd have to ask the firmware devs that), but it seems to produce similar quality to values around 15-20 (i.e. very good).So, assuming average quality (let's say 20), what sort of bitrate do we need to record wide-screen 360p video? I ran the following raspivid command line twice to record 30 seconds worth of video, then spent the first recording waving the camera around (under the assumption that more motion means more bandwidth required, and we want to test the limits here), and the second with the scene absolutely static:The resulting files were 673675 bytes (658Kb) and 2804555 bytes (2.7Mb) in size respectively, so the bitrates produced by the encoder were:Hence, plugging those values into the equation above, we can realistically expect 24 hours worth of video using similar settings to come in somewhere between 1.8Gb and 7.5Gb in size. We can make sure it definitely won't be larger than that by setting bitrate to something like 750000 which we know will give the encoder enough room to reproduce motion at our desired quality (20), or you could experiment with lower qualities (e.g. 25) to see whether they would be acceptable, and then lower the bitrate limit accordingly. That said, it is worth bearing in mind that you're likely to break 2Gb with the file, so as mentioned above you're likely to run into the 64-bit file pointer issue unless you use Python or recompile userland.For reference, here's the Python script from above modified to include the limits just discussed:Finally, just to respond to goldilocks' comment on Linus' answer: splitting the video file into multiple parts is quite easy (and would easily alleviate any 64-bit file pointer concerns). With raspivid, you can use the --segment parameter to specify that a new file should be opened every n milliseconds, e.g. to record one file for every hour (the %02d in the filename will be substituted for a number, e.g. 01, 02, 03, ...):Alternatively, with picamera you could use the record_sequence method to split based on time:Or based on file-size. In the example below, I've set it to produce 100 files rolling over once each reaches >1Mb, and placed the output iterator in its own function just to demonstrate it's possible to use infinite iterators with record_sequence too:Or ... well, whatever limit you can think of the code for!"
36494,The simplest way would probably be
39225,"Here's sample code I'm using to write messages from a pi to an Arduino-compatible teensy board (which is driving an LCD display unit).  You can replace the code that says LINE1=... and LINE2=... with whatever you want to feed into the serial buffer.   On the Arduino side, I've created a reusable class for reading the serial port that looks like this:and...Then you just have to invoke the method above on Teensy with a byte array to fill with data:Hope that helps.  I'm using this code to post messages on a LCD display board via a web service from my phone ( iPhone Safari --> Pi Web Server (OliWeb) --> cgi script --> serial write --> teensy serial read --> lcd display).  The pi is connected directly to the Teensy board via USB cable."
43600,"I do not see why that pigpio code would be affected by PWM.  It would be affected by the system being busy - just like any other code would be.For any serious timing purposes with pigpio you should be using callbacks.  The callback will tell you when the GPIO changed state accurate to a few microseconds - regardless of the busyness of the system.http://abyz.me.uk/rpi/pigpio/examples.html#pdif2_SRTED is an example of using callbacks with the pigpio daemon.The following is an example of the sort of thing to do using the library directly.  In this example the callback function is called sonarEcho, which simply times the difference between the echo going high then low."
46949,Here is the code to get Pocketsphinx to listen to the mic in just C. All you have to do is compile it and run it.
4886,"I can only help you with the hardware part, Chapter 10 of the datasheets discusses the SPI bus, there is a register that is the 'SPI Master Clock Divider'  (see Page 152 on the bottom).But how you can do anything with that register in Python is for somebody else to answer, or do a search on google for Python programming, or I am also sure the Python module you use, is full of writing data to specific registers, checking that source will also provide the answer.UpdateWithout any knowledge of Python, I found out that the actual communication is done using a .c source, that binds in someway to python. From Python you call functions from this .c file. I see that the SpiDev_new function (which smells like a constructor) accepts as first parameter the defined structure (as shown above), in this structure there is a field that states the maximum frequency of the SPI bus (max_speed_hz). In your source I see a call to:I guess you can add some parameters to this call to get things working like you want...What and How I don't know yet..."
49378,You will have to do something along the following lines.
5109,"Like @okertanov said, your code has syntax errors. In C, comments must be enclosed /* like this */, strings for printf ""have to be in quotes"", and newlines are printed with \n inside the quotes.Try something like this:"
57446,Two points.
59255,"As far as userspace programs are concerned, it's pretty easy to fool them and fake the contents of just about any file. For example, suppose a C program is using /proc/cpuinfo file to verify the serial number. The program is copy-protected and tied to the serial, and I don't have the source code. However, I can still run strace program 2>&1 | grep cpuinfo, which will reveal something like:At this point, I can create a small library, cpuinfo.so with the following function:As you can see, I'm checking if the user of the library tries to open /proc/cpuinfo, in which case I open /tmp/cpuinfo instead.Then I will run the original copy-protected program as LD_PRELOAD=/path/to/cpuinfo.so program, and it will happily read my fake file thinking it's /proc/cpuinfo, while working correctly with the rest of the files.Note that if the copy-protected software includes kernel objects, it will be much harder to fool, as it could access hardware directly. However, such software will also only work with the kernel for which it was built, making it quite impractical to distribute."
7013,"I looked into this, the ARM has 'ldrex and 'strex' instructions, the strex will return a fail result if exclusivity is lost (or may have been lost) since the ldrex, which includes a context switch (or another processor modifying the same register in a multi-processor environment). So it can be done using that; if the strex fails you loop up, and re-do the operation (with a fresh ldrex).ref: http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dht0008a/ch01s02s01.htmlThe routines below seem to work on the Raspberry Pi (in that they generate the assembler I was expecting; and that the effect on the bits when I use them are as expected. I haven't verified that they protect against the context switch issue).
Note that these are inlines rather than functions, so they should be put in a header file.[ EDIT: This does not work for the purpose discussed, it seems it's disallowed somehow. If I use these routines where *addr is an ordinary variable, it works fine. When I use it where *addr is pointed to a mapped GPIO register, the process gets a bus error. (When I change the ldrex/strex to ldr/str and disable the do loop, it then works). So it seems that the ARM exclusive monitor is not able to, or is not set up to, function on memory-mapped I/O regs, and the question remains open.]"
7172,"Thanks to everyone that helped.  I thought I would post my final solution to help others that might read this question.  It's basically the code from dispmanx with a few of the things that I learned.First, in order to compile you will need to add the following include directories to your makefileand the following library.Now include the ""bcm_host.h"" file in your source and the following structure definition:When the program starts, call the bcm_host_init() function to initialize the video core.My goal was to display full screen, solid color test patterns.  I simplified down the dispmanx example and moved the FillRect function code into the following source.  I realize my current method to generate the test pattern is not optimal in terms of performance, but I left it in case I add more complicated test patterns in the future (us565RGB is the color pattern).To clear the test pattern, I call the following code:Finally, I've observed that you do not want to call the code that creates a test pattern without clearing the previous test pattern.  If you do, the previous test pattern will be ""stuck"" on the display and the only way to remove it appears to be rebooting the Raspberry Pi.  You also don't want to exit the program without clearing the test pattern because, again, it will leave the test pattern on the display and a reboot appears to be the only way to fix it.  Unfortunately clearing the test pattern and switching to another one means you'll see the first pattern, then the live display (command prompt or GUI), and then the next test pattern.  I experimented a bit with modifying the active test pattern, but abandoned that effort due to time and the lack of documentation on the API.Hope this helps!"
71894,"Well, in case anyone has trouble with this in the future, I figured it out. It turns out the REST API on WebIOPi does all the work, really. You can check this out on WebIOPi Documentation. To put it simply: no need to mess around with server configurations, all you need is have your client make the request. In my case, it ended up like this:The http.begin() is set to request the value of GPIO 27. Then, given the state of this GPIO on RPi, the GPIO on ESP8266 is set accordingly. "
7434,"If you can bear some of my old C code, here is an example of performing the mapping in C Excuse the length, it is a long bit of setup so that the main bit of code for doing masked writes is short, also it allows for out-of-alignment pages, which is not really an issue here (I had this problem previously with a different embedded register map).
Note that you will need to run the binary as root or the mapping will fail as permission denied to /dev/mem"
75903,The pigpio sonar ranger example html is not displaying for reasons I don't understand.However this is the code given in the example.
76982,"You can certainly read multiple bytes using read.The comments about FIFO are misleading, even though they are important to ensure high speed troughput, are inaccessable.The kernel drivers almost certainly provide buffering, but again this is inaccessable. (In the 1970s I wrote my own drivers which used a 256 character circular buffer.)The following code fragment is an example of how you could write such a buffered interface (into a user supplied buffer).This ia actually an add-on to a wiringPi library routine (AFAIK installed by default on the Raspbian) which I use to provide an equivalent to fgets. Similar code could be used with any library.The following is a test program"
78348,"This looks similar to what I did with a DHT11 temperature sensor with first a Raspberry Pi 3 and then with an Arduino.The Arduino code is at this URL: https://github.com/RichardChambers/anduino_uno/blob/master/project01/dht11_sensor.inoOne thing that I did was to write the DHT11 function, onewireReadDHT11() in my source code, so that I could collect statistics on how the read function was working. What I found was that the counter value check needed to be around 25 for a Raspberry Pi 3. However for an Arduino the comparison value was much less. You may need to increase that value to more than 30 for a Raspberry Pi.So an edited version of your read_dht11_dat() function with the if statement modified follows. The if statement checks the value of the variable counter which is really the width of the pulse received.One thing you can do is to print the actual data received out as hex values and check that if the dht11_dat[] data is all zeros or all ones."
79128,Using a char type to hold bytes is fairly common in C.  char is one of the basic C types and holds one byte.Here is some C code to read channel 0 of the MCP3008.  The example should make clear how the functions are used.
81747,
89185,"I was wrong (in comments) about the need for a function where you can delimit the number of bytes read yourself.  The way the I2C/SMBus protocol  block read is supposed to work is that the device indicates the amount of following data to be read in the first byte:This command reads a block of up to 32 bytes from a device, from a 
  designated register that is specified through the Comm byte. The amount
  of data is specified by the device in the Count byte.From: https://www.kernel.org/doc/Documentation/i2c/smbus-protocolThat's is taken care of in the implementation, and the first ""count byte"" is not part of the data.  Here's the definition of the native C userland function that most likely underlies the python library:You can see how the length of relevant data is used via data.block[0], which is the return value indicating the amount of data copied into the values buffer.  This is just a wrapper on the kernel interface, and although its not clear how much is actually read from the device, presumably it does accord with the count byte.It seems unlikely that the python wrapper messes that up.  So it is possibly the device itself which is at fault.  There's no way to tell looking at that code whether an error is passed up if the device gives a garbage value for the count, or whether the kernel then just limits the read to 32 bytes.  I'm inclined to believe the former, although that would mean the device said read 32 bytes, even though it is pretty clear from your output that only the first three or four are meaningful. "
92355,Here's a function called get_temp that returns the temperature in Farenheit or Celcius.Make a file called temp.c and compile it with gcc temp.c -o tempHere is temp.c:
99180,Finally I was able to find a solution. I used the example 2 from this post posted in Arduino forum https://forum.arduino.cc/index.php?topic=396450.0. I have edited python code also.Arduino codeEdited Python code:
