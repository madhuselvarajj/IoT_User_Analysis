PostId,Body
1027460,"Well, you can use a std::string that will take care of all memory allocationEdit : 
If it is the call to malloc() that you want to avoid you could do this :This will waste some memory however, which can be an issue on embedded platforms."
10687971,"You have a redundant check causing an infinite loop.Now, since this is clearly homework, I'll just give some general advice. In general, you use recursion to make a problem of a particular size smaller. Figure out what part of the problem is getting smaller each iteration, and just make each iteration a recursive call instead of a loop (hint: this means you'll probably want to pass some value into the method to tell you the size and/or location of the current iteration). And remember to have a check either at the beginning of the method or before you recurse to check the size of the problem.This isn't how I was thinking of doing it, but I believe it should work once you fix the problems I've pointed out (and possibly some I missed)."
11069389,I think you  want to do something like this to read in the data:Then use atoi() to convert the data to integers and use them.
12483533,
12666409,"I don't know Python, however, what is wrong with the Arduino sending the number like this:For the Arduino to receive a float:Note this code is untested although very similar to code I have used in the past."
13493939,"getPressure() has no return type!  According to the cpp you posted, your header file should declare the method as float getPressure(); so change your header file to:to correspond with the definition which isAlso, keep in mind that you should review your constructor as it is not declared in your header. Also, doing something likeis really weird. What are the variables on the left?  You are initializing them with your uninitialized members (those on the right, starting with _). You should consider giving an initial value to these members (like 0?)Changing your constructor to something like:To make sure your member variables are initialized with a ""known"" value.Also, most of these values seem temporary (you might not need them outside of a call to getPressure(). In this case, consider moving all these bytes to the scope of the function instead of inside the sensor class to avoid using unnecessary memory - there is not that much available on Arduinos.You will also need to add MPL3115A2(); in the public part of your MPL3115A2 class, this is because you are defining a body for this constructor in the CPP file, therefore you need to declare it so that it's part of the object."
14166964,"It's pretty easy if you just use base 2 as an intermediate.  You can convert from a string in any base to base 2 like this:Then to convert to base 10 is trivial:To print out a number in base 12 is a bit tougher - there isn't a built-in function that already does it, so you need to write your own (with some helpers to keep things clean):You'd use it like:You probably want to add better error handling than I have there - I was shooting for a short implementation for purposes of fitting it here cleanly."
14933653,"The problem looks to be due to getClass(), getSubClass() and getDataValue() returning local variables (returnStr). As soon as the functions return these values will be lost.A few ways to avoid this:Return a String object (a local String will get copied on the way out of the functions):Dynamically allocate the char* within the functions (using malloc()) - if you do this you'll need to be careful to deallocate it afterwards (using free()):Pass a pre-allocated char array into the functions - this can be a local variable in the calling function:"
15522215,"Not having the exact code:Pretty sure you're having this problem b/c something between the malloc and free is throwing (and you're probably catching it already so you don't exit the loop).  Depending on if this is happening in C (or objective-C) or C++ code, you have slightly different methods of resolution.In C++, wrap the malloc/free in the RAII pattern so that when the stack is unwound the free is called.In Objective-C you need to use a finally block:"
15524630,"In C++, if you have a C++11 capable compiler and you use std::vector instead of raw arrays, you could use initializer lists:"
15599741,You can use boost::function<> or boost::bind<> to point to a class member function:
16378017,"Short answer: learn how to use loops (for and while) and arrays.A longer one:define M like this:(replace ... with rest of the values)and change the LedBar function to:also, in setup, instead of pinMode (L.., OUTPUT); lines you can write:"
16537096,"To blink a Led without blocking the program, i suggest you use Timer (and the TimerOne library). I make a quick sample code :  Note :
Consider putting the tag 'c' or 'java' to have syntax highlighting on the code."
16725027,"I take zero credit for this code as I pulled it from a thread on the Arduino forums (http://forum.arduino.cc/index.php?topic=112733.0).  It writes a .bmp file to an SD card.  Another discussion indicated that because of the compression algorithms associated with JPG and PNG files, the amount of code to make those work would be more difficult to fit on an Arduino, which makes sense in my head (http://forum.arduino.cc/index.php?topic=76376.0).  Hope this helps.  Definitely not an expert with Arduino - just tinkered a bit."
16978220,"You're just reading blocks of 300 characters, so there is no string termination \0.You'll have to look at n to see how much data you have read and then process the data before printing it i.e. look for the ^J^M and terminate the line,then continue reading the rest of the data.  FYI ^J^M is Windows line termination (it's just ^J form linux)The following should read multiple messages and convert ^ and J to \n and ignore ^M.Note this uses STDIN, not a serial port."
17394825,"instead of doing the following:I'd advise you to index the error category (1000s, 2000s etc..) as first index of a matrix, and the actual error as second index of the array:Here's the idea:(edit) Here's a valid syntax:the only drawback will be that you shall specify the length of the inner array, and thus need to have the same number of string in each inner array.And then you could code a function that does status code conversion:That solution does not use more memory than using one array (just one more pointer). The only downside of that is if you need status code that are not contiguous, like 1000, 1010, 1042 and 1300. Then there is no cool solution I can think of, except using a good old switch/case:(edit) I had a third idea on how to deal with your problem:But I think the solution that uses the less memory of all three solution is the second one using use cases. Because everything is done in program memory, and all the strings are in the flash thanks to the F() macro. To save a few extra bytes, you could even make the fmt_error() function inline, so it does not add to the function call stack.HTH"
17410904,"The execve() call supplies a new environment to the executed program. For the program to be able to access the X display, you need to retain certain environment variables -- DISPLAY at minimum. Have you inadvertently omitted DISPLAY from the new environment?For OMXPlayer to work without X, it has to have access to the video device itself (/dev/video, in this case; see OMXPlayer builds page for details). It's usually configured so that all members of the video group are allowed to access it.You can use popen(""id -Gn"", ""r"") in your program, to run the id -Gn command which lists the current group memberships. (Read the list as a string from the file handle, then close it using pclose().) If the list does not contain video, then the problem is that the privileges of the user that is running the original program do not include access to the video device. The fix is simple: adding video to the groups that user is a member of.Here is an example program, run.c, to illustrate basic use of execvp():You can compile and test it using e.g.Note that the run() function does not attempt to check whether the command was actually executed or not; it just returns the child process PID, or (pid_t)-1 if fork() fails.Many implementations, including GNU C library popen(), use the 127 exit status as an indication that the execution failed. That is, it is not returned by the command that should have been executed, but by the child process, because the command execution failed. The above run() does so too.You can use a close-on-exec pipe between the parent and child processes in the run() function, to let the parent process know whether the child process successfully started the desired command or not, and if not, why not. The parent process can then also immediately reap the defunct child process. This leaves very little extra effort to the caller in case of errors, so I personally highly recommend this approach. Here is an example implementation:The only downside to this approach, in my opinion, is the extra two descriptors used in the parent process, albeit only temporarily. In almost all cases this is irrelevant, but if you have a server-type application that uses a lot of file descriptors, this is something you should be aware of.The Phidgets library uses threads. The thread that executes the callbacks is different than the one that say, waits for the keypress in the RFID Phidgets example. One option would be to use posix_spawn() to execute the player (from a non-main thread).However, in general, it is better to have the main thread monitor both the player using waitpid(child, &status, WNOHANG) to check if the player has exited, and to handle any new RFID events, launching the player as needed (killing an existing instance if new RFID), and even killing the player if the RFID is moved outside the reader range.This requires a simple threaded event queue:As per the Phidgets RFID example, the tag and tag lost handlers areInstead of waiting for a keypress after everything has been set up, you create a loop, something likeIf you start the player, the above loop detects it is not playing within a second. If there is no player running, then it's okay for the loop to wait for an RFID signal for as long as it wants -- I used 30 seconds."
17552715,"You will need to use long to store values over 32767 (or in an unsigned, over 65535). I'll be back with a simpler piece of code - I think your code is more complex than it needs to be. This code uses no standard functions except isdigit, and just walks through the number. No limitiation on the size of the number (obviosusly, if you go over the limit for a double, then  it will fail). Error handling may need a bit of improvement. I have given it some mild testing... "
17720837,Thank you for your answers. This is my final code:
18175521,"I'm not sure I understand your exact problem.  There are a few problems with the function though which might explain a variety of errors.The linesseem wrong.  You'll decide when to grow the buffer by comparing the number of characters read to absoluteMax so this needs to match the size of the buffer allocated.  You're currently writing beyond the end of allocated memory before you reallocate.  This results in undefined behaviour.  If you're lucky your app will crash, if you're unlucky, things will appear to work but you'll lose the second half of the data you've read since only the data written to memory you own will be moved by realloc (if it relocates your heap cell).Also, you shouldn't cast the return from malloc (or realloc) and can rely on sizeof(char) being 1.You lose the first character read (the one that is read just before the while loop).  Is this deliberate?When you reallocate buffer, you shouldn't reset rcount.  This causes the same bug as above where you'll write beyond the end of buffer before reallocating again.  Again, the effects of doing this are undefined but could include losing portions of output.Not related to the bug you're currently concerned with but also worth noting is the fact that you leak buffer and fdF.  You should free and fclose them respectively before exiting the function.The following (untested) version ought to fix these issues"
18415021,"You probably meant ""string"" instead of ""String"" from std. After that change, it compiles. See the working code below.Also, this is not a typical to implement linked list. Besides, you could just use the corresponding linked list from std unless you have a specific requirement you have not yet mentioned."
19195767,"You pass a pointer to the function but the function is a class member. Likely the call will be invalid because the this pointer will be garbage(may compile fine but will throw strange errors at runtime).You need to define a plain vanilla function, outside of any class, and use that.
If you don't have a very complex project you can get away with having a global pointer to the class instance you should use and just delegate the call in your new function.
If you want to do thing the right way you need some mechanism to get the instance pointer I talked about above. Usually this involves either a singleton or some factory pattern.Example:Having a callback on method will crash because you have an invalid pointer for this so x=5 will write 5 somewhere randomly in memory.
What you need is somehting like:Now you can pass method_delegator to the function. It will work because you now also pass foo_instance for this pointer."
19868780,"Offering this as a suggestion in support of what you are doing...Would it not be useful to replace all of the nested if()s in your loop with something like:   EDIT added global string to copy myString into once captured  Now, the return value from mySerial.available() tells you exactly how many bytes to read, you can read the entire buffer, and test for validity all in one."
19889148,"Before answering your questions, let's look at what's going wrong with solutions 1 and 2.The problem with solutions 1 and 2 is that you're using an initialiser ( i.e. the `{} syntax ), where your compiler is expecting an assignment expression. Initialisation syntax can only be used at the point where the variable is declared. Roughly speaking, initialisation should be understood as giving a value to a variable as soon as it is constructed. Assignment should be understood as giving a value to a variable that has already been constructed somewhere else.So when you do: You are doing initialisation. You are initialising the variable codes to a freshly allocated array of pointers to unsigned char.On the next line, you are then telling the compiler you are doing an assignment. You're using the = sign and assigning to codes, which was declared on the previous line - compiler sees this as assignment.But then, immediately afterwards, you attempt to use initialisation syntax. Your compiler is complaining because it's read this:as a complete expression. It read that as you're allocating an array of CODE_LENGTH bytes and assigning it to the RADIO_ONOFF th member of codes.And it expected you to stop there, with a semi colon but you continued and added the initalisation syntax {}. It doesn't understand, because you are mixing assignment and initialisation together - which are two separate things.  That's why you're getting the ""I expect a semi colon"" type error from the compiler.To answer your questions, both solution 3 and 4 are taking the long way round. There are quicker ways of initialising a 2D array in C++. I also agree with previous answer about using uint8_t.Would something like this be more suitable?A good way to read array syntax is to take the final (rightmost) value in the square brackets [] as the size of some array, and then work backwards.So uint8_t codes[CODE_LENGTH][NR_OF_CODES] will decode out to an array of size NR_OF_CODES of  something. And to get that something go left, and we see uint8_t codes[CODE_LENGTH] - so it's an array of length NR_OF_CODES of arrays of uint8_t, each of length CODE_LENGTH.I hope that helps.NB. In answer to your comment about needing to index the array with named indices - there's nothing stopping you from referring to the individual members of codes via an index.
What you can do is initialise the whole thing via {0} - shorthand for initialising all members to 0.And you can assign members of the RADIO_ONOFF array (or any array for that matter) individually e.g.Try this example - and note the output:"
19893013,"Let me offer a suggested sketch with a few changes. Bastyen's idea of using a timer is quite good and makes the code much easier. The approach I would suggest is to have the timer pop forever at a fixed interval (100 milliseconds in my sketch). If the LED should not be blinking it stays off. If the LED should be blinking, it switches from off to on or vice versa each time the timer goes off.A few notes:The setup function establishes the timer with a 100 millisecond interval and attaches the callback routine. Based on my testing, this only needs to be done once.The main loop just ignores everything unless an input string is complete. If an input string is ready, then the input string is checked for two known values and the appropriate steps are taken. The input string is then discarded.The timer callback routine forces the LED off, if we are not in blinking mode. Otherwise, it just toggles the state of the LED.The flow on and flow off routines set the blinking state as need be and control the valveThe serial event routine has two changes. First, input is ignored (and kept in the buffer) if an input string is already complete. This will preserve commands that are being sent to the Arduino while the current command is being processed. Second, the newline character is not added to the input string. This makes checking the input string slightly easier."
19894433,"I think this is your error:This might work better:That should eliminate any garbage that you were seeing due to unterminated strings.  That said, to get nice newline-terminated strings, you probably need an outer loop to look for those boundaries and divide the stream properly that way.One way to do that might be this:  Declare a string received in your class to hold all buffered input that hasn't yet been returned to the caller.  Then, rewrite read_data() as follows:If you'd like a version that returns an empty string when there no complete line to see, as opposed to waiting forever for data, you can use this version of code.  Note:  If there's buffered data with no terminating newline, it will hold onto it until it does see the terminating newline.  You might want to add a separate flush method to make that data visible."
19951359,
20324420,"To read a string, you can allocate memory for it and then add bytes from Serial:"
20434191,You have to declare your classThis is just the simplest example imaginable. But you have to implement Constructor and Destructor and add the included´s needed. 
20779191,"You are checking the each bit of x (0 to 7) in the code by doing Say for example: You want to display 0 on the led. the seven segment code for displaying 0 on led is 0X3F (The variable x has the value 0X3F). (For more on seven segment display).You are checking the each bit of the 0X3F and the variable 'b' has the value whether the bit i is 0 or 1.For example:Will print when you say the variable yaw is having the seven segment code for the number you want to display on LED and you are checking each bit of yaw. If the bit is 1 you are calling sendOne() function, which might be sending a high voltage to the LED and which will light up the corresponding LED in the 7 segment display. If the bit is 0, you are calling sendZero() to send a low voltage. Here you can notice that you are trying to light up the individual LEDs in the 7 Segment. The above program will be so fast that, you will see all the LEDs (who's bits are 1 as per the 7 segment code)lighted up. "
20928942,"The issue was complex (consisted with a few smaller issues). Dumping request and response frames from both ends as @tomlogic suggested was quite helpful.To resolve these issues I first ensured that hardware part works.XBee explorer has 4 LEDs. One is power and should always glow red when powered. And 3 others, depending on what explorer you have, may be called rx, tx, rssi or din, dout, rssi.When transmitting code runs, we first need to make sure that rx and tx are blinking simultaneously every second. I.e. signal is sent each second.When receiving code runs and calls readPacketUntilAvailable, LEDs on receiving XBee explorer should glow as follows: rssi glows constantly, tx or dout should blink.Now that when we know hardware is fine, we can debug software part.My issue was with receiving code. When we are setting up receiving XBee, we need to make sure we do two things. First, we call xbee.begin(baudRate). And second, we should reset module.And last, but not least thing, readPacketUntilAvailable method will not reset response. We call this function in a loop. Whatever first response we get will be repeated, no matter what other data is sent by transmitter.First response that receiver got in my case was MODEM_STATUS_RESPONSE (0x8A in HEX). And subsequent packets were not read. readPacket must be called instead, since that method will reset previous response.My receiving code now looks like this:"
21035211,"With the below edition of the above sketch, you can simply add to the end of beat[] and notes[]. Note that number characters in notes[] should equal number of elements in beat[]. As I see in the "
21149578,"Unfortunately you will need to loop through each of the filenames individually. please look at an example of my code that does just this. Similar to the above comment by ""A Person"". Here are links to my actual use WHERE I use it and THE filter functionNote that my above use is using the SdFatLib, a more advanced version that SD (the IDE provided) library. Below I have adapted the same function for SD. Should work as it merely inspects the pointed char arrary's last 4 characters. FYI - Note that the SD and SdFatLib only support 8.3 format. "
21199851,"Dynamic allocations are a bad idea on AVR not because it is an 8bit MCU, but because of potential stack-heap collisions. The problem above is that you have a global char*, and being global, it gets initialized to NULL [this is part of the C standard, you have no control over this, it is done by the __do_clear_bss section of the final executable]. The moment you do strcpy() on this NULL pointer, you start writing at address 0. Now, if this was an x86 machine and you were working at an application level, the software would crash with a segmentation fault. There is no memory protection in AVR, so strcpy() will happily start copying the string to address 0 in RAM. This falls right into the register file if using absolute addresses, meaning that any variables that were cached on these registers are now trashed. Consider this test case:which compiles to:if done with avr-gcc version 4.8.2 and invoking the compiler with avr-gcc -O3 -mmcu=atmega168 -o avr.elf avr.cFrom the AVR instruction set manual, the st instruction says:
""Stores one byte indirect with or without displacement from a register to data space. For parts with SRAM, the data space consists of the Register File, I/O memory and internal SRAM (and external SRAM if applicable). For parts without SRAM, the data space consists of the Register File only.""which corroborates the above. Obviously, the compiler doesn't really know you trashed the registers, and will happily use them for other things, trashing them even further. Reading from them after the strcpy() will yield problems as well. You can fix the issue by making a buffer, if you want it global, as char message[8];. Since it is a global variable, all elements get automatically initialized to 0. As to why your data is getting trashed, I would have to see more of your code to determine why. Most likely though, due to memory corruption.Cheers."
21464832,"Dynamic array in C++ is found under the name vector. You call would become:There are multiple issues in your code, for instance:is a pointer, sizeof(_relay) is the size of the pointer, nothing to do with the size of the memory allocation it points to. So  sizeof(_relay)/sizeof(short); is equivalent to  sizeof(short *)/sizeof(short); which does not really make any sense.When you do:you are copying a pointer, now _relay points to the same place _pins point. However this memory where they points to was ""volatile"": it is a temporary you allocated at the call site. It will be de-allocated as soon as the call return. Your pointer is now pointing to an area you should not access anymore."
21467525,"It's generally questionable class design to have a C++ class contain a pointer to ""outside data.""  Often a better way to do it is to have your C++ use a copy of the external data, so it's clear that the memory is de-allocated when the class instance is destroyed.  Also as someone else mentioned, some of these things are much easier to do with C++11.  If you're using g++ or clang++ as your compiler, you may already have support for C++11, which makes a lot of things very nice and easy, especially for embedded system work.  In this particular case, here's a complete and compilable program (I used g++ and compiled with g++ -std=c++11 -o relay relay.cpp with the following as the contents of relay.cpp.  I've combined everything into a single file for simplicity of illustration, but in real life, you should keep the separation of .cpp and .h files that you already had.#include 
   #include The enum for the A0 through A4 lines are just for completeness in this example, but they might be #define or const int declarations.  It doesn't matter.  The two print...() functions are only for illustration to demonstrate that it's actually doing what's expected.  In this case, the output is:The std::vector is part of the standard library and could be used even if you're not using C++11.  If you are, then you can take advantage of such interesting things as move semantics and constexpr and other goodies that are of particular use in embedded systems.  One such nice feature is called a list initialization and is used within main in this sample program.  In this line:A temporary std::vector<short> is created and then used to initialize the reles class instantiation.  A clever compiler can, under some circumstances, optimize away the creation of such temporaries.  As always, looking at the actual assembly language output is useful for evaluating particular techniques and particular compilers.Another thing that I find very useful is the for (auto i : _relay) style of for loop. This tells the compiler to automatically infer the type for i by treating relay as a collection of something.  Very concise and very handy.If you're not yet familiar with the C++ language (or just the relatively new parts), I'd recommend getting a book such as Stroustrup's The C++ Programming Language, fourth ed..Edit:
In the unfortunate case that you have a very limited C++ compiler, as seems to be the the situation with the Arduino, you'll need to do things differently.  Specifically, because you don't have an operator new or operator delete you'll have to either pre-allocate some maximum size for your arrays, or simply rely on those being passed in as part of the initialization.  Here's one way to do that:"
21505275,"Please, note, that there is no easy way to specify additional flags from Arduino IDE or use other IDE (Eclipse, Code::Blocks, etc.) or command line.As a hack, you can use a small proxy program (should be cross-platform):You're done!Example avr-g++.ini:"
21506507,"It can get tricky using classes with Arduino/Wiring since, to simplify things for us, there is stuff that goes on at compile time which is not obvious (and not like using straight C++).For your task, writing a function to set the pin should work (and good practice - the whole encapsulation thing). The code below compiles (though I haven't run it).Careful with classes on Arduino though - there isn't much memory to play with so sometimes, the cleaner, more obvious approach won't work and one needs to resort to storing things in arrays and using lots of variables."
21607031,"You must protect against buffer overflow. The buffer tmp must be terminated with a zero value byte. tmp is static so is zero filled. Use a sentinel value (BufferMaxChars) to ensure that the final byte of the buffer is zero-value terminated.I am guessing here - but possibly you want to print out the string value enclosed with quotes. If that is the case, the tmp buffer would only be assigned once count == 1 (when the first quote char was found)."
21657278,"You where close, you just need to move the pin variable definitions out of the function.  That will make them have a permanent lifetime.  Your library probably does not need any module other than the .CPP file they are defined in to use the variables 'redpin', etc.  The addition of 'static' below means that these variable will not be visible to other code modules.  That means if some application by chance uses a variable 'redpin' then it will not interfere with your code.You showed no use of ledID.  Are you thinking there are more than one LED?  C++ will not construct variable names on the fly.  If you are going to have N LED's then the above would use an array."
21919499,In general case they are not the same.Let's assume that a and b are some expressions. For example a is expression x += z and b is a single variable yNow consider the following codeThe output is
22135948,"The best way to do this is to pass the value into the function as a parameter. Here's a simple example:Class:Sketch:The setup() function here passes global variable someNumber into the class's member function. Inside the member function, it stores its own copy of the number.It's important to note that it has a completely independent copy of the number. If the global variable changes, you'd need to pass it in again."
22138528,As much as Bloomfiled's answer is correct using the the more accepted practice of employing Getter and Setter functions. Below demonstrates this along with making the attribute public and directly accessing it.
22235592,"Nope :)A quick solution may be to wrap your code in a loop, like so:"
22297863,You could also use the combination of printf() and strtof():
22643927,"Well I managed to solve it by dividing the logic between priming for a answer, and then waiting for the input to the answer, if anyone is interested:"
23194097,"One obvious problem is that you are returning the address to a local variable:Here, the returned pointer points to the address of tempValue. This ceases to be valid once the function returns. Just use an int:Next, I doubt that this is a valid argument to Serial.println:but this should work:"
23242578,"Perhaps that is best Way to convert Float to Byte and Byte to Float,-Hamid Reza.regards.
    `"
23531356,"well, as the compiler is telling you, you can't print a HardwareSerial, because it makes no sense.Though, you're not taking the right approach for your problem, because this is a folded problem:For the first point, there's not much you can do, everything is setup at compile time, and that's what you'll have to implement: different usecases depending on different AVR.For the second point, I don't think there's anything to test that in the HardwareSerial class, though you can do it yourself:cf source code of HardwareSerial:in there:HTH"
23571875,"in arduino, i guess this is what you have:in that code, while a new character is being sent (and you've read the entire buffer), you haveso the main loop setsand you lose the previous data. Fix this inicializing cmd outside the main loop, and also inicialize c outside the loop:"
23634960,"You can really cut down printf if you remove the extraneous formats.
Here is an example alternate fprintf (printf is just fprintf with 1 as first arg) that compiles down to 1/2kb including my conversion functions (it could be smaller if you remove more)just comment out the formats you won't need and modify for your existing conversion functions - Also if you want it to be more compliant, make it an int function vs void and sum the returns of write for the return value ... though 99% of the time I don't use printf's return."
23735596,"You have a couple of errors/misunderstandings in your code, so I've added a bit of simple debugging that works by opening Tools>Serial Monitor after you've downloaded your code. In your EdgeDec() function (function = Java method) you had if(EdgeDec = 1), but EdgeDec is just an int with the value of 7. What you wanted was to read the value of a pin numbered 7 - if(digitalRead(edgeDec1) == LOW).also, I reversed your logic from HIGH (1) to LOW (0) because you hadn't tied down the digitalRead pins either LOW (using external resistors) or HIGH (using the Arduino's internal resistors) - read my comments in the code. Not sure what you were doing with the while(true) loop - maybe some further debugging? Anyway, hope it helps..."
23875869,The while loop and the delay() call don't help.  Say that the PC sends the START command to enable temperature sampling and STOP to tell it to stop updating them.  You'll need a bool variable to indicate state.  Something like this:
24267993,"I stumbled around on this for hours. The first answer works well, but leaves a bit to be desired, if you are wanting to compile your libraries as you build them.I'm not using Arduino's libraries folder, but instead referencing like so:#include ""../includes/MyClassName/src/MyClassName.h""Sublime Text 3 beta with Stino plugin (HIGHLY RECOMMENDED - I enjoy it a lot!)Arduino IDE version: 1.5.6 betaOk, now on to the code. Here is MyClassName.h:Here is MyClassName.cppThe benefit of doing it this way is that you can load up MyClassName.cpp, modify it, and then compile right then and there. If you have any errors, you'll know about it. Also, you won't have to update anything in MyClassName.h as MyClassName.cpp is included and the #ifndef's keep from double declarations.The only thing I'm not sure about using this method is that compile time may still be hampered by the inclusion of MyClassName.cpp in the .h file. That is the main reason for having separate files in the first place. Perhaps an expert in C++ could comment on this?"
24273173,Pass the values you want the function to output by reference or by pointer.  output will be 0 20 30
24420675,"Here's a way to do what you want that won't break if you're on a system with a different endianness from the one you're on now:You can see it in action here: http://ideone.com/umY1bBThe issue with the above answers is that they rely on the underlying representation of floats: C makes no guarantee that the most significant byte will be ""first"" in memory. The standard allows the underlying system to implement floats however it feels like -- so if you test your code on a system with a particular kind of endianness (byte order for numeric types in memory), it will stop working depending on the kind of processor you're running it on. That's a really nasty, hard-to-fix bug and you should avoid it if at all possible. "
24742504,Code works by simply adding a delay(100) after the first Serial.available()This is the code:
24758754,"Edit: I make a big edit of this post, because I think that's currently not the best solution. This edit is really similar to @MarkusMayer answer, but I came to it in a very different way of thinking (I think), so maybe it will help you.First, let define a GPIO pin, which can be anything you want (a class would be good, then you can do pin.setOutput() or pin.set(), etc. I let you define it the way you want, let's just assume we have a GPIOPin class.First, I define an abstract board as a set of pin, which look quite correct to me:Then I define interface for ADC and LEDs which are also abstract:Now I can create what represent the real board with ADC and LED:Then you create your own ADC and LED:Finally, you can simply use it as follow:I did not define destructor for MyBoard or Board but of course you can. You can also use shared_ptr like @MarkusMayer.End of edit.I think there are different approaches to this problem, I'll present here what I would have done. It is often difficult to use OO design on embedded system, first thing is that you should have singleton class almost everywhere because you've only one ADC (you cannot instanciate multiple ADC), so your ADC class (and LEDBoard class) should look like:To answer your problem, I would create a base class that do your initialization, and will do it only once (use of a static member to know if ports are already initialized).Then your ADC and LEDBoard class inherit from GPIOs:Then in your code, you simply do:You could also use a singleton for the GPIOs class but since it's an abstract class than is only used by ADC and LEDBoard which are already singleton, it's not the most useful.I'm sure there are plenty of other ways to deal with your problem, but the main idea I wanted to show is the use of init method / class that you can call multiple time without doing mutiple initialization because of the _init boolean."
24759886,"I'll sketch you an idea. I don't know of any design patterns for this, but the below may fit your need.Firstly I agree with your idea of using a GPIOPort to control the whole port, but I want to introduce a more modular approach than a ""class in a class"". Instead of setting up the ports in the device constructor, I suggest creating an object that describes the device, and let GPIOPort setup the devices based on these descriptors.My idea is to encapsulate the access to the GPIO through the GPIOPort class. But, leave the raw output open for the user of the code to work with. This could be combined with other classes as well, but they should be using GPIOPort in this design, and not the other way around.One (of many, sometimes conflicting) advices in OOP is that you should only subtype a class if its behaviour has changed. If you can express difference between two classes simply by changing the attributes, they are of the same class. I'm unsure if that is the case here, depending on how how much work you have to do to initialize a device."
24760569,"Some definitions:I highly recomment to not use a singleton. Some day you may connect a second device to other GPIO Pins and you will be in trouble.If you create separate classes for LEDBoard and ADCBoard, you have to ask: 
""What do I need to create a LEDBoard/ADCBoard?""
Well... You need a Device!So my design would be the following:You can use the classes like this:Benefits:"
24996105,"Example 1 on how to convert a byte to a hexadecimal, null terminated string:This method is usually faster than the second example below.Example 2 on how to convert a byte to a hexadecimal, null terminated string:"
25153311,"You have to actually allocate the array; and you'll want to use a pointer type, float array[] is not what you think there. As juanchopanza reminds us, you'll also want to either disable the copy constructor and assignment operator, or implement ones that do a proper deep copy.However, if you have some dynamic, automatic container at your disposal (e.g. std::vector) you might want to use that instead - then you don't have to deal with copy / assignment / destructor / memory management."
25153423,"If you only know the size at runtime, Jason C's answer is what you want. ( With juanchopanzas comment )If the size is known at compile time, you can use templates:Or use classes like std::array instead of std::vector."
25174645,"What should I do?Use your code as shown without any of the volatile and be happy :)The volatile keyword is only a hint to the compiler that a variable might change by unseen paths.  If a simple variable was modified only by the ISR, then it would not hurt to mark volatile.  Such a mark could prevent the compiler from doing the wrong thing with code like this:For your object, it is only about whether the changes introduced by the ISR cause variable changes that other users of the object might not see.  If the PID object is consuming the input and the only driver of the outputs via compute() there isn't an issue.  In other words, the changes in compute() are not affecting the main loop()The bigger concern should be consistency which is not fixed with volatile.  If setpoint is a 32 bit integer then the value in memory cannot change atomically.  The main loop() might have an innocent lineBut this involves getting the value from memory into a register, performing the math and writing back out.  At any clock tick in the process, the interrupt may occur.  Exactly in the middle of storing the new value of setpoint to memory, the interrupt might occur (will occur eventually).You protect this by disabling the interrupts in the main loop() while accessing the shared object.Now you are ensured that the interrupt will not occur at the exact worst moment and execute compute() on a broken value of setpoint."
25185476,
25219783,"The below code creates an array of your groups and then iterates through it, invoking a call to a Foo method for each of your instantiations (foo[0-8]). It makes a few assumptions about the contents of the arrays involved (namely the bounds on i and j), but it should do for the example, and should be easy enough to customize to your liking:Output:I hope that this answers your question. Let me know if it doesn't, and I'll see what I can do :)"
25344516,Your line static int* link[6]; // array of pointers inside your class definition is only a declaration because it is static. You need to ad a definition outside the class in a source file (not a header): int* Scenario::link[6];Something like this:
25580526,"If you change your code to a practical and simple 'helloworld.cpp' file and compile it with a GNU C++ compiler, you are warned about the problem with how you are currently returning a pointer to something on the heap that gets destroyed when getLat() goes out of scope:Compiling:At runtime, I see garbage:A quick fix, but not necessarily the best fix, is to allocate the buffer variable on the heap instead of within the scope of getLat().  Change GetLat() code like this:...this yields better results:Don't forget that you have to deallocate the heap memory storing the char[10] buffer object after you finish with it, or you have yourself a memory leak. :-)"
25827521,"I solve like this, but I am not satisfied.It's not important of '2,' is not display. 
How would you do better?"
26087477,"First off, using 'if' is more versatile than 'switch'. For example, if the value was 601, you'd still want the LED to flash, but your current code wouldn't do it.What you need is a persistent variable that's defined outside of the functions. You can't define it in setup() or else it won't be recognized in loop(). You then look for changes in the values read from the switches, and adjust the variable accordingly. For example:Note that how I've written it here, the threshold will reset to 600 each time the device is turned on. If you want the threshold to be persistent even when the device is unplugged, you'll need to use the Arduino's EEPROM. But that's more complicated. Let me know if you'd like me to get into it."
26484776,"This Web client sketch has been tested and works flawlessly.If for some reason it keeps hanging, you can implement a watchdog timer mechanism. For more info about WDT on ATmega328P Datasheet.
I have an example from one of my projects:"
26661151,"If char delta(e, z) {} should be a function definition, you have to remember the proper syntax to do so."
26807673,"It reads 'ÿ' because there is no char to read in the buffer. It takes some time for the others characters to unstack from the uart buffer. So, you cannot do a loop to read chars. You have to wait that another character is available before reading it. Also, this way of waiting characters is not the best way because it blocks the main loop.Here is what I do in my programs:"
26920512,"Your code is C++, but your error suggests you are trying to compile it as a C program because cstdio is the C++ version of C's stdio.h.Your compile command:Is trying to compile mycfile.c as C (not C++) which is causing your error. GCC detects the type of file based upon extension (.c for C, .cpp, .cxx, .cc , and .C for C++). Rename mycfile.c to mycfile.cpp, link the C++ runtime library stdc++, and run:I am unfamiliar with CImg, but if you're open to suggestions, you can
give stb_image.h a try:"
27022738,"With the tips I gained I created this solution.Thanks to cpburnz for pointing out to use stb_image.hstb_image.h is easy to use. I added 2 defines which should be added when using stb_image.h (as I noticed from comments in the .h file)The difference rates where not optimal yet. I created a test environment to optimize the color checks.I created a few 10x10 images.
- base image which is entirely red (255,0,0)
- test image 1 which contained red (255,0,0) and green (0, 255, 0)
- test image 2 which contained red (255,0,0) and white (255, 255, 255)Most of the time 255 was seen as 255, 254 or 253. And 0 was seen as 0, 1, 2.
I created an OFFSET (10) which I use to filter the result of these minor color differences.I created in c a small project which prints out all the red, green and blue values of both images and the difference. And also a visual representence of the difference between the images. (a '.' for same color and a '+' for different color)Below you see the result of my test environment with the base image and the second test image."
27192363,The error is really really really small and i noticed it just by luck. I changed the counter of the list to byte to reduce the steps. But if my list is empty it is -1 so this would not work. Thats all! changed the count to short type and it works!
27732957,"I think this is the solution for you, there is no need for an array since you can directly write the bits"
27918518,"It seems that this question is getting closer to How do I determine the size of my array in C?BUT, in the general case, you do have to provide the length of the array or use some guard element (like null-terminated strings). Somewhere up the call chain you must know the size of the array, don't you?A small example to show why sizeof() may not be correct:which, on my (64 bit) machine, prints sizeof a = 10, sizeof b = 8, sizeof foo = 5, sizeof bar = 8"
28450536,"The following code shows how to use the millis() function to determine the time between two events. Each time the piezo returns a value greater than 2, the elapsed time is displayed, and the timestamp is updated."
28501330,I think what you're trying to do is something like this:Note the syntax for the initialization of menu_item1 and menu_item2.  I added main() just so I could test this with a normal C compiler (since I don't have an Arduino with an LCD handy).  The output from my testing looks like this:And I think that's what you're trying to achieve with your data structures.  You'll just need to adapt this to your Arduino code and use these data structures to manage the menu selections on your LCD.
28825798,"The problem is that a c-string stored as an array of char cannot be copied, passed as argument by value,  or  compared like build-in scalar type. Solution 1: use string instead of char[4]. That's the recommended C++ way. They are extremeley easy and intuitive to use, and they have no real length restriction.  But if you desire to limit their length, you can control it at user entry.   Solution 2: if you can't use solution 1, because of technical limitations of an embedded system, you could use a structure/class for holding the string.  Here a templatized version: Solution 3: You can keep your data structures exactly as they are, but use strncpy() instead of assignment, and strcmp() instead of comparison.   "
28909945,Answer might be a little late but;It appears the Arduino IDE doesn't like member functions being declared in the class definition. Just to be clear:
29460225,"int seems to be only 16 bit wide on your target machine.
1 is an int, therefore shifting it by more than 15 bits invokes undefined behavour.  The solution is simple, you should use a long constant:The language you write in is not exactly C, but this solution should still be correct.Incidentally, 1 << 40 invokes undefined behaviour if int is 32 bits.  Below is a simple test:On OS/X with clang, I get this output:clang warns the programmer about the problem and insists on generating undefined behaviour, with consistently inconsistent output.  Amazing isn't it?  A good example of why one should never ignore compiler warnings"
29652157,"It does work when e==1. When e==0 the computation is trivial, since s and v fall out due to power of 0 always being 1. This is the code copied and altered only enough to get it to compile.Sample results:"
29984108,"You can print the binary value of an integer using the bitwise.As far as I am concerned, I'm using this kind of function to understand how it works :In this code, the i represents the selected bit. With this selected bit, I'm searching if it's a 1 using the logical AND (&) operator. If it is, I print ""1"" and I select the next bit until the end of the number (which contains 32 bits, because it's an integer).There is many way to obtain the value using the bitwise.. You have to try it yourself to understand better !Good luck!"
30092615,"First things first, that code as you've shown it will never deviate from a delay of 2000 simply because there's no way to exit from the initial for(;;) loop. That's probably the first thing you need to check and fix.In terms of being able to end a delay early, you can do something like change:into:This basically exits the delay early if the switch changes, so that you'll never be waiting more than 10 time units (rather than up to 2000).Just be aware that there may be an overhead to repeatedly calling delay. In other words, while delay(2000) may take very close to 2000 time units, two hundred calls to delay(10) may take a little more because of setup time for each call and so on.In fact, you can probably greatly simplify your code by not using hard-coded values at all. Instead, you can have a single loop with minimal delay, with some internal controls which work out when and how to change the LED (i.e., not every time through the loop).For example, something like this would do it. I haven't tested it since my Pi2 is still sitting in a box awaiting some time for me to play with it, but it should be pretty close:Basically, you have a single loop but one which loops every ten time units rather than every 500 or 2000. You maintain a separate counter which decides when the LED should be flipped and the starting value for this counter depends on the current cycle time.When the switch is flipped, that counter is zeroed so that it (almost) immediately changes to the next cycle."
30382989,Thanks for everyone's help.  In case someone has the same problem I wanted to show my solution.  Much of this code came from the devmem2 from Jan-Derk Bakker.Here are the two routines I wrote to read and write from memory.And here are the headers I used.
30640671,UART data is sent only in ascii format...you have to convert the integer data  to ascii format..use itoa() or do this one
31166790,"Since you would like to get better at programming, I would recommend starting by being more descriptive with your variables.  For example, flag doesn't really describe what that variable is doing.  It really resembles a timer, so why not call it timer_100ms?  Then you know exactly what that variable is for.I would also recommend using an enumeration for case statements so that what you are trying to accomplish is a little more clear.  For example:Doing this makes your code a lot more readable.That being said, to make your code more scalable - with the ability to create more LED blinks without adding more code - I would recommend starting with something like the following:Obviously, you would need to add the led_is_on() function to check the state of the pin you are using to flash the LED.  Since, I don't know how you have your LED wired, I didn't want to assume how that would be done.  It is very simple to implement though."
31507923,"It's possible you're overflowing in one of the situations.The multiplication of var1 and var2 (both long) gives a long which is then loaded into var3.If both info->accelXYZ[0] and info->taughtAccelXYZ[0] are int (for example), the result of the multiplication will be int which is then loaded into a long.The intermediate int form may be overflowing, something you can see in the following snippet:which outputs:"
31754875,"Thanks David for your comment on my question.
I found the answer by myself. I used serial.WriteData(""o"",1);Here is the complete code of my main.cpp. Just in case it might be useful for others:"
31935263,"If I understood well, it should look like something like this:With size, the size of you're array (10 for you). You should initialize you're array with 0 or -1 to be sure.
However I don't know the difference between ansi C and embedded C. Maybe ""for(int i = ;...)"" doesn't work and you'll have to create the variable i just before.
Not sure if that's what you wanted."
32026716,"Now your code is ready to be compiled, at least in my machine I could compile with no errors."
32081593,"I see you're using NeoPixels! It just so happens that Adafruit has some great tutorials on using millis() and micros() for timing purposes instead of delay(). They also include good material on interrupts, if you're feeling ambitious and want to separate your timing from your main function entirely (a worthwhile undertaking, if you have the time and resources).Part 1 (basics of using millis()):https://learn.adafruit.com/multi-tasking-the-arduino-part-1/overviewPart 2 (introduces interrupts):https://learn.adafruit.com/multi-tasking-the-arduino-part-2/overviewPart 3 (puts everything together):https://learn.adafruit.com/multi-tasking-the-arduino-part-3/overviewAlright, I edited your code, adding in a loop that checks for both delay periods to be done using millis(). I attempted to stick to the variable naming conventions that you've been using, for easy readability. There were also some other issues with your code syntax that I cleaned up. Make sure to effectively comment your code so that it's understandable, for yourself and for others!Hopefully this works the way you want it to!This new code should work, I've tested it and it works as expected on my machine.As a side note, your original question was ""How can I replace delay() by millis()?"". This question has been answered both by myself and by the previous answer author, user3704293. In the future it may be helpful to separate your questions to get higher quality answers and to better serve those who are searching for answers to the same questions. Once your question is answered, as I hope this question is now, you should accept the answer that is the best for you.Let me know if it all works out!To have LEDs change independently of each other, replace the loop() function in the previous code with this one."
32597149,"Something like this?EDIT
Here are two more ways to do it. The first is simpler, using the switch statement, which is really just another way of doing if...else..A little more complex is by using an array of function pointers. If you want to pass arguments to the functions, you'll need to change the array declaration too. The drawback is that unless you have variadic functions, they must all have the same arguments."
3271018,"Yes, to send these numbers you have to first convert them to ASCII strings. If you are working with C, sprintf() is, IMO, the handiest way to do this conversion:[Added later: AAAGHH! I forgot that for ints/longs, the function's input argument wants to be unsigned. Likewise for the format string handed to sprintf(). So I changed it below. Sorry about my terrible oversight, which would have been a hard-to-find bug. Also, ulong makes it a little more general.]And similar for floats and doubles. The code doing the conversion has be known in advance. It has to be told - what kind of an entity it's converting, so you might end up with functions char *float2str( float float_num) and char *dbl2str( double dblnum).You'll get a NUL-terminated left-adjusted (no leading blanks or zeroes) character string out of the conversion.You can do the conversion anywhere/anyhow you like; these functions are just illustrations."
32988850,"Surprisingly this compiled in Visual Studio 2015.Well, a vector is just a handle. Its elements are stored in the heap. All the vector needs is a pointer to these elements in the heap (data), the current number of elements (size) and the maximum number of elements (capacity).
So if you grow/shrink the vector, the handle's size always remains the same and only the array in the heap will change.This works because this and myVect.data() are both pointers to vClass in the managed array. You don't need to divide by sizeof(vClass) because pointer arithmetics take into account the size of the type they point to.sizeof(vClass) == sizeof(int), when you increment, decrement or subtract pointers they move in blocks the same size of the pointed type so you don't have to explicitly increment a pointer with the right size. You do get the indices 0,1,2,... but in other words that would also mean 2 vClass'es would fit between this address and this address.When you try this with an array of vectors, each vector is contiguous in memory (each handle). But also, each vector points to its own array in the heap so each array is completely unrelated. But I don't know exactly what code you tested with so I won't comment on that.The this pointer, given that your vClass instances belong in the vector, is actually linked to the internal array of the vector and not to the vector handle itself.This works because your class is a POD-class. If you were to make a vector of pointers (each instance would be in unrelated addresses), or use a pointer to a base class (each instance in an unrelated address AND derived types would have different sizes), then this wouldn't work.Although this example works, I won't encourage you to do this (besides this only works because your vector is a global variable). You're moving from C to C++, and I understand old habits die hard, but avoid pointer arithmetics unless you really must use it.You can get the vector's size by (you got it right) calling the size() method, and if you need to know an element's index you will know when you iterate the vector. (There are other ways sure, but that's up to you)EDIT: About indices and iterationWhen you iterate arrays or vectors, you can iterate by index (among other forms of iteration). So obviously, each iteration you know one index,Which is basically what you did when you printed your vector.If you need to know a specific index without iterating (whether you need it to erase an element, or direct access, etc), you can, for example, have a separate container with relevant indices, or store it in the object as an ID, like,Then when you push elements into the vector you can set their IDs and they will know their index. Of course, you have to update the indices yourself if you sort the vector. They won't ""auto-update"" like when you used the pointers, but your instances had to know exactly which container they were in and had to use implementation details to find their index (specifically for vectors), and contained objects shouldn't need to do that.As I said there are many solutions to this. It depends on what you want to do."
33260205,"With a dynamic flat array in pure C and then alloc the 3D array
The array size is double each time needed
You can set the first size with the define:as said in my comment the format is strange ;. should be . and the final ;. should be removedI add test to check if next line as the same size than the first one.output:"
33265128,"i hope you saved the last post, this is an update to the last one, it handle 2D arrays as requested. hope you find it useful, if so send me a postcard :) "
33325411,"I wrote the following code for PCF8591 using a C language.
This cord work fine.And you can use analogRead()."
33395761,"There are quite a few issues with this code.  There are probably other things that I have missed, but that should give you a starting point.  It looks like you have created a lot of code without testing to see if any of it worked.  I would recommend taking this a step at a time... code one logical block and see if it works before you move on to coding your next idea.  It may seem like it takes more time but, in the end, it is usually a much faster way to program.Another suggestion that I would make is to define variables within the function in which you use them.  Making all of your variables ""global"" like you have done is not a good way to write code.  For example:Note the use of the keyword static.  This will ensure that the value stored in number will not go away when the function ends.  In other words, the value will still be there the next time the loop() function is called.Finally, if I had to guess at what you were trying to accomplish, I would think your code should look a little more like this.  It appears as though you were trying out different things so I left a number of code snippets in there from your original code that don't actually do anything:"
33453961,on arduino using the time library github.com/PaulStoffregen/Time
33570151,"Also doing an Arduino project here...
Everybody on the internet seems to insist it's impossible to do this...
and yet the oldest trick in the book seems to work just fine with null terminated arrays...example for char pointer:magic..."
33693995,"Ok, if I understood correctly you want a function that1) you call once and it resets the counter
2) you call successively and tells you how much time passed
3) you can reset sometimesIf so, you have to ask yourself ""how can I reset the timer?"". IMHO the best solution is using a flag passed to the function.And... avoid using the millis function twice ;)And, BTW, I think you want to perform an action just once when you receive the serial data, so move the switch inside the test...Here is a sample:EDIT:Ok, then you want a ""stoppable"" stopwatch. What I suggest you is to detach the update from the serial interface, so you always have updated values. Or at least that's the way my head works :PI modified some things. You shouldHere is the code:"
34113238,"You can declare a packed struct to hold these two values:But to send it as two bytes, you'll need to either (1) ""union"" it with a two-byte array:(The struct is anonymous when nested in this union; the union has the name.)Or (2) cast a pointer to the struct to a pointer to bytes:They both print the hexadecimal value of the bytes: 0x02 and 0xC8.  800 is 0x320, shifted left by 6 bits is 0xC800.To send this to the PC, you may want to start with a special character sequence and finish with a checksum of some sort (Fletcher checksum is easy).  Then it's easy to throw away garbage characters and know when there are transmission errors."
34470137,"First of all, I agree with @Thomas Padron-McCarthy. Sending character string instead of a byte array(11 bytes instead of 3 bytes, and the parsing process) is wouldsimply be waste of resources. On the other hand, the approach you should follow depends on your sender:If it's periodic you can check in the time period of the messages. If not, you need to check the messages before the buffer is full.
If you think printable encoding is not suitable for you somehow; In any case i would add an checksum to the message. Let's say you have fixed size message structure:Now, you should check every 4 byte (the size of MyMessage) in a sliding window fashion if it is valid or not:If It's not a fixed size, it gets complicated. But i'm guessing you don't need to hear that for this case.EDIT (2) 
I've striked out this edit upon comments.
One last thing, i would use a circular buffer. First add the received bytes into the buffer, then check the bytes in that buffer. EDIT (3)
I gave thought on comments. I see the point of printable encoded messages. I guess my problem is working in a military company. We don't have printable encoded ""fire"" arguments here :) There are a lot of messages come and go all the time and decoding/encoding printable encoded messages would be waste of time. Also we use hardwares which usually has very small messages with bitfields. I accept that it could be more easy to examine/understand a printable message.Hope it helps,
Gokhan."
34503416,"You have methods apparently being created within the constructor, which is not correct. Each should be its own method, such as:Consider your code snippet within the constructor:This is actually being treated as a call to the function ledOn followed by a block containing the digitalWrite call, both of which are perfectly valid (other than the fact there is no ledOn function being defined, of course, something you'd no doubt discover at link time if you could get past the compile errors).The particular compile error that's preventing this is your attempted definition:As stated, this is actually more of a call to ledStrobe and unfortunately it's not a valid one since you're not supposed to provide the data types in the call (it would normally be ledStrobe(time);).So that's where the first error comes from. The second is because, since you're not actually defining a function receiving the time parameter, the code that uses it is complaining that it doesn't exist.Defining the methods correctly should fix both those issues, and that can be done with something like:"
34582497,"Sorry for the trouble, it turns out I was misusing the EEPROM.get function, and the problem wasn't my macro at all. The EEPROM library get() method is defined: https://github.com/arduino/ArduinoCore-avr/blob/master/libraries/EEPROM/src/EEPROM.h#L130, and the documentation here: https://www.arduino.cc/en/Reference/EEPROMGet.  I was simply missing the 2nd argument, accidentally using this:...instead of this:Here are 2 solutions I came up with that work.  -I prefer this method. It turns out the word ""inline"" in this case is optional, and makes no difference.
-This method makes my program 7610 bytes, with 472 bytes used for global variables. It takes 162 bytes less memory than option 2 below.-I prefer the above method.
-This method takes 7772 bytes for program space, and 472 bytes for global variables. It takes 162 bytes more than the above method.Thanks for everyone's help!  See @Chris A's answer here.Yet again I have failed to fully read the documentation. The EEPROM library Put function documentation here (https://github.com/arduino/Arduino/tree/master/hardware/arduino/avr/libraries/EEPROM) says, ""This function uses the update method to write its data, and therefore only rewrites changed cells."" Therefore, my update code is redundant. I just need to use the ""put"" function as-is. Refer to the EEPROM library's author's (Chris A) answer here too. So, I've learned a lot, and here's my final answer:"
34597599,"Pass-by-value:Pass-by-reference:Passing a pointer is similar to pass-by-reference, with some differences outlined here.The code you've written for testVal will perform manipulations on a copy of kd. This is not what you want.For small structs, the speed of pass-by-value and pass-by-reference will be similar. However, the memory footprint will be very different. Passing-by-value will make copies each time something is passed, which will take a lot of memory.There are likely optimizations because copies are being made instead of actual changes to the passed-in object that the compiler is making for you. This is done, however, at the cost of an incorrect algorithm.After passing-by-values, the changes will not be reflected in kd that is passed in. The pointers' changes will be reflected and will be correct."
34682045,"In your question - 
1. Plugin p = new Plugin();
2. Plugin o = OneWirePlugin(ONEWIRE_PIN);Below example will help .Run on IDE
Object slicing happens when a derived class object is assigned to a base class object, additional attributes of a derived class object are sliced off to form the base class object."
34812896,Declare the A::run method as static .The following compiles and executes correctly.Hope this helps out.
34959006,String to Long Arduino IDE:
3497740,"You say the function is returning a char, but yet you try to return a char* (the reference to the array).  So you either need to change the function to be a char*, or you need to return an actual char.  Also, you return a reference to memory that is no longer valid, you need to either malloc on the heap, or pass in the pointer to be filled with the function call.Edit: Further clarificationAll of these are pointers to arrays of type uint8 or char.This is regular data.This next line declares a pointer to an array of chars that has 8 elements.  This probably isn't what you want.  The sizeof macro is evaluating to 4 because that is the size of a pointer (compile and run the program below).  Also you need to change this to char * long_s = malloc(sizeof(uri) + sizeof(key));  Dont forget to free it later.This returns the pointer to the array that you just filled, not an actual char.These next lines should just be char * newURI = combine(key, uri);Edit: Try this out:"
35024024,"Here is an example using plain C (gcc):And this is the result:If speed is an issue, you can do the following optimisation:"
35025402,"Yet another way, without unions:
(Assuming byte = unsigned char)"
35033032,Try this which can help you
35033831,Try this code.
35484971,"The SHT31 uses 16bit read and write, rather than using 2 8bit writes you might be better off using wiringpi's 16bit write. wiringPiI2CWriteReg16(). Same thing applies to the read.Below is a very early copy of what I've done to read the sht31-d on a PI. It has no dependencies except i2c-dev.   Heater enable/disable is not working, but softreset, clearstatus, getserial & get temp/humid are all fine."
35530101,Your mistake most likely is to use == comparison instead of = assignment.Usage:
35759510,"Assuming that channelList is null-terminated, and that _channelList is supposed to be a class member, you could try this:Unless I'm missing something, that should take a C-style int array of any size, and copy it into _channelList.  If the passed array is larger than _channelList, it may cause issues.  If possible, you would be better off using a std::array if the size is predetermined, or a std::vector if it isn't.If the size is fixed:This should allow you to get the functionality you want.  [Note that you can also use the above delegation, true_type, and false_type constructors to fill C-style arrays as well as std::arrays, if you need to use them.]If the size isn't fixed:As a vector's length can be changed at runtime, we can use vector::assign to allocate space and store the entirety of channelList.Regardless of whether _channelList is stored as a C array, std::array, or std::vector, it's relatively easy to define getters and setters.Getter (entire thing):Note that to my knowledge, a C-style array returned in this manner must be stored in a reference variable.Getter (single element):You can define a setter for the entire thing using the constructors above.  I would suggest using std::fill() to erase the contents of _channelList first, then copying the new array into _channelList.  You can define a setter for single elements using the single-element getter as a basis.Setter (entire thing):Setter (single element):Note that this answer assumes that channelList is null-terminated, as it appears to be.  If channelList isn't null-terminated, but you want to stop filling _channelList at the first null element, then you'll have to do a bit more work, likely using your while loop.You can find working examples of most of the above here.  It's a bit of a mess, since it's just a quick program I used to test various things while typing up this answer.[My apologies for any typoes and/or errors I may have missed.  I believe I caught them, but there may still be some there.][Edit: Added a note about using fixed-size template constructors with C arrays.  Added the C++11 trailing return type way of returning a reference to an array.  Added a simple, working example.]
[Edit: Added an additional single-element setter for a vector.]"
35768838,"Justin Time's answer is the correct way to implement this in C++ (using arrays and vectors natively handled by C++)I just have to add this solution, which is the correct way to implement what you tried to do in C (i.e. using char arrays).There are two problems in your codeThere are two solutions here. The first one is to give _channelList a fixed MAXIMUM size (maximum means that if the passed channelList is shorter you will get a shorter list, ok, but the allocated memory will still be the maximum one).The second method dynamically allocates the memory for the array. You should, however, dispose it when you are done with the object (in the destructor). This means that if you create the Node variable you are ok (for instance, Node mynode;). If, however, you dynamically allocate it (with Node *p_mynode = new Node(); you will need to call a delete on it when you are done.Note, however, that if the malloc fails you will have a NULL pointer. In theory it should not fail, unless you run out of ram...Just one more thing. Using a 0-terminated int array is not a good idea, because if you have something like this { 15, 3, 0, 5, 10 } and then the terminator you will just get the first two numbers. It would be MUCH better to explicitely tell the array size (and save it in the object)"
35843096,You should initialize your base class in your constructor.
36174060,"The above code doesn't make any sense, Arduino or not. (Bear in mind Arduino uses C++).You are trying to define arrays _lPins and _cPins which have lengths _x, _y, _z which are uninitialized. A class has to have a fixed size, so that when you instantiate it, the compiler knows how much memory to allocate it (before calling the constructor). How can it allocate memory for unknown sized arrays?(Edited to add)I think StackOverflow has a constructive answers policy. Please do give a solution if you think I did something wrong (which is why I am here).I'm interested to know why you accept an answer which says ""Your code: ... is wrong."" but take offence at mine. The accepted answer posts no solution code, just some guidelines.This code of yours, not in the class definition, also makes the same mistake:That also generates an error. You can't declare a static array like that, with bounds of x, _y, _z where x, _y, _z are not constants. The array won't redefine its length in the future when you change x, _y, _z.In your constructor you are passing as an argument, a name _x which is also a class variable.C++ doesn't let you assign arrays like this:You have a lot of errors, not just one, eg.You really should go through and clean them all up. Likewise, IIRC, new and delete are also not provided on your platform Actually the Arduino provides new and delete, as well as malloc and free.I'm trying to be constructive, but there is no one-line fix. A rework is needed, sorry to tell you. And you might want to do some C++ tutorials. The code you are writing (although I can see what you are trying to do) is you hoping that the language works in a certain way, when it just doesn't.Below is a possible way of allocating the pin structures in the constructor, based on supplied array sizes. I don't think this is a great implementation, but at least it works. The showPins function shows that the data has been correctly retained.Output:"
36190693,"The answer to the question really depends on what is receiving the data being sent by the Serial class.If it's human eyes reading, then you apparently are looking to actually print a decimal number.If you are trying to pass it to another program who will reassemble two or more messages into a 64bit number, that's a different problem.But if it's for a human to read, from the arduino forums comes this example sketch on how to print a long longhttp://forum.arduino.cc/index.php?topic=58697.msg422207#msg422207EDIT
The observation in the comments that the modulus of 1,000,000,000 (a billion) can be used instead of 1,000,000 (a million) to allow a larger range is correct. But since an unsigned 64 bit number can represent up to 18446744073709551615, that is still more than 18 times a billion squared.   So even a modulus of a billion isn't perfect, After dividing by a billion, the result will not fit into a 32 bit integer.  A billion billion can fit into a 60 bit number[ACADEMIC ANNEX because the question does not seem to be coming off hold ]Three ways it can be done, geared more to look how, rather than optimized
The third one is probably good enough to be a real answerWarning:  None of these have been tried on an actual Arduino"
36205031,"The idea is to create a wrapper for function that will call said function when the object destructs. That way I can for example ensure some cleanup happens after exiting some function.The code you are trying to use seems like something that has been a little over thought, or at least tailored to some other specific uses. For the quote above, here is how I would accomplish the task using lambdas and simple functions.Now the calls can be as custom as you like, and the implementation stays nice and simple:"
36208035,Hoping this helps
36270201,"Duplicate of this.References can only be initialized, not changed.  To use it in the constructor like you have shown means that the reference member has to be initialized in the constructor:"
36435715,You can use macro to do that combined with stringify preprocessor:I hope this helps :)
36561669,"Danger Danger, you're returning a pointer to a local variable, Binary, that is on the stack, once the function returns it is out of scope and no longer valid.  This will cause weirdness, it will work some times and then it will stop working, don't do it!See Can a local variable's memory be accessed outside its scope?You need to pass in the storage.eg.On a ""real"" computer with an operating system there are many more memory management options than on a little arduino.  You could allocation from the heap and use something fancy like an auto_ptr to manage it (see What is a smart pointer and when should I use one?).This just isn't possible on something as small as an arduino.   You could however allocate it as a static.  This isn't appropriate for a fancy computer because it is not re-entrant and thus not thread safe.  Static allocation is done at program linking or startup and persistent across calls."
36691088,And more shorter convert:And than for get uint64_t from unsigned char buffer:
36744053,"_client is a reference to Client object. Unlike a pointer, you cannot change where the reference ""points to"". So you have to initialize it with a value. In your constructor you don't initialize your _client variable, but you try to assign it a value. Thats is why you get an error error: uninitialized reference member 'web::_client'To initialize a reference you have to use initialize list in the constructor. Here is a simplified version, that also uses just one constructor, since you don't have to have both overloads.Then you can create a web object:I suggest you read about references and pointers if you want to use them effectively. Otherwise you will continually have problems with them."
37332650,"I would revisit your design. I would do it like following:Implementation of my::unique_ptr and my::make_unique is left as an excercise, since it is trivial.Explanation - do not keep the references to something you do not really want to own. Instead, construct the proper implementation and keep it."
37333268,"If you want to construct the ntp_client with an r-value reference (i.e. a temporary) you need to give the temporary somewhere to live.The logical place would be inside the ntp_client, or something derived from it.This starts to argue for a factory function that makes either an ntp_client with an encapsulated wifi or ethernet UDP, or a reference to one. Is it possible to do this without using smart pointers or templates?yes, but templates make it easier with less typing..."
37410779,You can define a struct for the message and then define a matrix of that struct.Example:The best is to add requested signal status for each message:
37424512,"If you need only a sensor for all instances of motorIR, I suppose that it could be a static member of the class.Or a static variable in a static method; like thisYou can use it in this wayp.s.: caution: not testedp.s.2: sorry for my bad English--- EDIT ---The error is ""'NECIRrcv' does not name a type"" or ""'NECIRrcs' does not name a type""?In my example I've written, by mistake ""NECIRrcs"" instead of ""NECIRrcv""; sorry.About your need to begin() only one time the sensor, you can modify the getSensor() method in this wayCaution: not tested."
37425426,"I loved the idea of declaring the object NECIRrcv::sensor as part of class motorIR though, but trying to define NECIRrcv sensor(4) anywhere in motorIR.h leads to error: 'NECIRrcv' does not name a type; so it would be interesting to solve this problem in order to be able to implement @max66 's idea (or eve just to figure out why motorIR.h doesn't recognize NECIRrcv properly).In spite of that, I think I've run into an alternative solution: using an extern object (as it's described here).It can be implemented as it follows:In NECIRrcv header:In motorIR source file:"
37585008,Just shift 0 or 1 to its position in binary format :) Example 2. But is not tested!
37673354,"As your function is taking a pointer you'll need to get the address of root before you pass it. This is done using the & (addressof) operator.However, you should use a reference, then your code will be a bit simpler, and also look a lot cleaner (no addressof and no dereferenced pointers)."
38708913,"C++ does not support runtime sized arrays. Therefore if you do not know at compile time what size of memory you will need an array is the wrong tool for the job. I would instead suggest having your object contain only a pointer, and then use new to dynamically allocate the data block based on some runtime value.Note the following code is just to demonstrate the idea expressed above and is not tested, and probably does not compile.If on the other hand, the size is known at compile time, but you dont wish to edit the header file every time you need to change the size you could instead use a template class, these allow users to provide compile time parameters when they use the class. For example:The class can then be created with a custom size known at compile time as follows:"
39354052,"the following code should work: it prints ""1"". "
39667998,"The compiler is complaining about the lineYou cannot use the = operator to assign the contents of an array; an array expression may not be the target of an assignment operation.  Also, the result of getACOfNumber is an int *, which is not the same type as int [100].  This could work if you declared receivedNumbers asIn that case you're assigning a pointer to a pointer, which should work.  But, you have another problem:This will not do what you expect.  Once the getACOfNumber function exits, theArray no longer exists - the pointer you return is no longer valid.  IMO, your best bet is to pass the array as a parameter to getACOfNumber and update it directly in the function:"
39841866,Try to put SerialPort.Open() in try-catch block and call the SerialPort.Close() method after sending data:
39855376,Here is working codes....Thank you...............
39867143,"As pointed by @KIIV, it's better to specify Route directly inside the declaration of routingTable. As an alternative solution, you could redefined the struct Route toIn this way, reading both URI and function address from flash can be done by single call to memcpy_P. The complete codes:"
40093486,"Expanding on what KIIV suggested, you could possibly do something like this:"
40451154,"First, I think you left out some key information: it looks like you must be using an Arduino board with a 16-bit int type (e.g., Arduino Uno).The problem here is how integer promotion works in C and C++. When you cast a 16-bit signed integer literal, 1<<15, to a 32-bit unsigned integer literal, it will take the following steps:I don't have a 16-bit machine sitting around to test this on, but I can duplicate the same behavior on my 64-bit laptop with this test program:So you can see in this program, it's not the >> operation that's doing the unwanted sign extension, but rather the cast from a 32-bit signed integer to a 64-bit unsigned integer, because the cast actually acts like this:int32_t → int64_t → uint64_tIf you want to avoid the extra sign extensions, you should either start with an unsigned literal (as Some programmer dude suggested in his comment), or make a cast to the same-width unsigned type. Any of these should work:"
40623487,"Kevin's done an excellent job at explaining what the syntax error you got means and how to tackle it.In addition to that I'd like to point out an issue I spotted in Simon's question as well:float inByte = port.read();According to Serial's documentaiton on read():Returns a number between 0 and 255 for the next byte that's waiting in the buffer. Returns -1 if there is no byte, although this should be avoided by first cheacking available() to see if data is available.There are couple of issues:I recommend double checking if the data is displayed correctly in Arduino's Serial Monitor first. If it is, close Serial Monitor (as you can open a single connection to a serial port at a time), then run your Arduino code.You can also take advantage of this one weird trick: Arduino already knows what serial port and baud rate you're using and saves this as a preference (so you don't have to select the port every single time you restart it). This is actually stored in a Java Properties format that you can easily parse in Processing. You can easily find the location to this file from the Arduino Preferences panel:
Here's a basic sketch that tries to read the serial port name and baud rate from Arduino preferences then read a string and print it to the console (while trying to handle some errors):On the pragmatic side, you can always type in the port name and baud rate as you configure it in Arduino manually, just remember to double check the syntax, in your case:e.g.as Kevin pointed out"
40713161,"Try this: Edit: I just edited displaying of voltage, because value was int. But principe would be same."
41075677,"You need to use PROGMEM directly. The F() macro is code that requires a function.You can then cast the char pointer to a __FlashStringHelper* when needed.Oh, and the above is how you could do it if FS is a global variable, like your example. If it was a local variable, the F() macro could be used."
41080636,Awesome thanks for your help.  It turns out the way I want my code written Im using global variables.  I also want to pass the string as an argment rather than defining a separate variable.I ended up taking a different approach where I store the information into PROGMEM in the object constructor.  This has the needed effect of storing the data into PROGMEM and saving SRAM.
41272703,yes red and blue channels are reversed you have to process the buffer:
41430662,"it seems like a destructor's problem,I post a an implementation based on your code ..This is my result with your main:"
41650473,"You have to split it. You already know (or you should) that an int16 has, well, 16 bits (so it takes two bytes to store it).Now very small digression about endianness. With endianness you mean the order of the bytes when stored. For instance, if you have the value 0x1234, you can either store it as 0x12 0x34 (big endian) or as 0x34 0x12 (little endian).I don't know what language you use, so... Normally in C++ you do something like this:This sends in big endian format. If you prefer the little endian one, writeA simpler version can beIn the first case you know the endianness of the transmission (it is little or big according to how you code), in the second it depends on the architecture and/or the compiler.In JavaScript you can use this:and then send this new array. Credits go to this answerWhen you receive it, you will have to do one of these three things to convert itThe last method is the most error-prone, since you have to know what endianness uses the compiler and it has to match the sendong one.If the endianness mismatches you will receive what you think are ""random"" numbers. It is really easily debugged, though. For instance, you send the value 156 (hexadecimal 0x9C), and receive the 39936 (hexadecimal 0x9C00). See? The bytes are inverted. Another example: sending 8942 (hex 0x22EE) and receiving 60962 (hex 0xEE22).Just to finish, I think you are going to have problems with this, because sometimes you will not receive the bytes ""in one block"", but separated. For instance, when you send 1 123 555 (in hex and, for instance, big endian this will be six bytes, particularly 00 01 00 7B 02 2B) you may get a call to SimbleeBLE_onReceive with just 3 or 4 bytes, then receive the others. So you will have to define a sort of protocol to mark the start and/or end of the packet, and accumulate the bytes in a buffer until ready to process them all."
41724363,"You should factor out a separate QObject class that performs communications, and connect other classes to it.A well designed system will never have a UI class own and use a serial port directly. See e.g. this answer for an idea how to separate the communications and the UI.Let's see what transformations you could do to your code. At present you might have something similar to the below:The serial-port using functionality is spread across the UI classes, coupling them very tightly with the port. Let's fix that by factoring out the port operations:Finally, if you're tired of passing the controller around explicitly, we can implement a method akin to QCoreApplication::instance to get access to the unique controller instance:"
41754745,"I don't understand why do you convert the bitset to string. Just access it's elements directly.You could also go with bit shifting, that's the most low level way of doing this:If you're going with bitset, I'd recommend that you keep the bitset instead of using bool* because in bitsets, every bit actually occupies one bit, whereas bool is eight bits large at least.Finally, here's some test code I made for that, you can use it to do benchmarks:"
41764142,That's specifically what the function call operator is for.
41868368,"how to split char c into two separate integer variables?You can use the strtok() function to split a string (and specify the delimiter to use), like this :NOTE : If, generally speaking about such a problem to solve in c and not in arduino, you do not know for sure that you will have only two elements in nums, you should use dynamic memory allocation (read more about it here), and modify your code like this :"
42388182,"You have two Problems:First you hooked your ""for loop"" for the green color in(!) the for loop for the Blue color. Based on the fact that the loops running infinite you only loop through the second for loop.The second Problem (perhaps not a problem, but the reason why you don't see Blue) is your initialization of the blueVariable as 0.
If you run the first time, you write the value 0 to the PWM Pin. After that you change the variable, but do not write to the PWM Pin, because you get stuck in your ""infinite green Loop"".Btw, like said in the comments from Michael, you should change the 255 to 8 AND in your array you should change the last value (256) to 255 because the 8bit PWM means 256 values from 0-255.Example:"
43286729,"You don't need to put everything into a class.  I think using a class for the lights is overkill.In my experience, a functions are used to process the light pins and they all would take a pin enum.  Unless you have a huge amount of pins to set up, a loop may not be worthwhile.  Unrolling the loop may increase the programs efficiency:Initialization usually only occurs once, so optimization is usually not warranted.  If need to use classes, I suggest one class that models a single light.  Every light has an associated pin.You can have a container of lights (such as array):  An advantage to this model is that your program can be in terms of lights and not worry about pins."
43418731,"While I was trying to understand your question I realized what you needed was more than a single variable. You needed a class, this is because you wished to have a string that represents the hex code to be printed out and also the number itself in the form of an unsigned 16 bit integer, which I deduced would be something like unsigned short int. So I created a class that did all this for you named hexset (I got the idea from bitset), here:I assume you'll probably want to do some operator overloading to make it so you can add and subtract from this number or assign new numbers or do any kind of mathematical or bit shift operation."
43455977,"I found answer to my own problem. I used this time c++ to organize it in class (very poor one because it doesn't handle any errors and doesn't use c++ in the most..) Here is the code : This is more of a ripoff from ""Serial programming HOW TO"" : http://tldp.org/HOWTO/Serial-Programming-HOWTO/ (form the example code..)And here is the new poor arduino code :"
4359039,"I'll try the following:Or, even better, use a STL vector instead ..."
4359054,"Your code as I'm writing this:The declaration of _intArray is not valid C++: a raw array needs to have a size specified at compile time.You can instead instead use a std::vector:Note 1: some compilers may allow your original code as a language extension, in order to support the ""struct hack"" (that's a C technique that's not necessary in C++).Note 2: I've changed the name of your member. Generally underscores at the start of names can be problematic because they may conflict with names from the C++ implementation.Cheers & hth.,"
4359061,You should really use vectors as others have suggested. A work-around could be as shown (in case you do not want to use memcpy or a loop).This would be useful if you have a really huge array. Note that it would add a level of indirection to access the array.
43703784,"A ""blind"" or unconfirmed auto-repeat is not a good idea, because presumably it takes the Arduino some time to react to the command. Given that by default you have no flow control anywhere, you'll overflow the buffers along the way - in the USB-to-serial chip (if any), and also in Arduino. Since your packets (lines) have no error checking, you'll end up executing junk commands on Arduino, with varying effects.At the very minimum, the Arduino should send a message indicating that a command was finished. It can be a simple Serial.println(""OK""). You would then send the next command as soon as you receive the successful reply.This slows things down a bit since the next command can only be processed after you've finished receiving the reply and finished sending the command. Instead, you can pre-send one or more commands ahead of time, so that the Arduino is always busy.We can leverage Qt to concisely model both the PC side of it, as well as Arduino.A complete example follows, written in the literate programming style.First, we'll need a local pipe to communicate between the PC and the mockup Arduino. This is much easier than using QLocalServer.To manage the communications, the controller allows up to two commands ""in flight"" at any given time. This is a very simple controller - in production code, we should have an explicit state machine that would allow error handling etc. See e.g. this question.A user interface provides a button and a status indicator:
We're mostly done with the PC side of things - the test setup will come later, inside of main.We now turn to the Arduino side, and mock up a minimal Arduino environment. Recall that the Arduino ""language"" is really C++11! We implement Arduino functionality using Qt classes.We can now write the Arduino code, exactly as it would appear on the real Arduino. The LineEditor is a class I find missing in Arduino - it provides asynchronous input tokenization, and allows interactive line editing when TTY is set. When run on an actual Arduino, you could call Line.setTTY(true) and connect to the Arduino via PUTTY or any other terminal program. Yes - PUTTY is a general-purpose terminal that can connect to a serial port.An adapter class executes the Arduino environment:Finally, we set up the test and connect all of the involved components.
The Arduino object runs in its own thread.This concludes the example. You can copy-paste it into an empty main.cpp, or you can fetch the complete project from github."
43789817,"In the constructor of your class you are passing a pointer of the type Servo, so you must store that value in another pointer. To do this you must change:*.h*.cppUse:"
43824307,"Just try it:I dont know what your definition of HIGH is but since they are walking it 8 time across a byte i assume it is one bit, it is perhaps allowing for positive or negative logic on the port, so could be a 0 or 1 I am thinking.I get all 0x01 if HIGH is 1 and all 0x00 if HIGH is 0.  so it doesnt seem to be doing anyting.  When you have && for example that is a boolean expression not a bitwise logical, so perhaps this is a typo?the val&(HIGH<<i) though is pretty simple, again you should have posted what HIGH was defined as, lets assume it is a 1 since that makes the most sense relative to the rest of the code.  There is a loop i that goes from 0 to 7.  so that means that you are anding (bitwise) with 1<<0 and then 1<<1 and then 1<<2 and so on.  1<<0 is just 1 right?  so val&(1<<0) is the same as val&0x01.  1<<1 = 0x02 so val&0x02.  this code is one bit at a time isolating the individual bits in val.  you understand that if for example val is 0x07 then 0x07&0x02 = 0x02?  you line each bit up 0x07 = 0b00000111, 0x02 = 0b00000010you look at this vertically isolate one column at a time and use the AND truth table which basically says the result is 0 unless both operands are a 1, there is one column where both operands are a 1 so the result for that column is a 1, the rest of the columns one or the other operand or both is a zero so the result is zero for that column.Increment i two more times and evaluate against a val of 0x07 and you see what is happening at least with the val&(HIGH<<i) assuming that HIGH is a 1, if HIGH is a 0 then you will always get zeros come out of this code.If you are wanting to and with a walking one why dont you just do val&HIGH, so again this doesnt make sense unless that peripheral or what is on the other end of that port desires this one bit at a time thing.The double bang (!!) looks like a logical operation to me and has no business here IMO.A single bang is a logical operationThe hope here would be that we know the compiler will generate 0x00 for a false, but what does it generate for a true?  0x01, 0xFF, the C language probably has a definition.  So the above code is genrating a bitstream based on our valueIn the lsbit position, the the loop tickles a clock.My personal preference would not be to play games with the C language spec, but be explicit to what you want to do:using all bitwise operations, no boolean true/false operations.Wondering if they were trying to do two boolean nots in a row to shift the not-zero bit to the zero bit position or something...instead for lsbit first or 7-i for msbit first."
44078453,"From the looks of it you are trying to create a hierarchical menu system. (As the JSON Object is not an array, but more akin to a tree.)C++ would probably be easier to implement in because of the STL, I'm not sure on your experience but I'll give a general layout. Design-wise anyways.I hope that gives you some guidance. The older answer in C is good however doesn't allow for child items that you have in your JSON struct. This might be easier to work with IMO."
4524111,"This isn't a real answer, but I think it might be a step towards figuring this out.  Since there is so much code duplication and confusing conditional code, you should start with a refactor.  It will then be much easier to understand the algorithm.  I've taken a stab at it, though no promises that it will be bug free.Get rid of getShadowRam, and modify plot to look like this:"
45267685,"Disclaimer: I don't have an Arduino to compile and test this, but from the pure C++ point of view, I would declare the member in the class declaration and initialize it in the constructor. Like this:Then, instantiate the class like this:DETAIL:The MidiHandler class has a member variable named midiA of type midi::MidiInterface<HardwareSerial>, which is a template with one template parameter (the Type parameter from the macro). HardwareSerial is used as the value for the template parameter.The type midi::MidiInterface<HardwareSerial> has a constructor requiring one parameter of type HardwareSerial&. Therefore, MidiHandler::MidiHandler, the MidiHandler class constructor, needs a parameter of the same type to be used to construct midiA.Finally, Serial1 is passed as the constructor parameter to handler. Serial1 must be of type HardwareSerial& or convertible to it. The C stile cast, (HardwareSerial&), may or may not be needed depending on the type of Serial1, but I put it there since the macro had it."
45398726,So:Notice that this will provide the correct result if the data you are getting is a big-endian dump of some integer.
45528409,"I was recently having the same issue myself and I spent several hours trying to figure this out. Ivanov, you have a good point about the length of the encoded data. The main problem is basically when the AES encrypt function creates additional padding and the decrypt function not being able to remove it.This does not have anything to do with the null termination of the string or the fact that it lacks a terminator. The problem is actually solved by simply omitting the last 5 padding from the decrypted string.Edit This is actually more than just omitting 5 characters from the end. As I found out that the amount of gibberish or padding varies depending on the length of your original JSON, it makes more sense to trim the string by detecting the end of the JSON string.I am providing my (updated) working code for reference. I hope this helps anyone who also has this issue! Good luck with your project!"
45746878,"Yes, a substring is what you need.Fortunately, String provides a substring function.https://www.arduino.cc/en/Reference/StringSubstringYou code could look a bit like this:"
46465908,"While the question why the data comes corrupted still remains, here is a workaround I managed to achieve:Here's the code:Theoretically, it may produce false positives or negatives but in practice, it just works."
46632750,"This solution is efficient in the case that there are not many exclusions during the lifetime, once the exclusion function is quadratic.There is a struct called RandomArray that holds a pointer to and array with size N. N is the desired size of the sequence. The time and space complexity is linear O(N) for the create function.When an event happens it shall call the function excludeValue, with a time complexity of O(N) and space complexity of 1.If it is desired to exclude a bunch of values, the function excludeValues (pay attention to s at the end) shall be called. In this case the complexity is O(N x K) and the space complexity is 1. K is the amount of values that shall be excluded."
47358047,The constructor gets called before the serial interface is initialized.You need to have a begin method that is then called inside setup().Client.hClient.cppYour program:
47475409,You need to make the DHT object part of the AM_2301 class and then initialize it using member initializer list.AM_2301.hAM_2301.cpp
47514957,"## is the concatenationThe preprocessor expands the definition to the concatenation of lft, t, _ and rgt.For instancewould concatenate the tokens ABC, DEF, GHI and _ toEditSay you define TIMER_TO_USE_FOR_TONE to be timer 3, for instancethe result would be"
47719243,"Actually, I considered the question a little bit too broad. On the other hand, I couldn't resist to ""try out"".First, I want to criticize (a little bit) the question title. simple logic parser sounds for me like an interpreter of boolean expressions. However, I remember that my engineering colleagues are often talking about ""program logic"" (and I've not yet achieved that they get rid of this). Hence, my recommendation: If you (the questioner) are talking with computer scientists, use the term ""logic"" sensible (or they might look confused sometimes...)The sample code MD1,TP,RP5,TT,RP10 looks somehow familiar to me. A short google/wikipedia research cleared my mind: The Wikipedia article Numerical control is about CNC machines. Close to the end of the article, the programming is mentioned. (The German ""sibling"" article provides even more.) IMHO, the code really looks similar a bit but seems to be even simpler. (No offense – I consider it as good to keep things as simple as possible.)The program notation which seems to be intended is somehow like Reverse Polish notation. I wanted at least mention that term as googling for ""rpn interpreter"" throws a lot of sufficient hits including github sites. Actually, the description of the intended language is a little bit too short to decide certainly which existing S/W project could be appropriate. Having said this, I want to show what I got...I started first with a parser (as the questioner didn't dare to expose his). This is the code of mci1.cc:I compiled and tested with g++ and bash in Cygwin on Windows 10:Uploaded for life demo on ideone.I introduced the function tokenize() as part of an update. (I got the idea when I was tooth brushing and poring how to get rid of the ugly nested switches of the previous version.) Tokenizing is a common technique in parsing – however, the implementation is usually a little bit different.Thus, the parser seems to work. Not yet the next big thing but sufficient for the next step...To interprete the parsed commands, I started to make a resp. back-end – a set of classes which may store and execute the required operations.The parse() function of the first step became the compile() function where simple standard output was replaced by code building and nesting the operations. mci2.cc:Again, I compiled and tested with g++ and bash in Cygwin on Windows 10:Uploaded for life demo on ideone.The trick with the nesting is rather simple done in the compile() function:commands TP and TT are added to a temporary stack pOpsNestedfor command RP, all collected operations are added to the RP instance popping the pOpsNested stack (and thus reversing their order),
afterwards, the RP instance itself is pushed into pOpsNested stack insteadfinally the contents of buffer pOpsNested is added to sequence MD (as these are the top-level ops)."
47901638,Thanks to @Someprogrammerdude to help. I needed to declare the read function as static.SRF08.hSRF08.cpp
48137835,You need to qualify it with Stepper scope -and use enum class if possible -
48380857,Hope this would be helpful
48475418,"Boost is mostly header only, so, unless your platform lacks language level support, boost variant/any/type-erasure/containers should work for you out of the box ...Anyway, if you still want to write your own type-erasure solution, the idea is to incapsulate the 'generic' behaviour behind an abstract interface, and let the virtual dispatch mechanism invoke the actual, templated implementation, something like:more precisely, a truly type-erased solution would hide the unique_ptr layer behind some regular type (eg. see std::any, std::function<void()>, ...), anyway, I hope you got the basic idea ..."
48549454,"It may not be the most elegant solution, but the following is an option: define an EventArgs structure that can hold any kind of data, then do a cast in EventHandlers. Here's a snippet I just wrote (not a native speaker of CPP though):Inspired by Backbone events and the general Event Bus pattern."
48557412,"Here is my take. If I understand correctly, each observer knows what concrete observable is monitoring; the problem is that the observer only gets a base class pointer to the concrete observable and hence cannot access the full interface. Assuming you can use static_cast as previous answers have assumed, my idea is to create an additional class which will be responsible for casting the base class pointer to the concrete one, thus giving you access to the concrete interface. The code below uses different names than the ones in your post, but it illustrates the idea:As you can see, you do not need to cast every time you create a new observable; the wrapper class does this for you. One issue you may face is registering an observer to the wrong observable; in this case the static_cast would fail but you would get no compilation issues. One way around it is to have the observable expose a string that identifies it and have the observer check that string when it's registering itself. Hope it helps."
48566767,"My previous answer does not take into account that the same observer might me registered with different observables. I'll try to give a full solution here. The solution is very flexible and scalable but a bit hard to understand as it involves template meta programming (TMP). I'll start by outlining what the end result will look like and then move into the TMP stuff. Brace yourself, this is a LONG answer. Here we go:We first have, for the sake of the example, three observables, each with its own unique interface which we will want later to access from the observer.Notice that each observer exposes an id function returning a string which identifies it. Now, let's assume we want to create an observer which monitors the clock and the account. We could have something like this:I am using an unoderded_map so that the correct dispatcher_function will be called depending on the id of the observable. Confirm that this works:A nice thing about this implementation is that if you try to register the observer to a temperature_observable you will get a runtime exception (as the m_map will not contain the relevant temperature_observable id).This works fine but if you try now to adjust this observer so that it can monitor temperature_observables, things get messy. You either have to go edit the simple_observer_clock_account (which goes against the closed for modification, open for extension principle), or create a new observer as follows:This works but it is a hell of a lot repetitive for just adding one additional observable. You can also imagine what would happen if you wanted to create any combination (ie account + temperature observable, clock + temp observable, etc). It does not scale at all.The TMP solution essentially provides a way to do all the above automatically and re-using the overriden implementations as opposed to replicating them again and again. Here is how it works: We want to build a class hierarchy where the base class will expose a number of virtual notify_impl(T&) method, one for each T concrete observable type that we want to observe. This is achieved as follows:The combined_interface class inherits from each interface_unit and also allows us to register functions to the map, similarly to what we did earlier for the simple_observer_clock_account. Now we need to create a recursive hierarchy where at each step of the recursion we override notify_impl(T&) for each T we are interested in.At each step of the recursion, we register the dispatcher_function to our map. Finally, we create a class which will be used for our observers:Let's now create some observables. For simplicity, I assume that the observer has not data:Now we can easily create any observer we want, no matter what combinations we want to use:I can appreciate there is a lot to digest. Anyway, I hope it is helpful. If you want to understand in detail the TMP ideas above have a look at the Modern C++ design by Alexandrescu. One of the best I've read.Let me know if anything is not clear and I will edit the answer."
48603804,"You get this error because of this:This variables are double pointers, strtok returns a pointer to char, those
are not compatible types.Because strtok returns char_array + some_offset and char_array is a local
variable in setupWifi, you need to do a copy for each of them and return the
copy instead. You can do it with strdup.I encourage you to always check the return value of strdup, because it can
return NULL.1If your system does not have strdup, then you can write your own:One last thing: It looks really awkward, never seen declaring double pointer this way. Much
easier to read would beFotenotes1While the syntax is correct, I still consider this bad practice,
because you should always check the return values of functions that return
pointers. If they return NULL, you cannot access the memory. This adds a
little bit of more code, but your program will not die of segfaults and it can
recover from the errors.I'd also change your function to return 1 on success, 0 otherwise:"
48617982,"You must not call pthread_exit() in the cleanup functions, because pthread_exit() will also call the cleanup function registered for the thread.So, in your program, the cleanup function is called recursively and the threads never exit.About the kill from another terminal, the command kill -9 and the pid of the process should always work because SIGKILL can't be ignored nor caught.And in the signal handler function, you have to use async-signal-safe functions, printf() isn't async-signal-safe.Another way to wait for a signal in the main thread is to use sigwait() or sigwaitinfo() instead of pause(), like you did for SIGALARM in a thread. So it won't need to register a handler function, but it will need to block the signals to be caught in all threads.Exiting the threads task2() and task3() with a flag seems to be complex, because the main thread have to send SIGALRM to task2 in order to wake it up, and also signal the condition in order to wake up task3.I modified your code to try to use a flag, but i may have missed an eventual problem because synchronizing threads may be complex.In the case of your program, I haven't enough knwoledge to say if it is better to use pthread_cancel() and pthread_testcancel(), or to use flags. However, pthread_cancel() seems to be able to cancel without synchronization problems, threads that are waiting for signals or for a condition.Using a flag, for task3, there could be the following problem:In this case, thread task3 won't exit, because it wasn't waiting when the condition was signaled. I'am not sure, but this problem is maybe avoided by protecting the flag with the same mutex we use for the condition. Because when the flag will be set and the condition signaled, task3 will be waiting for the condition or doing work out of the critical section.I don't know if there may be a problem for task2, for example if the signal is lost due to an internal problem, but normally, the signal will be pending.Here is the code of my test. I placed 1 as argument for the function pthread_cleanup_pop(), to make the threads execute the cleanup functions."
48848599,"There are a number of problems with your code, some of which I have commented here. I encourage you to read up on some literature to familiarize yourself with the C language. As writing C code without much experience can be frustrating especially if you're not even sure with what your doing to begin with. And there are some ways to get this code to run faster if you want to create some of your own optimizations, as the scrollLeft code that I wrote doesn't take into account that the array only has one '0' and all other elements are ' '."
49121546,"The algorithm would look like this. This example only print the tokens, but you should be able to modify it to handle the keys, the values and the exception cases.As for data types, you can use methods of the ctype.h header file (link). For example, you can verify if a string is a number by iterating through all characters of the string and verifying that all chars are numbers (the isnumber() method)."
49191686,"Your problem starts at this point:It looks like, that your method needs to get a function which can be called without any object, so that you have to use a static function.But a static function, defined in a class, can not access data members from an object! Simply there is no object involved while calling a static function from a class.If you do not want to make your variable also static, which will end up in making everything static, and has the effect that you can not longer use multiple instances of your class you need a way to bind a object and a method to your callback.I have no idea how your startupTimer.setTimeout is defined. But if it simply takes a pointer to a callable object, it can be made as this:And the endInit method must be NOT static anymore.If your timer interface did not providing adding some user data to the callback, you have no chance to set the object data to the callback. Such an interface for a timer object is nearly useless. This makes it impossible to use any kind of OOP. So there is only a chance to make a list of static/ global scope helper functions. THIS IS VERY BAD DESIGNHere a very bad work around:The idea is to keep multiple runtime objects ( like your ESC objects ) into a list which is generated in compile time. So here a template provides the second parameter which is an index to the instance you want to call.
Because the template provides a static callback method ( forwarder ), it can be used to be used itself as callback to bad designed interfaces. As said: This is a very bad idea. Better use a full featured Timer lib!"
49226416,"I think that the code has some the memory problems. The node's address(pointer) is duplicated (double free problem). If you want to copy the structure, it needs new memory allocation and readdressing of the nodes for linked list.output is this"
49281947,"You need to only call wiringPiI2CSetup() once in the process.  One way this can be achieved by using a static variable for xio so that it will retain the value between calls:Another way would be to call wiringPiI2CSetup() each time you enter the routune, but then to close it between each call:"
49535098,"here is the answer to my question:the input: $./a.out 3
the output:"
50179256,"Unless there is a pressing need for you to use a union, don't use it. Simplify your class to:If there is a need to get the full byte, you can use:"
50203140,"Years ago when I was working on a C++ project happened to me too. Defining classes solved the problem.You can see my example files here:https://github.com/tkduman/project-x/blob/master/monster.hhttps://github.com/tkduman/project-x/blob/master/player.hThey have class monster; and class player; in each other, otherwise it won't work.Try to update your files as:CDFrame.h file:CDScreen.h file:"
50203306,"The problem is that C++ is declare before use, so any type must be declared before it can be used. (Where ""before"" means ""above in the source text"".) For types with circular dependencies, that means that the types need to be declared before they can be defined. That is done with a forward declaration, which simply introduces the name, without defining the type. In this case, such a declaration would be class CDScreen;.(Note that after a forward declaration, you can use pointers to the type, but not actual objects of the type as it is not yet defined.)As opposed to Java, C++ does not require you to place each class in a separate file. In fact, it is often preferable to put a group of classes that belong/operate together in a single header file.In particular in cases like yours with circular dependencies, putting each class in a separate header file/compilation unit can turn quite brittle. For instance, the order in which the user includes the header files can matter, leading to seemingly random compilation errors.In your case, I would argue that the best option is to put the classes in the same file, and add forward declarations at the top."
50218649,With respect to Arduino version 1.8.5First Refer HardwareSerial.h and you will see following lines:Then Refer HardwareSerial0.cpp. You will see following code:
50279664,"Just to add onto the list of possible solutions. 
I use the following function:"
50504426,The definition for sprintf is  So if you want to convert your number into a string (and that is what sprintf does) you have to give it an array of char where to put the string:That should solve your compile error.The second problem is you dec_to_bin function. The return values does not matches the value you are returning.
51023233,"The problem is your label declaration. You create a local variable label wich is destroyed at the end of the EDLController constructor.
You can confirm that by inheriting QLabel like this :The ""LABEL DELETED"" message will be logged when the QDialog is instanced. 
And, of course, you cannot display a deleted widget.The correct code is the following :The label will be destoyed when the parent item (your dialog) will be destroyed."
51088121,"It's not about what's happening inside the loop, but what's happening outside.The C++ compiler that comes bundled with Arduino is pretty smart. It figures out whether it is possible to reach an instruction or not. If a large declared variable is only referenced in a part of the code which will never be reached, it does not calculate the memory required for that variable while calculating dynamic memory.A simple test case would be the following. Now depending on which of the following combination are declared, the dynamic memory changes in the following manner.WHILE_COMPARE is defined, USE_TEST2 is defined, the DM shoots to 402 bytesWHILE_COMPARE is not defined, USE_TEST2 is defined, the DM is 209 bytesWHILE_COMPARE is defined, USE_TEST2 is  not defined, the DM is 209 bytesWHILE_COMPARE is not defined, USE_TEST2 is not defined, the DM is 209 bytesI hope this helps."
51331639,"EthernetServer ArduinoTcpServer(uint16_t); declares a member function named ArduinoTcpServer.  To declare a member variable, omit the parameter type and parentheses.  Also add a constructor to initialize the member variable, e.g. :"
51371901,"The fold expression based or recursive template solution is superior. But, if you wanted a preprocessor solution, you can see if your compiler provides the inclusion depth as a predefined macro. For example, GCC provides __INCLUDE_LEVEL__ (and MSVC provides __COUNTER__). You can then use recursive inclusion up to a limit to generate your template function calls.This technique is limited to the nested inclusion limits of your compiler."
51408145,Solution by OP.
51425069,"I ended up following the advice of VTT, and creating my own array wrapper.I'd love to hear some feedback if there are things that I have to look out for, or possible bugs, etc."
51611129,"Get some inspiration from this code. This is very generic canonical serial programming using C.NOTE: Canonical input processing can also handle the erase, delete word, and reprint characters, translate CR to NL, etc..I suggest you to read this article in order to know more about the serial programming settings, different mode. HowTo serial programming."
51640003,I ended up using a very different method to get it working by using char arrays and not relying on timing. So far it has worked perfectly. I was using this to get my arduino to work as a temp monitor.How it communicates the temperaturesPC > OpenHardwaremonitor > WMI > Batch Script (shown below) > COM Port > Arduino > LCDThis was the only way that I could get cpu temps correctly because it's so oldBatch code:Arduino code:
51823413,"I found the problem, what is url.c_str() doing?change this toExample : Curl program that download the text file.Offcourse you need to add this neccessary header file here."
51887950,"This is a very simple problem, like all simple problems no need for external libraries for serializing etc. Like @Galik  said above your problem is how to send a string from client to server. Additionally for your case you need a JSON parser on the server (any C or C++ parser from the JSON page will do, I use gason because it's fast and simple). In TCP/IP socket programming you have to make the other part know how many bytes (characters in your case) to read.I faced a similar case: send JSON over the web.
here's the example, a JSON ""message""https://github.com/pedro-vicente/lib_netsockets/blob/master/examples/json_message.ccin this case, the size of the message has this header formatwhere ""json_string"" is the JSON text, ""nbr_bytes"" is the number of characters ""json_string"" has and ""#"" is a separator character.how does the server parse this?
By reading 1 character at a time until the ""#"" separator is found, then converting that string into a number;
then make the socket API read ""nbr_bytes"" characters and exitexamplein this case ""json_txt"" has 100 charactershere's the code for the parser"
52106681,One way is to include time.h header and use difftime function. It will be implemented to check if the elaspsed time reaches the set time.example:
52224684,I found a code to execute using bcm2835.
52261636,"Caleb helped me very much. It's not really worked what i wanted, but i found another post on ubuntuforums.org (Keywords have been: c pid_t fork kill exec). And that was a really good answer. So Thanks to your help Caleb. It should be an vote up, but my rep isn't high enough. So sorry. But it said it has been recorded.So heres the link to the post: https://ubuntuforums.org/showthread.php?t=675734And here is the Code:I hope any other people with also this problem, could solve it with my question and answer.But a big thanks to Caleb."
52560467,"If you think about it, there are 256 possible combinations, but you're only interested in 8 fans, so all that you need to check is 8 bits:You need the 8-i part as your bit order is in reverse (fan1 as the leftmost bit) with the value order (MSB is the leftmost bit)."
52789041,"problem solved, just need to add a const before the type of the parameter as follows:"
52856558,"You could add a parameter to the call back, as mentioned in the other answer. Another option is to eliminate the callbacks altogether and use OOP design. Create a wrapper class around an int, with virtual functions for get and set.For the i2c parameters, you can extend this classTo use it you could do something like:I know Arduinos are very limited on resources, so I would be interested to see how this code performs on the device. "
52963674,"Yes, it is possible to put the classes in the main file and use the classes. 
You must initialize the classes before using them in void loop(), else the class won't be recognised. For example:Personally I think it is a better habit to put classes in separate .h and .cpp files for readability. "
52990743,I have updated your code and is working fine now kindly take a look.This works as follows:
53121168,"Your existing solution can be extended to handle multiple photo-diodes simply by using an array of DiodeResult instances:Or perhaps more ""Arduino-like"":However it relies on the photo-diode state remaining active for at least as long as it takes to iterate all ten sensors.  This may be the case, but it highly dependent on your application and possibly the implementation of readDiode().  It may be necessary if polling is not fast enough to use interrupts.Moreover the solution could arguably be improved by a little OOP:It looks a little long winded, but not how simple the individual elements are, and the cMonoStable class can be applied to other sensor types with similar characteristics, just be implementing a super-class with a different update() implementation."
53123121,"As @Lightness Races in Orbit mentioned in the comments. You can declare pointer to a Foo in global context and in the setUp function you can initialize in the global pointer with new'd object of Foo.Using struct doesn't make it Bar immutable. In C++, structure is equivalent to a class just with an exception of default access specifier being public. One way to make Bar immutable is to make members private and make sure only the constructor can modify it. Following example gives one such example with immutable Bar as member of Foo class. I hope you find it useful."
53226584,"Since the Arduino IDE by default doesn't seem to include <functional.h>, I wasn't able to use the answer using std::function<void()>. However, after some experimenting I realized there was an easier way, which also has the benefit of being able to model the listener.The listener class simply contains function pointers to each listener callback function, and a constructor that takes an argument for each callback. Then it's very convenient to just create a new instance of the listener class and pass each callback as a lambda.Not sure if there are any drawbacks with this solution, but it works, is readable and is fit for use on Arduino."
53237093,"It seems like you want to have a h.264 stream from the camera.OpenCV is unbeatable when you want to do some processing on the camera frames, but I would not necessarily use it for a task requiring to get H.264, since the Pi has a hardware h.264 encoder and I am not sure that gets used in your case.For getting a h.264 output to a file, or to stream it somewhere, you can either use the standard raspivid application and pipe its output where you want, or if you need more control, you can take it's source code and modify it.I got lazy and did the former. The code below streams the H.264 stream to a TCP socket.
If there is congestion (i.e. the data can't be written to the socket fast enough, the code will close the socket, after which my client re-connects). The approach may not be extremely elegant, but I have been using this for a while and it seems to work OK."
53585255,"i missed an unsigned byte in do_undelta7
so now it's decoding well
c#"
53613013,"As others have said, a pointer to a local variable becomes invalid as soon as the local variable goes out of scope, so it shouldn't be returned. You can instead create a ByteArray object that you can return-by-value from your functions. Example using ArduinoSTL:   "
53728861,"Yes, there are things wrong with it.serialOpen() returns -1 if the operation fails, with errno set to indicate the error.Make sure you include <stdlib.h>, <stdio.h>, <string.h>, <errno.h>, and <wiringSerial.h> at the beginning of your program, and open the serial port using e.g.write() may return a short count. You cannot just assume it sent everything successfully. I recommend you use a helper function, for examplewhich returns 0 for success, and nonzero for errors. You can use it thus:Don't do sleep(). At minimum, make sure you include <termios.h>, and doto ensure the kernel sends all serial data; it will return only after everything written thus far to fd (fd being open to a serial port or tty).Also, I recommend against using serialPutchar(), serialPuts(), serialPrintf(), and serialGetchar(), because they do not have any kind of error checking."
53939190,"So, I do figured this out. The following code is close to reality example which I was posting earlier.This code is just a small part of a project (main code). I found imposible / unnecessary to post whole project because there are lots of unnecessary stuffs that definitely will require a bunch of time to understand. Initially I thought there were a problem with a pointers, particularly in A::myPublicMethod, that creates *ptr, that then being transferred to A::privateMethod1 to store in vect1. I was wrong thinking there is a mistake while saving / transferring to vect1. Lately I didn't find any changes for vect1 in a main code. 
Vector vas created well, the problem was in method doPrint, particularly in if(name.length() > 0)... So again, I had to stick to the logic of main code without inventing an example which was a lil far from reality.In conclusion thanks to @paulmckenzie who indirectly gave me a reason to stop thinking in pointers. It would help me a lot if someone just confirmed that following my first example, pointers are logically correct.Cheers,"
54066668,Pass directly functor to your class:With usage:
54158227,"While I realize you say you want a global object shared between a library and your private libraries, I am going to assert that is not the best design pattern as it is brittle and error-prone (as you are experiencing). A better approach is to pass the SysLog object you create in your main code as an argument to any method that needs it. The reason this is better is because you are explicitly declaring then what methods can and should use the Syslog object.However, if you really must have a global variable, the second best pattern is to use a accessor class that looks something like this:SysLogHelper.hSysLogHelper.cppThen anywhere in your code you want to use the SysLog object, simply include the SysLogHelper.h header, and use your SysLog instance by calling the static method, something like this:Feel free to rename things to your preference. Also, with some creativity, you can have more than one SysLog object in this accessor class, each configured differently."
54167315,You can write this LinkedList template class and simply call it wherever you want :Use this class as follow:
54206070,I solved it by adding a virtual method that is overridden in every class that needs the Type-identification. For ease of coding I defined the code that should be repeated in every class in a single #define.Any suggestions for improvement are welcomeThe output of this is:
54225237,"Q1) your version of atoi() is too simple, the standard version ignores leading whitespace characters and handles an optional sign before the number. atoi("" -123junk"") should evaluate to -123.Q2) atoi is a standard function defined with the prototype int atoi(const char *s); it returns an integer.Q3) There are a few mistakes in Code 2:Here is a modified version:Q4) the expression n = 10 * n + (s[i] - '0') is evaluated for each new digit found in the string. It is indeed slightly inefficient to multiply the current value by 10 as long as no non-zero digit has been encountered, but writing the function this way is simple.To avoid these useless multiplications, here is an alternative:But this function is more cumbersome and might actually be less efficient that the simple version. Try and benchmark both on your system.For completeness, here is a full portable version using ctype.h> that handles optional initial whitespace, and an optional sign. It also handles overflow with defined behavior, although the standard version of atoi() is not required to do so."
54273915,"I did a test and found out exactely what is happening here.It is the issue with strtok, and also the fact that you are giving character arrays to all these string functions without space for a string dilimiter, ie '0'.This is the test functio which I wrote on a computer to test stuff outThen I copied all of your arduino code over to my computer commented out all serial commands, added the stdio header, and used the above funcition at several locations.This is the output I gotBased on this data this is my conclusion.The strtok funciton modifies the original string and replaces the search caracter with a null, then copies over the string to a new index and gives the index back.strcpy is not doing anything to your code, you have written the buffer values in such a manner that it seems like strcpy is doing nasty things, but it is just doing what it is supposed to do. copying strings till it finds a null. In most cases it would screw things alot for you but not in this specific case.As can be seen in the results, gva_testDate amd gva_testTime have a pointer difference of 6, as such when gva_testTime gets populated, if you use gva_testDate as a string, the null is seen only at the end of 12 characters.Also lva_testDate is supposed to be a buffer for you, you need to give it a value to start with or it becomes a null buffer and might end up modifying differt things based on what the code is compiled to.To solve the issue, I initialised all your variables as so, the output is printed below that.outputI hope this helps."
54289245,"First of all you are reading the value of the pin into level then in the while loop you are re-reading it: why is that? Can't you do something like:?Also don't you want to reassign the btn2_t0 = t1; even when the time was smaller than 700 ms? Like:The behaviour depends on how you built your electronic circuit: is the button-press suppose to make the pin high or low? Be sure about the behaviour is the one you are expecting by either connecting a led and a resistor or using a Voltmeter.However since your Python code worked I am assuming the electronic is correct and your algorithm too.Be sure of course you are pressing the button long enough. Add some prints to your code to understand which branches it is executing because when there is electronic involved it is difficult to understand only by the code. While waiting for news from you, in my opinion is better to do the following: define the callback as: INT_EDGE_BOTH so that it got called when the bottom is pressed and when the button is released. You can keep the time elapsed with a static variable."
54312099,Here is a partial example of a uint24_t that you might port to your tools (I don't know the 'current' arduino's tool set)Typical output:
54556420,"Functions of different arity may be abstracted with a generic signature (think about main). Instead of each giving each their own unique arguments, you simply supply them all with:This is how your operating system treats all programs it runs anyways. I've given a very basic example below which you can inspect. "
54595238,"At first, as denoted in comments, type punning is undefined behaviour in C++. So you should only ever read the union member you last assigned a value to. Second problem is that the order in which bit fields are filled is implementation defined (some compilers might place the first member at MSB of the underlying type, most would prefer the LSB, though).To get around any of these problems, I'd do the work you try to get simplified with bitfields manually:You'll notice that I set up the 32 bits as 0xuurrggbb (u: unused); if you prefer or need a different order, then adjust the bit shifts appropriately in above functions. You might even consider using the so far unused byte for the alpha channel..."
54752633,"I had a look onto the example linked in OP's question.The relevant part isThereby WiFiEvent is a free function which is defined above:The OP wants to refactor this event handler into his class ApiClient:The essential difference is that WiFiEvent() becomes a member function due to this, and OP got the reported errorOut of curiosity, I digged a bit in the github project and finally found the declaration of WiFiClass::onEvent() – it's inherited from class WiFiGenericClass:Thus, there are actually three declarations of onEvent() with two parameters, thereby the 2nd parameter of each has a default argument. (Hence, the call WiFi.onEvent(WiFiEvent); with only one argument in the example was OK.)To puzzle this out completely, I looked for WiFiEventCb, WiFiEventFuncCb, and WiFiEventSysCb and found them in the same header file above of class WiFiGenericClass:This is what the three typedefs mean:Obviously, the example used the 2nd onEvent() as it is the only one accepting functions with two parameters.Support of std::function is very nice, because it accepts anything callable with matching signature:So, to make the ApiClient::WiFiEvent() compatible, there are two options:The first option restricts the usability of ApiClient::WiFiEvent() as static member functions are called without an instance of the resp. class. The drawback – there is no instance in the member function available (i.e. explicit or implicit access to this prohibited) which may or may not be acceptable.The second option can be achieved easily by using a lambda as adapter. For this, the event handler registration in ApiClient::ApiClient() has to be changed:This effectively registers a functor with the accepted signature which captures this of ApiClient so that a valid call of member function with instance can be done. The return type of lambda is implicitly declared to void because there is no return in the body of the lambda.Finally, I'd like to mention that capturing in lambdas is something which has to be done carefully. If wifi outlives this (i.e. the instance of ApiClient) then it may call ApiClient::WiFiEvent() without a valid this-pointer.To make it ""bullet-proof"", the destructor of ApiClient could call removeEvent() using the wifi_event_id_t which is returned by onEvent(). (This should be stored in ApiClient for this purpose.)"
55009808,"Issue is from constructor of Led class. Constructor is trying to initialize default i2cController controller; field. Constructor is also looking for default i2cController constructor without parameters, which is not defined. If you need a reference make it like the following. If you need a copy"
55400788,"I discarded  Serial.parseInt() function, removed the switch statments and followed  @Arno Bozo advise on serial listening while following this tutorial on http://forum.arduino.cc/index.php?topic=396450.0
I came up with what I want and here is the code In Summary the code works like this1.In serial monitor send this <1,123> : 1 = the trigger point for the switch statement ; 123 = PWM value."
55474761,"A timer can be initiated using the Teensy system using its overflows and interrupts. The below code will set up and initiate a timer which will count up in. A struct is used to initiate a boolean value (among other possible things within the program) which can be used to control whether or not the overflow of the timer counts, effectively pausing the timer.A function to draw a stringBelow is a formatting function using the above function to draw a string, the formatting function is used to get the mm:ss layoutWith the formatting sorted, a struct should be created to initiate the values requiredto operate the timer, and the timer initiatedBelow is the hidden part of the timer, this is the heart, it creates the values which are the basis of this entire question, it is very important, and it will not work unless TCCR1A, TCCR1B, TIMSK1 and sei() are initiated beforehand, the values can vary from 0, 2, 1 respectively, however, the values used in the below timer must be adjusted accordingly using a bit chartFinally, the code that works with the above timer to produce an output in mm:ss format is simple due to the timer above doing all the work, all that remains is the formatting. time passed calls the previously created function, which is the total passed time frame, min and sec are then found using division and modulo, and formatted using the previously made formatting functionA pause can be created by using similarIf the program is correctly created, the timer should retroactively update itself!
Hope it helps!Relevant includes, not all includes may be used."
55563092,"""You have the problem because you tried to define DHT dht(1, DHT22); multiple time.Try this: 
 your .h file should look likeand .cpp"
55563201,"The answer is in one of the links you posted. The comments explain how to initialize objects in a constructor. When you pass a member constructor, you want to use initializer list.The header should look something like this.And here is the implementation. Look how dht is initialized."
55740265,"Well, I think your best bet is to go with for loop to search for studentName. Depending on what C++ revision you are using:or if you are constrained to pre-C++11:The rest is very similar.BTW.: You can change:to:"
55837280,"There was a point in Linux 2.something where nanosleep had a specific behavior for processes scheduled under a real-time policy like SCHED_FIFO or SCHED_RR where it would busy-wait when the specified sleep was below the minimum clock resolution or granularity, but it was removed. (Try man nanosleep, I believe this behavior is mentioned there).I had a need to have a more precise sleep interval so I wrote my own version to call in those special cases. On the target machine I was able to get < 10 µs delays with only occasional blips (see the comment in the code).Just remember that for non-real-time scheduling policies, if your application tries to sleep for less than the minimum clock resolution, it may still be preempted.Here is a little test program that I wrote to test this, the busy loop calls clock_gettime() so it knows when it's time to wake:"
56085530,"I'd like to suggest that your current solution is fine. You have a device that needs to know a value that's store in a remote database. As far as the device is concerned, the value could change at any time, and the device needs to update its own state when the remote value changes.Having it act as a Host that receives connections or notifications of any kind from the remote server would probably be problematic. You mentioned that you'd have to set up port-forwarding. You'd also be adding the security concerns of a Host server to this device, and you'd need to worry about maintaining a consistent IP address (or something).The ideal solution will depend on what you're trying to accomplish. Why don't you want to poll the server every five seconds?Of course the actual question you asked was how [to] postpone the HTTP GET response until the moment that the user changes the device status with a button click?Postponing the response is hardly a normal thing to do, and you're going to run into all kinds of problems with timeouts, which I'm not going to address here (for brevity), and it'll be a struggle to get your system to do anything else at the same time, but it can be done:client device:host serverAnd we could take this even farther (make it even worse) by pushing our while loop down into the MySQL, but that would require learning the details of MySQL Stored Procedures, and no amount of internet points is worth that."
56117309,"A more reliable approach to running the motor until the button is released is to use a ""no-code"" timeout.  That is, if the ""no code"" state persists for a period longer than the auto-repeat period, then it has been released.It is not clear in your code what the 1 second analogue pulse is for, but placing long delays in your loop() function makes your system far less responsive.  Better to poll the system tick and ""do stuff"" when it is time to do so.  Also magic numbers should be avoided if you want anyone to understand your code and avoid errors in maintenance.The following uses system tick polling to implement the ""no-code"" timeout.  I have omitted the motor on/off code because it is not clear what you are doing there with the 1 second delays.I have included response to the motor-off code, but that may not be necessary, since the motor will be switched off 250ms (or whatever time you choose) after the ON button is released in any case.  You might instead have a forward/reverse button and release either to stop:"
56507333,"The problem was that I did not call my Bluetooth Object by reference.
Instead of giving my function the Bluetooth Object I should point to it:"
56750328,"Your function is just horrible written. It is so bad - that even it does not make any sense to analyze it. BTW forget the recursion in the uC development.  Always think about the algorithm. Here you have much simpler and definitely more efficient:of course the haystack has to be:but to use the function I thought calloc() is essential for my function.Forget about malloc and friends when programming uCs.  Otherwise you will get into serious problems. Dynamic memory allocation in the low memory enronments is a bit tricky , and ""big computer"" mechanisms fail miserably here"
56772243,You can have string variable which stores all the read values into it and once ! is read it will start processing it. 
56957155,You can do it using the C function strtok to tokenize the buffer
56970006,"#define is irrelevant.After preprocessing, your snippet is exactly equivalent to:So the problem is reduced to ""how do we compare two C-strings?"", with a much simpler example like this:The answer is, not with ==, but with strcmp."
57455124,Sorry but you can use delete in Arduino with anything that's created with new.And the destructor is called when you deleted.And Yes about malloc and free.
57499584,"You should not be setting everything to volatile. Volatile has a specific purpose, and that's to prevent the compiler from optimizing out reads and writes to memory. Let's look at a really simple example.When we look at the assembly, we see that in regular_sum, the compiler realizes you're dereferencing the same pointer twice, and it optimizes it to just one dereference. But in volatile_sum, the compiler inserts both dereferences:Optimizations are good, and most of the time, you won't need to use volatile. If you're doing memory-mapped IO, or you're writing values to pins as though they were a pointer, that's where you use volatile. To reiterate what Nathan Oliver said,You only need to use volatile on variables where the hardware can change the value of the variable because the compiler can't know about that. This is what volatile is for, letting the compiler know this is a special variable that could be changed in a manner it doesn't know about. If the hardware cant change the value on you, then you don't need volatile. But if you're doing computations on an object, don't use volatile. Do the computations on a normal object, and then copy the result to your volatile pointer. Volatile and Interrupt Service Routines.It is appropriate to use volatile on global variables that might be modified by Interrupt Service Routines. That being said, volatile cannot be used with objects like std::bitset because std::bitset does not have support for volatile operations, and std::bitset is not trivially copyable. In this regard, you have two options:If you have a class that is trivially copyable, then you can do something like the following. First, we have to define functions to allow us to copy to and from volatile types:Then, we may write a class normally, and as long as it's trivially copyable we can create a copy from a volatile version:We can also encapsulate this behavior in a class, so that we can ""check out"" volatile variables:Using this allows us to create local copies of volatile variables, make modifications to them, and the result will be saved automatically:"
57550329,"You could do something like the following: 
( Not sure if Arduino can have like following )See here"
57550576,"Arduino doesn't have std::function, because AVR GCC doesn't ship with the Standard Library, so those suggestions in the comments won't work for that specific platform. If you need similar behavior for Arduino or other embedded platforms, you can use ETL's etl::function or etl::delegate, or create your own implementation. std::function uses heap allocations for type erasure, which is usually not a good choice for embedded.The simplest implementation would use C-style function pointers:Live example, with some use cases.Of course, you can also just use the C pointer for this case, but this class can be extended for other types. If you need more complex behavior, like functors, member functions and capturing lambdas, see ETL's implementations I cited above."
57568938,"So I went back and reviewed the documenation on uniform initialization a bunch more and came up this this as a starting point, but i would like it to be simplified as much as possible. compiles on godbolt.org, and in the arduino studio."
57851179,
57875604,"When you create an array of structs:This creates a copy of each struct you're using to make the list. You either have to use an array of pointers:Or you have to create your own class, which stores a reference to them:This class will work as intended in your code because it'll store a reference to each sensor, rather than a copy:"
57924560,"OK, so I think I found my answer...After having a few conversations with Tinkercad and the great support team there I was told that they use an old version of Arduino to compile their code.  Well, all the code I'm writing and the IDE I'm writing in are based on the latest releases of everything.  I think this is where my issue starts to happen.Currently, when trying to compile the following code in the current version that Tinkercad uses I get the respective error that follows...As you can see, I'm trying to create a function in my class called InitializeClass() that takes my enum as a parameter.  The compiler does not like that one bit, and the error highlighting along with the error returned are horrible for some reason telling me nothing!
However, if I change the class to only use the enum in the constructor itself, that seems to compile just fine with no errors.I wanted to create a class that has as least repetitive code as possible, this is usually the way I try and code in general.  If I have to type the same code twice...  Start looking at making it a function.  This way a) there is less code and b) if you ever need to change the logic you're changing it in one place rather than multiple places.  So I start out usually making my classes look like this...This works perfectly fine in VS IDE (c++) as well as the latest Arduino IDE.  However, since Tinkercad is using an old Arduino compiler it has a fit with me using the enums in a private class function.  (Update: Just found out this happens in ANY class function!  Not just a private one.)So this whole time, I have been thinking with a c# mentality when coding my Arduino project when I should have been thinking more c++ like.  Well, in my defense I am after all a c# guy through and through.  I love it SO much more the c++.  Well in almost every way.  There are apparently exceptions.  I recently found out, that while c# does not allow it c++ DOES allow you to overload class constructors!  That changes everything for the way I would write my classes in c++.  Now there is no reason for the private class function to initialize the class.  So I can just have something like the following...That my friends compiles completely fine in the old Arduino compilers.  It also saves me some space for other code (these ATTiny chips are not huge so a smaller program is always a win!)."
58042988,"strArray is an array of string pointers, terminated by a pointer to a zero-length string (why not a NULL pointer?). An array itself decays into a pointer to its first element. You need to dereference the array pointer to access the individual string pointers so you can pass them to strcmp() until you reach that terminator, eg:Alternatively, just use normal array syntax (which works on array pointers) instead of manual pointer arithmetic syntax:Alternatively, it is possible to eliminate the i and j variables completely:That being said, there is no guarantee that two different ""\0"" string literals in code will point to the same memory address at runtime. Some compilers do merge duplicate strings, but that is very compiler-specific behavior. You should not rely on that. You need to either use strlen(...) == 0 to detect the terminating zero-length string, or better to use a NULL pointer instead."
58085787,"If you use a reference, then the variable needs to be initialized (as not being NULL) in the constructor. This is safer, since you are assured the reference is really pointing to an existing object.AboutThis does not make much sense, unless the State object is used only as input for the Mutator constructor; however if it changes the newly created State variable, when the constructor returns and mutator is created, the State() instance is deleted.Also (see note of NathanOliver below), it is not legal C++ code and not portable.UpdateTest application:The code above compiler and links correctly on an Arduino compiler (1.8.9):"
58207225,"Without going into the specifics of your code (since I cannot build it to test.) I only have one quick suggestion:Instead of using a series of if-then-else (or variations of it) consider using a state machine.  Implementations often include use of a switch() inside a while(expression){...} loop.  The following is a very simple example of how you might be able to do the steps you need in this construct:
(Note, this is a mix of C and pseudo code for illustration.  It is close to compilable , but contains a few undefined items.)  Suggestion for improvement to this illustration:
Expand this code to read in a ""profile"" file.  It could include such things as parameter values typical to your process, such as temperature profiles, vibration profiles, number of cycles, etc.  With such information, all of the hard-coding used here as illustration could be replaced with run-time configurable parameters, allowing the system to use many different profiles
without having to recompile the executable each time.Another state machine example.  "
58237326,"As @0andriy mentioned, for my purposes I need more low-level functions, not a contextless. Here is my test example with generic libgpiod functions."
58358980,I figured it out!My new code 
58567143,"I suppose you are using this:https://www.arduino.cc/en/Reference/WiFiServerI can see that you are not declaring the myServer in your class; that I guess is the error in your code. If I am not wrong, it should be something like this:The implementation, you would need to initialise the instance:"
58670386,"Since making the member function virtual is not a possibility, you have to simulate dynamic dispatch with type erasure:(live demo)Note that functions in Java are virtual by default.  Not in C++."
58749107,"You have created a float variable respond. This is a numeric value and not a string but ""RESET"" is a string and you can't really compare a number to a string. You need to make respond a String and read the entire line with readStringUntil():By default, WriteLine appends a newline. Make sure you haven't modified that. See: SerialPort.NewLine Property"
58947850,This code should work for virtually any number of available GPIO pins. It works with both signed/unsigned numbers and calculates the mask required to get the desired bits off the number and display it. It also loops and asks for the input repeatedly untill EOF (ctrl+D) is pressed.
58951555,Hoping that your problem is that you don't know how to dynamically create member arrays in a class.
58955278,"On Arduino, space is usually very limited, meaning that using dynamic memory management is usually to be avoided on a large scale since that leads to memory fragmentation over a longer run.The following solution in itself uses no dynamic allocation:The main drawback is that this solution always uses up the same amount of storage meaning waste for smaller objects."
59245127,"When you send a GET/POST request you must put the IP of the destination, in this case, the IP of your ESP32.First thing to note, my server.begin() was listening on 192.168.4.1:80 by default as an access point.Now, to create an asynchronous server that holds GET and POST requests with json data you can have a function like this:file http_server.h:example of file http_server.cpp:Finally, if you want to conect directly to your ESP32 with your mobile/computer, you will need to configure its wifi connection as an ACCESS_POINT. So, your setup()  and loop()in your main.ino could look like:file main.ino:And that's all. to check that everything worked you can connect your mobile phone to the wifi choose_some_ssid with password chose_some_password, open a browser and go to 192.168.4.1/get_data and you should get ""Here I am"" as response.As you said on your question, if you want to send a post with python you can do:More information can be found on https://techtutorialsx.com/2018/10/12/esp32-http-web-server-handling-body-data/ 
Hope it helps!"
59462641,"This is pass by value, so a copy is made for the function. It does not echo any changes back to the original variable.To do that, you need to pass it by reference:Note that you'll need to pass by reference in all functions that want to change the variable (so stateSwitch as well as serialTask).By way of example, note the following:This will result in the three lines 1, 1 and 42, because the call to procA is pass-by-value which doesn't affect the passed variable, just the local copy of it.On the other hand, procB, being pass-by-reference, does change the passed variable.Note also that the call is similar regardless of whether you're passing by value or reference. You do not need to change the call in any way.You may also want to examine the logic behind these things:It's very unusual for a state machine to force the state back to the value it was before executing the event. It may be okay since we can't see all your code but I'd just be careful there."
59473987,"Matrix keyboard scanning does not require any interrupt. You should create scanning function that will be called periodically. The best way is to store each key as a bit in some variable - you have 4x4 keyboard so uint16_t will perfetly fit. XOR operator is perfect for key change detection. Also don't forget to implement some key debouncing functionality.I'd suggest following ""pseudo"" code or something similar (I hope there is no bug in it):"
59513124,"Your questions nudged me to provide a copy of code-with-stubs.developed on Lubuntu 18.10using g++ (Ubuntu 9.2.1-9ubuntu2) 9.2.1 20191008Note: 142 lines,  only 14 lines of stubsBuild output to show compiler options:Execution output (of stubs) including posix time measurement"
59687011,"Using a big regular array can be better sometime because ArduinoSTL takes a lot of memory and removing lets enough free space to use such simple arrays and the compiling is way faster.
In what I was doing, I didn't really needed a vector. A big array was enough.It provides some functions such as malloc(), calloc(), realloc() and free().
The main advantage is that it is standard and is not only for Arduino.
Here is a piece of code in a regular C++ coding to show how to use it.The Arduino IDE doesn't require to include the library as it is already included by default.Here is a link for more details about the library: stdlib.h - C++ referenceIf anyone know a fast vector library, then feel free to share!"
59706852,"Before deciding how to do it, the qquestion is what do you want to do and why.  Because, maybe there are better alternatives using simple C++ idioms.Do you want to specialize some functions of your switch, so instead of calling the function of the auto_switch you'd call dome more specialized ones ?     In this case you wouldn't do:  but instead you would rely on polymorphism with virtual functions in the base class:  and write a specialized class for the leds:  In fact, the compiler will generate some function pointers behind the scene, but you don't have to care:  But event if each object's behavior is dynamic on the the base of the real class of the object,  the objects of the same class share a behavior that was predefined at compile time. If this is not ok, go to the next option. The functions of another objects can only be invoked with that object at hand. So having a function pointer to a led function is not sufficient: you also need to know on which led it shall be applied.   This is why member function pointers are different and somewhat constraint:  you can only invoke functions of class of your member function pointer.  If polymorphism is sufficient (i.e. if derived class has a different implementation of a function already foreseen in the base classe) then you are lucky.   If you want to use a function that only exists in the derived class and not in the base class, it won't compile.  Here a simplified version of auto_swith:  I provide a function, but allso a pointer to the object on which the function has to be invoked: Online demo Another variant would be to use the standard functional library to bind a member function and the object on which it shall be executed (as well as any need parameters):Here you can bind anything: any function of any class: Online demo Now if you want to perform something on an object when you turn on and off the switch, but you need total flexibility,  you can just implement the command pattern :  this lets you execute anything on any object.  And you don't even need a function pointer.  "
59812630,"In most cases temperature does not change very fast, so sampling at 10sps is probably excessive, however if the sampling is noisy, such oversampling is useful to get stable readings at higher resolution.  Given the typical dynamics of temperature change you can instead take the sum of samples over a short period N, and every N seconds, add that sum to a moving-window buffer and reset the N accumulator.The min/max value over the window period can then be found in the buffer without having to retain all the samples over that periodFor example given the following function:you might have a Sketch loop() like:Note that temperatureWindowedMinMax() handles its own sample timing and need only be called rapidly in the loop.  It would be possible to separate the min/max recovery from the sampling by creating two functions and changing the min-max buffer scope:Then update and the usage can be independent:Either way you get control over the memory usage via the constants:For example taking a longer average allows a shorter buffer while being less responsive to rapid fluctuations.  A shorter average but a longer buffer will capture short temperature spikes at the expense of more memory.  In practice, temperature tends to be a low-bandwidth, laggy signal, so the above settings are probably more than adequate in most cases.Note that in both solutions, the conversion from analogue sample sum to temperature need not be carried out on the stored samples of sample sum, but can be performed only on the final min/max result.  Doing do is both efficient and avoids data loss through rounding.  Note also that the sum of samples is accumulated, not the average it is both more efficient and avoids data loss."
59977449,"The loop() sets a target relative position for each motor, then waits until all motors have reached their target position.  Performing a sequence of such steps.  On each timer interrupt, for each motor that has not yet reached its target, a step pulse is generated. (In fact it is a little more complicated, since each motor has speed and acceleration profiles, so the step pulse is generated when demanded by the motion profile).An important thing to note is that the step pulse is very short, the motor controller generates the correct signals to the motor coils to complete the step. The step pulse is completed long before the motor reaches the end of the step (or even starts its step), so although the pulses for each motor are issued sequentially, because this takes no significant time compared to the step time, all motors can step simultaneously not sequentially.So there are two threads of execution - the timer ISR and the loop().  The ISR allows the stepping to occur asynchronously to the loop() code, which can then do other work.  Except in this case it does nothing other than wait for the steps to complete, which rather negates any benefit of background stepping - turning the asynchronous motion into a completely synchronous process.Regardless of the merits and deficiencies of the Arduino Sketch setup()/loop() framework, this particular implementation defeats it completely by never iterating loop() and blocking indefinitely at its end. The framework expects loop() to run to completion and it calls it repeatedly (hence its name - it is the body of the executive loop).  The loop() body should be implemented as a non-blocking state-machine or sequence of state machines, for example:This will allow you to make effective use of the CPU, getting more work done and and allowing more responsive behaviour.  For example you could poll an emergency stop input to abort the motion:"
60032006,"As it was pointed out already in the comments - the argument that UdpTask(String (*handleGson)(String)); constructor expects is not a pointer to a member function. Rather it is a pointer to a free function. A pointer to a member function would be of the form:Note that pointer to a member need to know a member of what type it is.As to your original problem - there are a number of ways to solve it (as always the case with C++).Most straightforward is to use std::function<String(String)> to store a functor. That is any object that can be called. So something like:In the implementation, you just call it as: handler(args);In case you can not use std function - other solutions can be explored.Simplest would be to store a pointer to a handler in you UdpTask and call its method directly:In the implementation, you just call it as: handler->handleGson(args);Now, I do recognise that there might be arcitual concerns about tight coupling between UdpTask and what is eccentially a UDP data handler.
So you may consideg making generic interface for DataHandler, storing pointer to it and making GsonHandler an implementation of DataHandler: "
60065443,"You really should not return false; there. What you want to do is return nullptr; or return NULL; if nullptr is not available. The reason why this was only an warning in the past is probably that you used an older c++ standard in the past. On my system, you get the following for different c++ standards:Code:Output:It seems there was a change to this in the C++11 standard. I am not sure what exactly changed there, the only change I know from C++11 regarding conversions are explicit operators, maybe someone else can say something to this regard."
60082900,"I was able to get the ESP to respond to the AT commands with the following code. There are sections commented out as I was simply frankensteining my way to 'working' code. I was able to change the SSID and password via a hard coded string. I simply sent it by pressing 'Enter' to get the code to proceed. As it turns out the issue laid in sending data to the ESP (rather than receiving, which was my initial theory). Now I need to get the code to receive an uint8_t[] from the terminal, but that is a separate issue from the original question so I'll mark this as answered.Thank you @hamboy75, @Juraj, and @KamilCuk for your help!"
60303887,"Noticing that:129,66,36,24,24,36,66,129 = 128+1; 64+2 ; 32+4; 16+8; 16+8; 32+4; 64+2; 128+1;I ended up with this code:And it works."
60375692,"A ""pointer/reference"" to an array seems to point out some issues in understanding how pointers work in relation to arrays.When you take a pointer to an array element, and ""pass an array"" to such function, you're triggering array-to-pointer decay, and what you end up passing is the pointer to the first element.Thus, in your case, passing sensors via sensor* will work, and you'll be able to change the contents of the array:That being said, if you're passing an array, you need some way to assess the size to avoid out-of-bounds access; one way to do that is to pass it as another parameter.That being said, it's much preferrable to use std::array, which you can then pass as a reference. That way you avoid all the pointer shenanigans and get the size passed automatically. The downside is that you need to know the size at compile-time.Unfortunately, while providing std::string_view, C++ lacks builtin memory-view primitive. std::vector is used in desktop code, but its use in embedded program for a limited MCU is rather questionable. In that case, you might need/want to write your own type encompassing the pointer and size, e.g.:"
6056338,Try this... you will probably need to do the code for exceptions (ex: if the response is bigger than 2024)
60649079,Make your memberCallback function static. Change your code to this:
60657202,"The ESP32 Arduino Core has an example of how to do exactly this athttps://github.com/espressif/arduino-esp32/tree/master/libraries/ESP32/examples/GPIO/FunctionalInterruptI'll quote code from it here:The important things are:std::bind() is a standard C++ library function; there's documentation about it online.That said, I'm concerned about what you plan to do inside your interrupt handler.Interrupt handlers need to run for a very brief amount of time, and they need to be very careful about calling other functions and making sure that data structures are in an inconsistent state. Unless you lock out interrupts (which you should do as little as possible) outside of the interrupt handler, data structures can easily be in inconsistent states.The example in the Arduino Core is good - it just changes a couple of variables. Doing more than that - calling functions like Serial.println() or allocating memory or creating objects is not safe."
60800719,The specification is very poorly written and vague but just adding up all the bytes in the message and taking the lower 2 bytes of the result seems to produce the right checksum:
60810377,"As this is quite often asked question and I'd propose more like using wrapper class inheriting Stream interface on C string (and it can be initialized from Arduino String object too). However usage with Arduino String class is tricky as the original String shouldn't be altered during usage of StringStream, but it's possible to reinitialize it again. Using rvalue (String literal, passed into the class) is forbidden by using non const reference as the parameter of setData method and constructor.However it's not tested much, so there might be some mistakes. The copy/move constructor and assigment is ommited (and it shouldn't be :D), also using  operator=(String&) and operator=(const char*) would be more intuitive interface for it. And the test program would be like:"
60835674,"In order for this to work I need to use addressing like what is talked about in the post:
C++ pointer to objectsthe incorrect way to do this would be like this:Edit: this is a bad idea I have learned. It ""works"" but leads to undefined behavior."
60986629,"The comments are probably going to lead you astray or at best confuse you.  Let me break it down with some options.Firstly, the problem is as you say: the array whose address you are returning no longer exists when the function is popped off the stack to the caller.  Ignoring this results in Undefined Behavior.Here are a few options, along with some discussion:The caller owns the bufferAdvantage is that the caller chooses how this memory is allocated, which is useful in embedded environments.Note you could also choose to return s from this function as a convenience, or to convey some extra meaning.For me, if I was working in an embedded environment such as Arduino, this would be my preference 100%.Use std::string, std::vector or similarThis is probably the way you'd do it if you didn't care about allocation overhead and other potential issues such as fragmentation over time.Allocate memory yourselfIf you want to ensure the allocated memory is exactly the right size, then you'd probably read into a local buffer first, and then allocate the memory and copy.  Same memory considerations as std::string or other solutions dealing with heap memory.This form also has the nightmarish property of the caller being responsible for managing the returned pointer and eventually calling delete[].  It's highly inadvisable.  It's also distressingly common. :(Better way to return dynamically allocated memory, if you absolutely mustSame as #3, but the pointer is managed safely.  Requires C++11 or later.Use a static bufferGenerally frowned upon.  Particularly because this type of pattern results in nasty problems in multi-threaded environments.People mostly choose this approach because they're lazy and want a simple interface.  I guess one benefit is that the caller doesn't have to know anything about what size buffer is acceptable.Make your own class with an internal bufferThis is more of a verbose solution, and may start to smell like over-engineering.  But it does combine the best parts of both #1 and #5.  That is, you get stack allocation of your buffer, you don't need to know the size, and the function itself doesn't need extra arguments.If you did want to have a static buffer, then you could just define one static instance of the class, but the difference would be a clear intent of this in the code."
61054855,"@Delta_G - Thanks!I tried the 2 dimensional array first but could not get it right.
Think I messed up the second printing routine.
For future reference in case somebody needs this to, this is a complete working test code."
61120511,"I followed your code and I did some changes to behave as your example.If your string is always such that, where the ! always come before the # and, in between them there will always be some numbers to work on, then you can do some loops to wait for those markers.So, basically:But again, this algorithm works with the example you provided.Also, I noticed you are returning at the end of the loop() function.
You are not supposed to do that because embedded systems like Arduino must have an infinite loop to keep running."
61121144,"Here's a simpler way of going about it, I think. It depends on whether or not there are requirements that aren't explicitly stated.A few things worth mentioning,Code:"
61225311,As not exactly knowing what you really want I did the following assumptions:So here a complete sequence (works as posted) you could easily implement into your code. No String class is used and its a one line file read/write only:
61277926,"If I am right, your syntax for the ternary operator is wrong, should be like:So it should be like this:Is the same as:If you want to use a function, why not like this?You don`t have to put everything in the function, just the code which has same structure."
61455049,"OpenCV can only work for USB camera, not Raspberry Pi camera. The hardware interface is different.
You can find some Picamera C++ repositories from the Raspberry Pi Q&A.For example:"
61546581,"As I dont like the String class (will cause you memory problems later on)I rewrote with char arrays and it works as expected (Included your ""solution"" but have you checked serial monitor output):"
61573206,"I reworked your code to use char arrays instead of String class and changed the decoding logic. It might have flaws though, cause i could not test the logic for your script.If its not doing what you want, uncomment getDebug() and comment getData() upload and post result (starting with ==== DEBUG ====) as edit to your question.If you get a buffersize error double the amount of BUFFERSIZE till it runs through."
61655638,"To summarize the discussion, and correct some of your wrong assumptions:BTW: data type int usually blames you for not thinking about it.  :)"
61919861,"Here is the initial code of my question, corrected following the @Jarod42's answer.It compiles correctly and tests using sizeof() on the subclasses objects reported the expected sizes of the array."
62133421,"After more attempts of searching for similar issues, I finally found the answer of what is wrong in the code. It just took searching for the error message in so many different possible inputs.The lines:needed to be within rank 0 only. Meaning the correct code to get it to run on multiple nodes is:I don't know how acceptable it is to answer your own question, but I wanted to ensure that if anyone has the same issue they know how to fix it. I know I hate when I find a similar question only to see that the asker edited in that they fixed the issue without explaining how they fixed it. "
62617948,"As @sweenish has already mentioned, you need to fix the errors related to the constructor. You have 2 ways:1.Add a default constructor:which is a shorter equivalent ofThis approach has a drawback of redundant construction + assignment, and you will also have 2 copies of each motors, where each can control your robot, one in main function and one in your Driver object:2.Use pointers (or references) in Driver:Then you will also need to change the way you create SimpleMotors, for example:Of course, you could use raw pointers or uniques_ptr instead. You may find more info on shared_ptr in the here: https://en.cppreference.com/w/cpp/memory/shared_ptr"
63432587,"For embedded code, compactness is the key. Use user-defined structure like so."
63543029,"You can simply use a goto statementin both the loop.....you dont even need a loop if you use goto, like in assembly language.c code for it is:"
63819683,I believe this is the most straight forward and quickest way:
63831703,"I am no familiar with arduino components, but..You can extend the device class:In this way you keep a reference to your register inside your class, from doSomething() you can deference myShiftReference and perform actions with:"
64428720,I found a solution and it worked with inListPassiveTarget:
64478361,"Ok your piece of code does not highlight the error, in fact I try to reproduce that with this code:And it works perfectly with output :You can try it on C++ Shell.So the problem in your code is other piece of code. Probably you use the shared_ptr in a wrong way, let the memory used by this pointer is destroyed before the call of delete."
64792394,"Graphic services use an in-memory buffer to make the screen image and write the whole buffer or only the modified parts of the display into the screen device (e.g. clipping).So, here are two slightly enhanced versions of the program:In both, a call to gettimeofday() has also been added to measure the elapsed time during the display.Second program with sendfile():If the program is launched without parameter, it pauses until the user type CTRL-C otherwise, it returns immediately after the display. On a Raspberry Pi 3 B+ running Linux 32-bits:The original program in the page that you shared is slower in the same conditions (I modified the loop to make it write the whole screen as in the previous two examples, I added inline and static keywords and compiled it with -O3):"
64843801,Here is finally a solution to my problem above. Thought I post it in case anyone else runs into a similar problem:
64966785,"Here it is. The code is a bit redundant :), but you can solve it if you want. Regardless, it must work."
65020609,"lots of thanks to @ocrdu and @Flash Ang for the suggestions, the code below is the working code and my PCB has been running continuously for 58 hours till now:This time to work smart, I used the default ip address to my router and monitor whether my PCB is still connected to the router by looking at the DHCP client list, and remove all the serial commands in the code. I'm afraid for my past experiences on the disconnection issues, it might be just a short temporary disconnect from the router, instead of a permanent disconnection.I'm sorry if there is any lack of testing in this program. Thank you for the time spent to provide me all the useful suggestions =)"
65118028,"I've removed all of the noise from the code sample to focus on the how-tos of passing and calling a function pointer.The gory details, and some very good suggestions, can be found at Pointers to Member FunctionsNote that since Button must now carry around the a reference to the Light instance it uses, making lights and Buttons local variable variables in a sufficiently widely scoped function is an attractive option.For completeness, here's what it looks like with std::function and a Lambda Expression."
65133982,For Arduino IDE:otherwise not working.
65219355," This is not an anwser. You may use the following code to print you string as integer in hex form. Every 12 characters a wide separation, and every 24 a new line. The arrange makes easier for you to count 24 characters. Print-out of this example:(meaning of the number can be checked in an ascii table google search.)  Send you string to above function dum_str(string), and copy the resultant table appending to your post."
65299658,"You never declared the function readSensor() as a part of CrossingSensor. Since it isn't a member function, it has no access to status.All you should have to do is declare the function as a member of CrossingSensor or pass it a CrossingSensor object.You would also need to change the .cpp file to reflect that change. The declaration for each would look like the following:This is your method declaration:This makes readSensor a part of CrossingSensor as well as the other way around."
65313745,It's code that was HTML encoded.  &lt; is the encoding for the < character and &gt; is the encoding for the > character.So this:Is actually this:Also note that this code won't compile as-is.
65361590,"What you do now is read a char, turn it into a CString str, and then you println() it before you go on to the next char.You could probably stick the bytes together the way you want from what you got, but it is easier to read the received bytes into a buffer and split the result:Send the RGB values from Python separated with commas and with a '\n' on the end, and then on the Arduino do something like this (untested, but you get the idea):Note: no checks and error handling in this code.There are no doubt prettier ways, but this came to mind first and I think it will work. It could also be done using a String object, but I try not to.For the code in this other answer to work, some things need to be added (but I haven't tested if these additions are enough):Note that converting what you read from the file to chars or integers on the Python side and simply sending three bytes would greatly simplify things on the Arduino side."
65362940,Arduino Code:Python Code:
65368627,"Your original code is almost correct.You just need to change the format a little bit to synchronise to newline characters.I've used sscanf() to read the 3 integers from the buffer because it returns a count of the number of items it successfully scanned into variables. I've also added some #defines to make it more readable and maintainable.Regarding Serial.parseInt(), it doesn't notify when it times out. Instead, it simply returns 0, which is a valid value, so the caller has no idea whether this was due to a timeout.The same issue exists with Serial.readBytesUntil() because it doesn't notify the caller whether the returned byte count is the result of encountering the search character or enduring a timeout. What if 255,255,25 was received due to a timeout caused by a communication error instead of the expected 255,255,255? The caller would be unaware.Compare with the robust methodology of int.TryParse() in C#.NET which returns a bool to indicate success/failure and passes the parsed int by reference.To overcome the issues of Serial.parseInt() and Serial.readBytesUntil() timing out without returning an error code when the serial input buffer is empty, it's possible to use a non-blocking algorithm algorithm, something like this which reads one character per loop() until it reaches a newline character before scanning the buffer for 3 integers:"
65496661,for your interest here's an example of code using 2 arrays to store button states of arduino pin  given to the corresponding input button. During the loop you can do a simple check with the wanted repeat:button_down() also defers the first repeat by DELAY_WAIT_BEFORE_REPEAT ms.Here the full tested example:
65979498,"menu_main is an array of pointers, that much you realise.You seem to think that &menu_main is a reference to menu_main but that is incorrect. &menu_main is the address of menu_main and & is the address-of operator. It's confusing because the same symbol & in a different context does mean a reference. However you may not be using reference in the technical sense that I am.In any case it doesn't matter, what you have is an array, and you can easily use a pointer to refer to an array, like thisNote that because you have an array of pointers, inview_menu is a pointer to a pointer (aka a double pointer). Also note that the address-of operator & is not needed in this code.EDIT Also note that inview_menu[selectPos] == ""Individual"" is incorrect. You cannot use == to compare C strings, you should use the strcmp function instead."
66150505,"I've made an animation library out of this for the WS2812 ledstrip:https://github.com/laurijssen/ledstripanimator/blob/master/ledanim.cThe timing stuff that jabujavi describes happens in the UpdateFrame function where every animation in the list advances to the next frame after it's configured milliseconds.Now you just call AnimList::UpdateFrame as fast as possible inside loop()editSo if you want to execute code every 2 seconds you create a class which inherits from Animation and override Updateframe. Then put ms variable at the time you want to pass between frames.
Of course remove all Adafruit and animation references if you just want a task based lib."
66189433,"I wrote this simple Serial full message repeater. It does not require a String object or any kind of delaying as in previous answers.How it works
It receives characters and stores them to buffer until terminating character \n or \0 is received. Then it prints the whole buffer back.There is also implemented buffer overflow check, so you don't lose any data.The main advantage of this solution is the speed and possibility to react to the message content even before the whole reading procedure is complete (for example, you can implement a message parser on top of this very easily)."
66423738,"Nvm, turns out I'm an idiot.This entire time it was a simple typo in buildShader() function. Here's the fixed version of that function:The problem was that I was accidentally returning true/false instead of the shader. I have absolutely no idea how the program still managed to run without an error and display a white triangle but that's how it is."
66946427,"looking at the definition of Vector it does not provide a operator==:but using these methods, you can define your own operator== at the start of the file (or put into your own file):now your == comparisons will work."
67259939,"The first approach I looked into was to use some kind of compression on the bitmap font table such as run length encoding as so many entries were binary zero. I tested this approach and it did reduce the amount of memory while adding a bit of complexity. However the amount of memory saved was around 200 bytes with the simple approach I tested.The second approach I looked at was reducing the size of the array by first eliminating the lower case letters and then by changing the bitmap font as well. Changing the bitmap font from a 16x16 size font to an 8x8 size font makes a significant difference in memory usage.However changing the size of the table from const unsigned char font16_B[96][16] to const unsigned char font16_B[96][8] means that the characters displayed on the TFT screen will be smaller.So there is a tradeoff between the amount of memory used and the character display size. Larger displayed characters requires more memory for the description of the glyphs.A quick search for ""8 bitmap font"" finds this GitHub repository of Daniel Hepper, https://github.com/dhepper/font8x8, with an 8x8 size font and the license is Public Domain.Using Preprocessor directives to select the font table to use and selecting a subsection of the file font8x8_basic.h from Hepper's GitHub repository, I added the following to the KeDei TFT library.I also had to modify the character drawing loop so that rather than using 16 columns, it used 8. The number of columns was a hardcoded constant but is now specified by the class variable font_size which is set to either 16 or 8 depending on whether the defined constant USE_FONT_8_B is defined or not.The loop looks like:If I turn on using both the 8x8 font and the SMALLER_FONT_TABLE define then when I compile my sketch I get the following compiler output about memory usage:Here is a comparison of the two different sizes on the 3.5"" TFT display attached to an Arduino Uno. The button is 64 by 40 pixels.NoteI have forked the KeDei TFT library source code from Osoyoo's GitHub and have begun modifications to the source. The fork is located at https://github.com/RichardChambers/driver/tree/master/KeDeiTFTOne of the changes made was to allow text to be double high and/or double wide. This image is of the current version of a scanner/scale simulator showing the difference in style between text that is double high and double wide as well as text that is double high.This updated image show what is expected to be the final GUI for now. It allows for changing the weight and it also allows for setting various status bits to indicate scale error conditions such as under capacity.In order to support the number of buttons, I rewrote the Button class so that I could have buttons which share some data thus saving about 11 bytes per button. So this GUI with eight buttons that are using the data sharing feature saves some 77 bytes of memory, a significant saving for an Arduino.The Button class is now derived from a ButtonShared class. The ButtonShared class is used to declare groups of related buttons which will have the same style. The ButtonShared class contains all the button mechanics and a Button object is a ButtonShared object with its own ButtonData member rather than a shared ButtonData member."
67369247,"I should say I do not like at all the idea of ""auto declare functions in an array"". Placing data in sections are neat tricks, but it's just spagetti code - different parts of code are connected via invisible links - which may lead to unmaintainable mess. Instead of resorting to compiler tricks, I suggest to just write a single big array in one place with clear and simple and readable and maintainable code.is there an easy and similar way to declare a list of functions dynamically?That's relatively very very simple. You place data formatted how you want into a section. Gcc compiler picks up all sections from all files and concatenates them (let's say in random order) and generates to symbols - __start_SECTIONAME and __end_SECTIONAME that you can use to iterate over the elements in the section.The following code:then compile and link:and you can:The same way instead of using __attribute__((__section__(""autofunc""))) you could make a big array of structures that has all the information in one place.Many compilers have different syntax of how to place data in a section and how then get to that section. Research your compiler documentation.Note that that is some convention that sections with leading dot are rather reserved. Prefer to use sections without leading dot for custom sections.How is it possible ?Compiler and linker expose a specific interface to work with user defined section that allows to do just that."
67764997,"In C/C++ one does not simply return an array from a function.When you allocate an array inside a function, you cannot return a pointer to the first element in that array, since when the function returns, all local variables allocated inside that function are wiped clean.When you do this, a pointer to the first element in the array listum is returned from the function. If you know how many elements there are in the array, you can loop through and offset that returned pointer to print each element.You could do this if it were not for the caveat that whenever you return from a function any stack allocated local variables are destroyed or wiped clean, so you are returning an invalid pointer. This is because these variables are stored on the function call stack. When a new function is called, the variables are pushed on top of the stack, and when that function is returned, the variables are popped off the stack.There are two main ways of returning an array from a function. First one, is heap allocating a dynamic array, using malloc() or new. The heap is a region of memory outside of the stack, so it is possible to manually allocate a variable inside the heap, but you would have to also manually deallocate that variable otherwise you get a memory leak.In this example we are manually creating three integers in the heap using malloc(), then fill the allocated integers, and returning a pointer to the first integer. Then in the main function we loop through these three integers, and print each element. Then we need to manually free these three integers, because we manually allocated them.The second way is to create an array in the calling function, and pass a pointer to that array into the called function.Here we do not need to free the array because it is automatically allocated in the calling function. We did not manually allocate it.If that doesn't make sense, perhaps you can watch the following videos:I would recommend you to watch this playlist:"
68095903,"This is how your code can be made to compile without errors:Free function pointers are fundamentally different from member function pointers: You need an object to call them. An object cannot be NULL. NULL should be avoided altogether in favor of nullptr. For initialization of members you should use the member initializer list rather than assignment in the constructor body.However, this wont help you to call class2::readSerialData from class1, because you need an object of class2 to call one of its methods. It's not quite clear why you started with function pointers, so I cannot tell you how to fix your actual issue, but this works (and is much simpler):"
68128276,"This syntax uses initializer list, a feature added to C++ with it's 2011 version.If you can, do switch to a more up to date compiler, at least handling C++14.If not, you can still resort to C-style:An other solution would be to provide a user-defined constructor to Station:"
68371366,"You code for adding a text ""record"" into the tag is correct. The reading from the tag for the message payload however is not. It take a little bit more to get to the ""record"". The nfc.read() return a tag object which consists of a message object, which could consists of multiple records, and within each record, it has the payload length and payload (which is the text node you added), some parsing is required to get the data you wrote into it.Please noted that the data are stored with a prefix that indicating the charset used for encoding the record, I add the code to discard the prefix, the record is stored in byte, it need to be cast to char before Serial.print()."
68460095,"Arduino's Vector library (https://github.com/janelia-arduino/Vector) accepts a statically allocated array at construction time, unlike std::vector which you can pass a size_t into.You will need to pass an array instead of a size_t, or use a different data structure during these member initializers:"
69019583,"You have two Debug values in your code. One global, one member of the Box class.Those are two distinct values, since Box create or copy from a value to create its own, and there's the global one.A solution would be to contain a reference or a pointer.Here's the example with a reference:If you want Box to still be assignable, then use a pointer:Since references are immutable, you loose some important feature of the language: assignment.The assignment would cause t1.ref to point to b after the assignment.Pointer has a more difficult syntax and hard to guess semantics. However, they play very well with assignment since they give you more freedom:"
69262903,"So this is the solution I came up with:You call it as smoothReading<[desired pin]>(). It's very similar to analogRead(), but you'll get the average of 10 readings."
69312975,I guess that you need an array of function pointer.
69517945,"Good question. C-style arrays mixed with C++ objects are tricky as hell. The syntax you've used here doesn't call the constructor for the class Adafruit_NeoPixel with the three arguments you've specified:Correct way to create a C array of C++ objects is either this (note the curly braces which enforce initialization and invocation of the constructor):or this (constructor called explicitly):If you are interested in the root of your problems, it's the expression (LED_COUNT, LED_PIN_0, NEO_GRB + NEO_KHZ800). This gets treated as a comma operator which evaluates all comma separated statements sequentially and returns the value from the last one. So your Adafruit_NeoPixel class got constructed by calling Adafruit_NeoPixel(NEO_GRB + NEO_KHZ800) which probably breaks something important inside it.Consider this snippet of code:You'd expect it to print outBut it doesn't. Instead it prints outThat's because the first object effectively got constructed with Foo(2)"
69525370,"The class has to be templated, rather than the member:In C++17, we can make it figure out the type of F automatically when making a Foo by adding a template deduction guide for Foo:Then, we can use it pretty easily!If you absolutely need runtime polymorphism, you can have an interface that each Foo<F> extends:This article about the way std::function is implemented provides more details than I can in a stack overflow post: https://shaharmike.com/cpp/naive-std-function/Addendum: You can see a working example here.When compiled with optimization, the assembly is extremely compact. One of the benefits of C++ is that there's no overhead in using lambdas or templates, and they're entirely transparent to the compiler.(Virtual functions are NOT transparent, which is why I do my best to avoid them, but sometimes you really need runtime polymorphism)"
69559746,"The performance improvement is not significant, although in an arduino environment,
you may be fighting to reduce every byte of generated code (more than execution speed).As listed, the code is a bad idea, although it will ""probably"" work OK, that's usually not good enough.For this case, you could do something like this:although you'll have to change the rest of the code to match.Edited to add:If the class contains no virtual methods and no other data, you could also do this:memset(this, 0, sizeof(*this));"
69649954,"A very specific limitation of rosserial is arrays have an extra field specifically for data length. This is needed since the data field is implemented as a pointer, thus having no real good way to get data length. The message type actually looks like thisSo, all you have to do is set the data field before sending a message"
69700981,"Thanks @hcheung...So I'm not sure if you pointed me to the interrupt page, with reference to the code issues around my interrupt handlers - I think I have sorted these by using volatile variables and removing excess code/print statements from the ISR handler. So thanks for the link - it was a helpful reminder.However this did nothing to resolve my issue and the output remained the same! On the interrupt page I noticed some code where registers are copied to a buffer and then reassigned later. I decided to try this and copied the ADCSRA, ADCSRB & ADMUX registers on program load and reassigned them after the AD scan.
This also failed - Then as last ditch I copied the registers just before the call to start the AD scan (i.e afer analogRead had been called) and it worked. I am now able to use the analogRead command after my continuous read.I attach updated code that works - i.e analogRead works after being in continuous mode.Output:"
69794580,https://godbolt.org/z/sesW14W5e
69922245,"Ok, I've stripped down the code, as well as combined them into a single file     in order to streamline testing the architecture concept (code embedded at the end).I think I have found the smoking gun - my OCR register is being set too low, likely as the last assignment of the acceleration phase. I caught it by printing the current OCR value at the same time I print the current step count. Here is a snippet of the serial output which shows the smoking gun:My hypothesis is that I am assigning a value to the OCR register which is outside the bounds of my OCR array. However, I am not sure how it is happening. The steps are only updated during the acceleration phase and deceleration phase, and the speed update ""distance"" (steps before adjusting OCR) is calculated from the number of acceleration steps, so I don't see how I can get a mismatch between the array index and the array bounds. Any ideas?Code:"
70121268,"C has a pre-processing command #error that can be used to trigger a stop to the compiling. However, the compilation unit is processed in order, not ran. Some programmes need to just run to see, (which is related to the halting problem.)The idiomatic way to to runtime checks is with assert, as in this C99 example. (You would #include <cassert> in C++.)However, C++ has techniques that encourage RAII; when possible, one should generally use this to set up an object on acquisition and manage the object throughout it's lifetime."
70200792,"See here: https://stackoverflow.com/a/17493585/2027196Arduino does this mean thing where it finds all of your function definitions in main, and generates a function declaration for each above the rest of your code. The result is that you're trying to use ProgressStore before the ProgressStore struct is declared. I believe the IRAM_ATTR must suppress this behavior.It ends up generating this before compilation:One solution is to move your structures and classes into their own .h files, and include those at the top.ProgressStore.hmain.cppThe function declaration is still auto-generated, but inserted after your #includes"
70230287,"found an answer if you need to do the conversion on the fly (and not just with a string in the source code).Solution is here:http://bjoern.hoehrmann.de/utf-8/decoder/dfa/Working example, table stored in PROGMEM:"
7295736,"I agree with the peek() -> count() error listed by vhallac.  But I'll also point out that you should consider averaging by powers of 2 unless there is a strong case to do otherwise.The reason is that on microcontrollers, division is slow.  By averaging over a power of 2 (2,4,8,16,etc.) you can simply calculate the sum and then bitshift it.To calculate the average of 2: (v1 + v2) >> 1To calculate the average of 4: (v1 + v2 + v3 + v4) >> 2To calculate the average of n values (where n is a power of 2) just right bitshift the sum  right by [log2(n)].As long as the datatype for your sum variable is big enough and won't overflow, this is much easier and much faster.Note: this won't work for floats in general.  In fact, microcontrollers aren't optimized for floats.  You should consider converting from int (what I'm assuming you're ADC is reading) to float at the end after the averaging rather than before.By converting from int to float and then averaging floats you are losing more precision than averaging ints than converting the int to a float.Other:You're using the += operator without initializing the variables (qu1, qu2, etc.) -- it's good practice to initialize them if you're going to use += but it looks as if = would work fine.For floats, I'd have written the average function as:And called it: average(queuea, 5);You could use this to average any number of sensor readings and later use the same code to later average floats in a completely different QueueList.  Passing the number of readings to average as a parameter will really come in handy in the case that you need to tweak it.TL;DR:Here's how I would have done it:"
8087366,"You can use something like this:orand then to make a function to translate a whole string...Advice:
Use a ""framebuffer"" - an array of 10 x 5 chars or 10 structs.
Send to Arduino, normal, C strings.
Convert characters from string, as needed, and put them in the frame buffer. In this way you can create scroll effect, very easily. 
Use a struct to keep character information."
8087796,"Extrapolated from my answer at How to read bitN integer data from a binary file?
Note this doesn't check boundries and will read past the end of the array given."
8124544,I understood from your post that you need to send data using visual studio not to write a program to flash or any other stuff. Here is an example i made for you on my machine it works sending the text test.
8737814,"All of your functions should have volatile qualifier, just like const qualifier needed for constant objects. Here is an example:"
8819664,"You can do this by making a functor object, that acts as a proxy between the timer code and your code.If it can't be done via a functor object, you could global variables and functions instead, maybe in a namespace:This only works if you have one robot instance though."
