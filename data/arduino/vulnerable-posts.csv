PostId,Body
10407,"I do not claim this method for my own, but I found this neat trick on the webpage MUX-DEMUX: CD4051 Parlor TricksWhatever method you choose to use to drive outputs or read inputs (shift registers, multiplexors or the straightforward direct use of the Arduino pins themselves) you can DOUBLE the number of outputs or inputs by a clever use of parallel circuit pairs (to form a dual input or output bank), employing diodes in opposing senses on each parallel branch, and switching the inputs/outputs to high and low.To illustrate the method for outputs (LEDs in this case, note that the extra diodes are not required):If you consider the pair of LEDs in this example to be a ""bank"", and
  you want to light LED_0, you need to set PIN 17 to HIGH, and PIN 18 to
  LOW. (The pin numbers are confusing, but they match the later example
  so bare with me). To light LED_1, you just reverse the PINS. The diode
  nature of LEDs keeps the current from flowing the opposite direction
  keeping the other one off.To illustrate the method for inputs (CdSs in this case, note that the extra diodes are required):This gets a little more complicated if you want to do an analog read
  on a CdS light sensor. First, you need to add a diode to each sensor
  to control the flow. Second, since you are reading values, you need to
  pull the inputs high or low to keep them from floating. Being a lazy
  person, I'm going to pull them high using the internal pull-up
  resistors. To read CdS_0, you set PIN 17 mode to OUTPUT and set it to
  LOW. This makes it the ground. Then you set PIN 18 mode to INPUT and
  set it to HIGH to engage the pull-up resistor. Now you are set to do a
  read on PIN 18 (a.k.a. analog pin 4). To access the other sensor, just
  switch the modes and outputs.So, if you have a CD4051 8 port multiplexor, using 5 pins on the Arduino (instead of the usual 3), you can obtain 16 inputs or outputs, or a mix of the two.Likewise, if you have a 4067 16 port multiplexor you can obtain 32 inputs or outputs, or a mix of the two.An example sketch would be:Like I said in the first line, the full explanation can be found on MUX-DEMUX: CD4051 Parlor Tricks"
10534,"I've built This circuit without C4 and everything after R4 (no rectifier, not a single diode used). R4 has to be switched for 100kOhms, since this gives a 100x amplification. I guess this is simple enough for most people.
Thanks for the hints.The following code can be used to detect claps/noises. It is restricted to a double-clap with silence in between. Parameters can be easily tuned. This works quite well for me, even when I play noise/TV/music to the speaker directly it triggers rarely, or not at all!"
12208,
13135,"If you want to fade all the LEDs form blue to red at the same time, I think you want code like this (explanatory comments embedded)..."
13137,"If you want to fade all the LEDs form blue to red at the same time, I think you want code like this (explanatory comments embedded)..."
13260,"I would recommend starting out with some easy stuff you understand or making code yourself... Starting out with code you don't understand will backfire you.I'll explain the code for you anyway.This part will ""set everything up"". The serial connection and the direction (in/output) of the pin(s).Somehow did the person who made this think it was logical to put this here instead of on the very top of code. There are 2 integer variables declared here of which one is initialized with 0. (f).This part of the code (untill the very last bracket) will be ran continiously, in a ""loop"". Many, if not all, embedded systems will run ""forever"".This is basically a ""flag"", it indicates if something has, or has not happened. At this point it's only initialized.Also we're keeping a buffer (text string) of the characters we receive.Check if there are characters in our serial buffer.If so, we empty our own buffer.And keep doing this code.We wait until the next character is ready.And add it to our buffer.But when we see our buffer ends with \r\n\r\n (carriage return, line break x2).We're going to set te flag, indicating that we have received a message.
And we stop the: ""Keep doing this code"".So we had this message, right? Let's do the following:Parse the variable in the GET request (f=??) to an int.Send a 200OK (with body) back to the thing that sent the http request (actually pretty neat to do so.)We also keep doing this blinking. (Fun fact: While receiving/sending stuff, your blinking will stop/desync. This is because the receive/send code is blocking the blinking code. Making the blinking hardware and/or receive/send interrupt based will improve the systems reaction time and efficiency.)But how will we make this better? Or atleast easier to read?
By using functions, you can split up the code, and giving the functions a logic name, it all becomes quite obvious. The whole thing is doing 3 jobs:
Blinking a led on a given frequency.
Receiving requests/commands through serial (handling serial).
And handling these requests afterwards.V2 (more likely to compile, but kinda changes the structure):We can even make it more nicer by:"
13267,"Here is my take at this. I realize that I did not really make the
program simpler, but hopefully better in some respects, as it avoids
blocking reads and heap memory allocation. Be warned however that I did
not test it. It compiles fine though.Preamble, hopefully simple enough that it requires no comments:Next, here is a function to read the HTTP request. A few things are
worth noting in this function:Parsing the request is done by a different function. Here, I do not
search for the ""GET /blink?f="" string, because it must be at the very
beginning for the request to be valid.Now we can send the response to the client, telling it how we parsed the
frequency. I avoid using String, as it involves heap allocation, and I
put the bulk of the response in PROGMEM (F() macro) to save RAM. I
also added a <title> to make it valid HTML.The next function blinks the LED in a rollover-safe fashion. Storing the
current LED state in a static variable avoids a call to digitalRead().Putting it all together, the main loop() ends up being quite straight
forward:PS: My version is significantly larger than the original at the
source level (66 v.s. 44 source lines of code), but the compiled program
is smaller in both flash and RAM usage:"
14050,"The problem was two pronged---both the copy/paste error that @Gerben pointed out, as well as the incorrect if-else statements that @BrettAM pointed out. Below is the working code: "
14055,"I suggest you first find what your Yamaha is sending you. I have a sketch that decodes MIDI for the Uno (assuming you have a Uno lying around). Run that, and see if you got note on with velocity zero, or note off. Then you are a little closer to solving the problem.This part is quite wrong:You are reading 3 bytes, even if none are available. At least change it to:The do ... while construct tests at the end of the loop. You must ensure you have 3 bytes ""available"" before reading 3 of them, not after.The code below is an adaptation of the MIDI decoder in my link above. This one just reads the incoming MIDI and turns on the LED on a ""note on"" and turns it off on a ""note off"" (or note on with velocity zero). Tested, works perfectly.From a comment:the 4N35 is too slow to work reliably with MIDI signalsBelow is an updated schematic that uses a faster opto-coupler.Admittedly the 4N35 is below spec for its rise time (it is supposed to be  less than 2 μs rise time, however the 4N35 is slower at between 3 µs and 7 µs). However during my testing it worked OK. It sounds like the faster rise time is specified to allow for multiple devices to be connected in series, a slow rise time will introduce distortion."
14169,"After reading the datasheet on the PS manual, I found out that the INT1 pulse had a width of 50uS.So what I simply did was to declare a global integer and check it at the end of the loop.Whenever I checked the incremented variable at the end, it was 48!.I personally suspected that my loop speed was to slow. Additionally the timeout value 14 ms per loop arbitrary. Clearly a disparity exists in the interrupt routine for the sensor and the microcontroller.So what I simply did was to reconfigure the sensor output to a latched signal which clearly solved the problem. I am now getting synchronized interrupt with convincing results.Here is the code:"
14304,"Got it! After doing the requisite amount of research... I've developed a much improved checking system which allows me to truly demarcate between messages during running status much like Nick Gammon's code. While the code seems to work perfectly now it was still a bit glitchy when I tried it the other day. Perhaps I accidentally fixed it, most likely it'll crop back up again. How does it look?On top of this, I managed to tweak the code to output particular values to a shift register as I had initially intended. The method I use to differentiate between note and velocity bytes is less than ideal but works on my keyboard. Because of certain limitations it only works over a range of 13 notes but that's fine for now. Code and flowchart below."
14352,"If you just want some example code, here is a smallish sketch I wrote that controls some LEDs via a shift register. Exactly how the shift register works isn't important, but you can see the basic idea for taking input from the serial port and decoding it:Example of commands understood by the above code:This code processes a 3-digit string as:Where ""nn"" is the LED number and S is the new state (1 = on, 0 = off).There is a more elaborate example on my page about using a 74HC595 output shift register as a port-expanderHow to process incoming serial data without blockingState machines"
1447,"What you describe seems to be a common issue that many C or C++ developers can get (or have got) with sizeof.Take a look at the following code:In that code, size1 will be evaluated, by the compiler, to 3 which is the real size of a variable, whereas size2 will be 2.This is just because sizeof a is evaluated by the compiler, and the compiler knows that a is an array of 3 char; but when a is passed as an argument to function size(), it is converted to a pointer (to the first element of the array), hence its size is the size of a pointer, which is 2 bytes on AVR ATmega MCU.This subtlety of sizeof may explain strange values as you describe.Most C functions that take an array as argument will require another argument that tells the size of the array; that's the way (the only one I think) to deal with this problem.Here is a sample code:It is common practice in C to declare an array and immediately after, define its size as above."
16002,"The “hint of blue on the strip” is a consequence of your second loop in rgbFadeInAndOutStrip1() ending with the test b > 0.  Because of that, the last strip1.setPixelColor() call sets the color to (0,0,1), a faint blue, instead of (0,0,0), off.  Here is some revised code that works ok:Note, since I ran tests on an Uno rather than a Leonardo, I attached pixel strings to pins 7 and 8 rather than 17 and 18.  I used enum to define constants, rather than declaring constants as variables, and factored some common code into functions rather than reduplicating it.Following is another program (which I call neocycle6) you can use to test two strips.  Note, it only counts colors down to 1 rather than 0 because I like the effect of leftover pixels glowing faintly.  Also note: the round boards I used have only 7 LEDs each, so I set PixelCount to 7, not 11; this uses pins 7 and 8, not 17 and 18; I don't drive the brightness beyond 77 since the LEDs are so bright anyway; and it doesn't have an
#include <avr/power.h> statement, which you can add if needed."
16003,"Your GSM shield will receive the SMS which your Arduino code can retrieve as a string of characters (that description hides a mountain of detail, most of which you won't need to know). It doesn't care what the content of the SMS message is.Your Arduino code will have to translate from the message text to motor-control commands so you want some text commands that will be easy to parse, but not so trivial that any random message might wrongly be interpreted as legitimate commands.The digit pair ""15"" might command motor 1 to speed 5. But you wouldn't want any message with a couple of digits in it to change a motor. (You didn't say you had multiple motors, and if not you can leave that part out).Let's make the message distinctive enough that it's unlikely to appear in some other context, yet simple enough to distinguish as legitimate. It would be nice if it's simple to thumb-type, too!""motor,1,5"" could convey the same information as the ""15"" in our first example, doesn't limit you one-digit values, isn't likely to appear in a ""Hey Dude, lunch at 12:15?"" type of conversation, is easy to parse and isn't too long to type on a tiny keyboard. You could extend it later, so ""motor,1,+2"" could mean to increase motor 1's speed by two units, ""motor,1,off"" could mean power it down (not just zero speed), and ""motor,all,off"", well, that's probably obvious.Look up the function sscanf() [oops: not sprintf()] for one way to parse the incoming strings and collect their data.Update: sscanf() does the reverse of sprintf(): It reads a string, collects values from it, and assigns them to variables. Search sscanf on the web for a description of its use.
Here is a sample program that reads a few possible SMS messages, checks whether they are motor commands (according to my simple example SMS above), and if it is, assigns the contained values to some variables in your program. You can see by the return values of sscanf() whether and how many conversions it made from each message, thus your code can tell whether a received SMS looks like a motor command, as well as what the command values are:"
1605,"Could you tell us which multiplexer IC you are using? This way, we can help you better. Also, why do you need the 8 second cycle? Does it matter if it's a little shorter or longer? If timing does not have to be very precise it would make things a lot easier.By the way: you say there are 30 sensors, but your table has 32...The following pseudocode will not work on your Arduino, but you can use the same structure.This code is by no means optimized, but written to make it easy for you to understand. Good luck!"
16155,"Each time the watchdog interrupt triggers, WDIE is reset. You will need to set it again in the loop if you want to continue capturing the interrupt rather than resetting the system.Also, consider using <avr/wdt.h> and <avr/sleep.h> to handle (most of) the watchdog and sleep functionality."
162,"If you want to know exactly how long something will take, there is only one solution: Look at the disassembly!Starting with the minimal code: This code compiled and then fed into avr-objdump -S produces a documented disassembly. Here are the interesting excerpts:void loop() produces:  Which is a function call (call), four copies (which copy each of the bytes in the uint32_t return value of millis() (note that the arduino docs call this a long, but they are incorrect to not be explicitly specifying the variable sizes)), and finally the function return.call requires 4 clock cycles, and each sts requires 2 clock cycles, so we have a minimum of 12 clock cycles just for function call overhead.Now, lets look at the disassembly of the <millis> function, which is located at 0x14e:  As you can see, the millis() function is fairly simple:So, if we add them all up, we have a total of 17 clock cycles in the millis() function itself, plus a call overhead of 12, for a total of 29 clock cycles.Assuming a 16 Mhz clock rate (most arduinos), each clock cycle is 1 / 16e6 seconds, or 0.0000000625 seconds, which is 62.5 nanoseconds. 62.5 ns * 29 = 1.812 microseconds.Therefore, the total execution time for a single millis() call on most Arduinos will be 1.812 microseconds.AVR Assembly referenceAs a side-note, there is space for optimization here! If you update the unsigned long millis(){} function definition to be inline unsigned long millis(){}, you would remove the call overhead (at the cost of slightly larger code size). Furthermore, it looks like the compiler is doing two unnecessary moves (the two movw calls, but I haven't looked at it that closely).Really, considering the function call overhead is 5 instructions, and the actual contents of the millis() function is only 6 instructions, I think the millis() function should really be inline by default, but the Arduino codebase is rather poorly optimized.Here is the full disassemby for anyone interested:  "
17025,"You are reading data without checking if there is any data there. That's like watching the TV without checking if it is turned on. Of course you get weird data.Pins 0 and 1 are used by HardwareSerial. Why are you using them for SoftwareSerial?So you initialized HardwareSerial, which now controls pins 0 and 1.Then you try to initialize SoftwareSerial on those same pins! Would you mind explaining why?Whatever your explanation is, it won't work.I've added in the changes you mentioned, but the data still seems to be skewed.You've changed things, for sure:Let's see. In a loop of 100 iterations you see if anything is available (and if so, put it into x).Then, regardless of whether or not you got anything you now assign x to y[i]. So, most of the time, y[i] will have garbage in it.the data still seems to be skewedNot surprised. Do it differently. Only write to the array if you have data. In fact you may want a complete rework. Read this:How to read serial without blockingI have posted the amended code. Change: Only add to the array is data is being read from buffer.You still have not fixed it. Let me talk you through what it is doing now.You are making 100 attempts to read some data. One or two may succeed, and they will be put into the buffer y (funny name for a buffer, right?).So imagine . is garbage and X is good data, after doing that loop of 100 the buffer will look like this:So your buffer is still 80% unchanged garbage. Then you print the first 64 elements (why 64 and not 100?) and you get a lot of garbage out. Exactly as expected.You need to think about what you are doing. Draw it out on a bit of paper, perhaps.Here is some example code from the page I linked for you, more than once. Please compare:"
17255,"Once I made a sketch to run multiple programs. I wrote a setup and loop function for every different ""program"", (e.g. setup_p1, setup_p2, ... loop_p1, ...) and then wrote a simple main sketch to handle them all.In my application I choose the program at startup with a 3-dipswitch, but you can easily switch this to allow ""on the fly"" switching.I choose to use a callback because it's faster than just checking the mode every time, at least in my case"
17504,"I had a similar problem when i tried to control some heating source here at home.This was how I made my steps to get it working.
First I will assume you are using the library time.h and DS1307RTC.h (check here for info: https://www.pjrc.com/teensy/td_libs_Time.html).Assuming that you will need 3 variables of the type tmElements_t.
tm will store your current time( the one you get from DS1307). The other two are auxiliary for defining time you start and time you stop the pump.
In similar way, you will need 3 variables of type time_t for the same reasons.
time_t variables store a the timestamps since 01/01/1970 (Unix epoch) which are easier to work with but tmElements structures are more human friendly.Now in your loop you need to get the current time from rtc:after, use the breaktime funtion to convert the timestamp value to tmElements struture:Next step is to copy contents of tm to the other auxiliary structures, use the memcpy function:after, change the the auxiliaries vars to meet your correct schedule of start and stop (are seconds important? if so, do similar way):Ok, we have the more human friendly start and end structures, lets get the timestamps from them. To do soo we use the makeTime function that converts tmElements_t structures to time_t:All you need to do now, is check if your current timestamp (now) is between this newly created timestamps:Extra tip: In case your stop hour goes past midnight, add one more day to the timestamp:clean code:EDIT: to correct the thing about midnight checks spotted in comments. New code:"
17614,"The problem code was reduced to this:This is the code which works:But I don't know how to explain that char inside main makes the problem disappear...EDIT
Just for the record, here are two more examples. The first example works with both compilation methods. The second example works only with the second compilation method. The examples differ only with that in the first direct code is used, and in the second it is used via functions."
18097,Given that my Python script printed the followingThis is the sketch I used to retrieve the array
18116,"This is my updated code based on your suggestions, jwpat, although I did not understand your comment with delay(70); not being needed if I start conversion with (2,0x5A). After running this code my results keep being the following values regardless of me shifting the distance between the sensors: 
72cm "
1816,Ended up going with something like this:
18221,"Regarding the question, “Does PinChangeInt only work on digital pins?”, note that PCI's work on all the digital pins of an ATmega328, and on the first six analog pins.  (32-pin '328s have eight analog pins, A0-A7; 28-pin '328s only six, A0-A5.)Regarding the problem symptom that “pulsewidth just seems to increase continuously”, that could happen if for some reason rising edges aren't processed.  To debug, add a couple more volative byte variables, say nrises and nfalls; increment each of them in the appropriate interrupt handler; and report their values from time to time.Regarding your #include <PinChangeInt.h> statement, note that PinChangeInt.h is deprecated (as of 3 April 2015).  Consider using EnableInterrupt.h instead.It's possible you'll resolve your problem while changing libraries.  If so, fine.  If not, or if that library's performance isn't adequate, consider changing over to handling the  pin change interrupts more directly.  The ISR in the following sketch shown below runs several times faster than code that uses PinChangeInt or EnableInterrupt library calls.[Edit: This edit encloses the ISR in a sketch that compiles.  The code previously shown was missing two array length specifications.  This code was tested with a rotary encoder attached to A2, A3, with A0 and A1 grounded; an output sample (using an Arduino Nano) follows the code.]The code shown above uses Streaming.h, a contributed library that adds some “syntactic sugar” to Arduino C.  That is, at compile time it converts C++-like << Serial stream operators to Serial.print statements, without increasing code size.  If you don't have Streaming.h installed, either install it via Streaming5.zip from arduiniana.org or manually translate the Serial << ... statement to Serial.print statements.A sample of the sketch's output on serial monitor:In the output above, the two 0's are from A0, A1 being grounded and not changing.  The next two numbers are from the DT and CLK lines of a KY-040 rotary encoder, which toggle alternately to encode step-direction.  They should represent on-times in microseconds, and are always multiples of 4 because micros() reports multiples of 4.  The last number is the number of times the ISR's change-checking loop ran since loop()'s previous print.  An A2 change will show a count of 3 or more, and an A3 change 4 or more.  Cases where times are the same may represent contact bounces shorter than the ISR's service time; ie, several falling edges in a row might be detected, or several rising edges.  A storage scope or logic analyzer probably is necessary for finding out exactly what happens."
18281,"You may find my answer to another question –  Read RC receiver channels using Interrupt instead of PulseIn – useful.  It includes the sketch shown below, which is intended for background timing of four RC channels attached to pins A0-A3.  See the other answer for further comments about the code, example output, etc."
18304,"Ok, if I understood what you meant, you want that a single led in the ring is on and the refresh rate is dependent on the pressure, right?If so, you did not write any ""select this led"" code, so it can't work.I fixed a couple of things in your code. Mainly:So, here is the fixed code. Let us know if it works for you"
18795,The compiler needs the prototypes of the functions before the body containing the call to the overloaded function otherwise if starts complaining that the parameters does not match the known function (at this point in the source code).Cheers!
18875,"So here's the new version, very strange, when I set the number on random, it doesn't work. However, if I enter a number myself, it does."
19007,"You might experiment with the code shown at the end of this answer.  It is fairly responsive, in the sense that readings are taken reasonably quickly (several per millisecond), which should leave a good deal of time available for other processing.In this code, all of the pins that are on the same port are sampled at the same time.  For example, pins 2,3,5,6  on an Uno are all on port D so their four pads can be tested all at the same time.  But if the pins list includes pins from k different ports, sampling will take up to k times as long as when sampling from a single port.  For example, on a Mega2560, pins 2, 3, 5 are on port E and pin 6 is on port H, so this code's execution time when processing buttons on pins 2,3,5,6 is about twice as long on a Mega as on an Uno.[Edit:  For Uno port-to-pin assignments, see an Arduino Uno Pinout Diagram.  On such diagrams, labels like ADC0 PCINT8 14 A0 23 PC0 show the Arduino digital pin reference number (eg, 14), analog pin label (eg, A0), its various functional designations (ADC0, PCINT8, and PC0, meaning analog input pin 0, pin-change-interrupt pin 8, and bit 0 of port C), and the physical pin number (23).   For hardware level information about Uno ports, see Atmel's document #8271.  Use Google images similarly to find other-model diagrams, eg Mega 2560 pinouts.]You may need to tune some of the constants to fit your own circuitry or switch-function requirements.  I'm not able to tell from the question what resistor sizes you are using or what your circuit is.  For preliminary tuning, enable the secondly() function and disable testChange() functions.  If your circuit is similar to that shown below but uses higher resistances, you may need to increase nsamp, IsHighCount, and preSamp.Here is the general idea of circuitry I used:
In the above, ""Drive"" refers to pin 4.  ""Sense 1"" ... ""Sense j"" (with j=4) refer to pins 2, 3, 5, 6, as in your example code.  The capacitors illustrated are tape-covered aluminum-foil pads, eg 22 x 44 mm and the resistors are 440 KΩ each (two 220 KΩ's in series).  Those resistor values produce an RC time constant of a few dozen microseconds when a button isn't touched, and a couple hundred microseconds when a button is touched.Here is some example output:In that output, the first column is switch number.  The last column is the current reading of millis() at time of printing.  The third column is total counts accrued from 12 sets of contact readings.  The simple-minded on/off algorithm used in the testChangeA() function is that a contact is on when its 12-sample count exceeds 180.  One could also add calibrations, adaptive threshholds, debouncing, etc to the code.Here is the code (which was run on an Uno, but I tested most of it on a Mega also, and it should run ok on other Arduinos as well since the direct port accesses are computed via functions like portInputRegister, portModeRegister, etc in countPins7() setup before it calls portSampler7() to run the test."
19093,"malloc() by itself generally doesn't crash a program.  It attempts to allocate the requested amount of memory, and if it can it will.  If it can't (there isn't enough memory available) then it won't allocate anything and will just return NULL.By trying to allocate more memory than you have it will just fail every time and no memory will be allocated - thus you don't actually have a memory leak, so your program doesn't fail.The main reason for crashing is a phenomenon called stack smashing where the memory area used by malloc() (known as the heap) and the memory area for the stack (used by local variables and for storing the contents of registers during function calls) collide with one another and one corrupts the other.  For instance, if the return address of the current function in the stack is corrupted, when the function finishes it will return to the wrong memory location and who knows what may happen then?  Wrong instructions will be executed for sure.For instance, try this program out instead:If all goes well you should see lots of ""Allocated 10 bytes"" followed by some ""Allocation failed"".  Since the memory is now full there is a chance that it may now crash as the stack and heap collide - in which case you would expect to see the ""Allocation failed"" messages stop."
19109,"Regarding the notion that “""internal"" interrupt latency and/or software overhead is much higher than it is for the ""external"" interrupts”, it certainly is true that PCI (pin-change interrupts) libraries PinChangeInt.h (deprecated) and EnableInterrupt.h have high software overhead.  By keeping track of former values, for each pin those libraries support separate callback routines for Rising, Falling, Change, High, and Low.  PCIs are grouped in sets of eight pins per interrupt vector, leading to 40 different cases of callback routines when a PCI fires.  That is, when a PCI occurs, the libraries quickly find out which set of pins changed – because that's what the hardware supports – but then they go through all eight pins on the vector one by one checking if it changed, and how it changed, then calling the callback associated with the particular pin and its particular state.For reading pins of a rotary encoder, say a KY-040, the overhead described above can cause loss of 10%–20% of rotary counts.  If you are concerned about not losing counts, write your own ISR()-level interrupt service routine.  The example below illustrates a routine using ISR(); this example is from my answer to previous question #18221, with some comments added here and there.  See that answer for discussion of the timing data that is this program's output.  (For rotary encoder quadrature-counting, see discussion below).  Note, for the above you may need to download and install Streaming.h via Streaming5.zip from arduiniana.org.Rotary encoder quadrature-countingThe program above tracks and reports pulse-length times, instead of decoding the quadrature signals the rotary encoder provides.  The program below reports rotary encoder counts, but does so using INT0 and INT1 instead of PCIs.  You will want to combine relevant portions of the two routines together – ie, use the interrupt setup and handling framework from above, with the body of the service routine from below.  [Note, this program is from my answer to previous question #16420.  The encoder decoding code within it is faster and shorter than other decoding code I've looked at, and is fast enough to support two encoders rotating simultaneously while losing few counts.]Using other pins for PCIsIf you wish to monitor two rotary encoder lines using pin change interrupts on pins other than A0 and A1, you may need to replace vector PCINT1_vect with some other vector, and will need to replace the pins mask with a different one.  The following program can be used to display a table of PCI vectors, masks, etc.  (As noted in my question Why PJ0 and PJ1 are not reporting as PCINT pins, pins PJ0 and PJ1 on an ATmega-2560 board will not report correctly.)ISR-framework-generating SketchThe program below generates frameworks for specified PCI pins and prints them to Serial.  See usage comments within the program.  This provides an easy way to create the basic outline of an ISR to handle PCIs."
19327,"Measuring the peak-to-peak current and scaling the result will get you an answer which will at least go up and down with the magnitude of your average AC current, so yes it is NOT incorrect.  As you suggested it will be sensitive to noise from the sensor - in fact as you are taking the highest and lowest single readings the noise will always cause the measurement to be higher than actual.However, I think you could do better.  Given that the code is already having to take many samples (basically as fast as it can) for 100mS (which will sample 5 cycles of the waveform if it is 50Hz and 6 if it is 60Hz, depending on where you are in the world), then you could actually do the maths to measure the RMS value and by basing this on all of the signal the effect of the noise will be reduced.You need to know the ADC reading when there is no current rZero (which should be around 511 but could be off a bit due to offset errors) - you could measure this with nothing connected to calibrate the sensor, or take a long term average even with the AC signal present.As the henrysbench tutorial points out it is important that the Arduino samples the signal at a high enough frequency (say 1000Hz - hence 100 samples for your 100mS sample duration)- the count of the number of times that the while loop executes sampleCount will confirm if this still the case even with the extra computation time of this code.Also if you increase the sample time please be careful that the unsigned long rSquaredSum can't overflow, but I would avoid use of doubles within the while loop as they will definitely slow it down a LOT."
19457,A common issue when using strings (character vectors) is that the vector size is not updated when the format is update. Check the size required for this data. Does it fit for the sprintf() statements?What is the worst case size required? Cheers!
19541,"Taking JRobert's advice, i checked out the simpletimer library.. the final solution was to set up three timers and change the way the buttons functioned. as per documentation of the simpletimer library, added the following global:Then to setup, i added my three timersThen started the timers in loop by adding:Finally, i edited the buttons and added variables to denote state of button. 
i.e. Changed the touch screen code for each button to kick off the timers...then i added a void for each timer, this is where i redraw the buttonsHope this helps someone else in the future, as it was a real pickle for me to figure out at first.. Thanks again, and credit goes to JRobert, his advice pointed me directly to the solution."
19710,"Well, you need a sort of tracking for your active relay, don't you? So you just have to reset that tracking variable and the previousMillis variables and you are done.Some code (note: untested and moreover I don't know how you are receiving the SMS)"
201,"ardprintf is a function that I hacked together which simulates printf over the serial connection. This function (given at the bottom) can be pasted in the beginning of the files where the function is needed. It should not create any conflicts.It can be called similar to printf. See it in action in this example:
The output as expected is:The function prototype is:It returns the number of arguments detected in the function call. This is the function definition:**To print the % character, use %%.*Now, available on Github gists."
20300,Your system works in pure C too:It might be a good idea to store any static Menu Strings into PROGMEM.
20464,Thanks to Mikael Patel for suggesting that link (your Google-Fu must be strong!).I am pasting the code below so that this answer survives any possible future deletion of the read-only part of the Arduino Forum.I also cleaned up the code a bit.
20551,"A simple bluetooth module like a HC-05 wired to your Arduino will give you a  serial stream that can be read and/or written.  With the RX/TX connected to say pins 10 & 11, a SoftwareSerial() object will provide access:If you connect the module to pins 0 & 1 - you can just use the Arduino standard Serial functions, but it will cause problems uploading to the board.  In which case you would disconnect the bluetooth module for uploading."
20885,"The issues in your code:  When communicating with the sensor, the sensor expects a register address after the device address. Instead of providing it the register address, you sent the number of bytes you would like to receive. Good guess, but unfortunately the device was not designed that way.  You did not combine the least significant bits and most significant bits of the sensor output correctly. The LSB contains the 6 (not 8) least significant bits, while the MSB contains the 6 most significant bits. You first combined them like 00MMMMMM00LLLLLL (where bits marked L come from the LSB and bits marked M come from the MSB), and then masked off the upper two bits as in MMMMMM00LLLLLL. The proper way would have been to only left shift the MSB 6 bits, producing 0000MMMMMMLLLLLL, and then masking away the upper 4 bits leaving MMMMMMLLLLLL.You should avoid 32 bit floating point math on 8-bit microcontrollers at all costs unless you have a huge amount of processor cycles to spare.In order to read data from the sensor you must first select the register you want to read. To select a register you must first send the device address (95 in decimal, 5F in hexadecimal) with the write request bit set, and then the register address of the byte you want to read.
You can then read the contents of the selected register by first sending the device address, this time with the write request bit clear, and then receiving one byte of data immediately followed by a not acknowledge (NACK) to end the transmission.  The internal registers are organized as in the following table: Here is my take on the code. It compiles fine, but obviously I cannot test if it actually works as I don't have the sensor. I removed the scaling routine, as it would be wise to first get it working to some level before implementing less essential features.  For some unfathomable reason Silicon Microstructures decided to not include the I2C interface specification in the datasheet itself. The information is instead found in a separate application note.  EDIT:
Apparently Wire.flush() does absolutely nothing. Implementation from Wire.cpp:  And no, the implementation isn't in the base class either: virtual void flush() = 0;. To work around this, I replaced the flush call with a read() loop."
20912,"it returns me Tiny lat:33.55 on serial monitor. But i want 33.546600. How do I do that? The issue is simply the number of decimal places. That can be added to the Serial.println(). Now if i want to make a String ""your location is \nlat:33.546600 \nlong: 75.456912"" , i.e. my String variable are stored in Tiny_latitude and Tiny_longitude and want to make a string my_Location. How do i do that?I would use sprintf() for that but as that requires some additional build parameters the easiest way is to use String. Some special care is needed to increase the number of decimal places. Cheers!"
20913,This has been answered in the previous question but I can repeat it here:An alternative is to use dtostrf() as in your snippet:Cheers!
21189,"Gerben's comment:You need to call stepper.run() instead of runSpeed, for moveTo to work.provides the answer. The updated code is:"
21231,Thanks @Arjan for reminding me. I would love to contribute to the community. So this is my final coding and its worked for me :
21257,"Thanks to the help of Charlie Hanson and jantje I found the universal solution!Because it is a pity that every Arduino programmer has to go through the same pain to figure out how to get the board name, I will offer my code to the public so everybody can just copy and paste it.Here it is:You can even put this code into a new header file and #include it into your project.P.D.
If you want to know additionaly to the board also the CPU model, search for the file avr_cpunames.h"
215,"First, let's see a few examples of what can go wrong.As pointed out by Edgar Bonet in the comments, local variables like status in the code above are not implicitly initialized by the C++ compiler. So, the outcome of the code above is indeterminate. To avoid that, make sure you always assign values to your local variables.Things are a bit different with global and static variables:Global and static variables are guaranteed to be initialized to 0 by the C standard.Source: 
AVR Libc Reference Manual - Frequently Asked Questions - Shouldn't I initialize all my variables?That means you shouldn't worry about initializing them to 0 in your code. In fact, you should really avoid it, as the initialization may waste memory. Only initialize them to values other than 0.The first problem here is that you don't know what will be assigned to v, but worse is that you don't know what you messed up with the assignment to position -100 of array.The first call to funcPtr() will actually be a call to doSomething(). Calls like the second one may lead to undefined behavior.  Well, you can run out of RAM, for example. What else. In any case, I think your program will keep running, probably not the way you intended it to.In computer systems, problems like these are usually dealt with at various levels:Arduinos only have limited protection of the compiler, and probably nothing else. The good news is that they aren't multi-tasked, so the only program being affected is yours. In any case, any of those bugs will lead to erratic behavior.The assumptions are the all of the problems I stated above are runtime problems.What happens if there is a runtime error in a program? The program will continue and what happens will depend on the side-effects of the runtime error. A call to the null function pointer will probably make the program jump to an unknown location.Will execution of the program just stop?No, it will keep going as if nothing extraordinary happened, probably doing what you didn't intend it to do. It may reset or act erratically. It may turn some inputs into outputs and burn a sensor or two (but that's highly unlikely).Is there some way I get the Arduino to tell me what the error is?I don't think so. As I said earlier, the protection mechanisms aren't there. There's no runtime support from the language, no OS, no hardware checks for out-of-bounds memory access (the bootloader doesn't count as either). You just have to be careful with your program and probably set your own safety nets. The reason for the lack of protection is probably because Arduino controllers are too cheap, have too little memory, and should not run anything too important (yes, there seems to be a disclaimer by AVR somewhere for you not to use the MCUs normally used by Arduino in life support systems)."
21554,"I suspect a low RAM failure.  Here are some suggestions that will dramatically lower your RAM usage:1) You still have Serial.print using double-quoted C string constants.  Use F(""C string"") for those, too.  For example:Every double-quoted C string uses RAM in addition to FLASH program space.  You have already saved a bunch, but you should get rid of the above uses.
TL;DR - it will use extra RAM, FLASH, CPU time, and cause inexplicable or random failures.Instead, use C strings, aka char arrays for variables, or double-quoted string constants.  When the constants are wrapped with the F() macro, they don't use any RAM.Here is an example of how to define and call a setHue with C strings instead of String:This just prints the C strings to Serial, but I hope you can see how they could also be printed to the client.
Here is an example of how to define and call a getHue that uses C strings instead of String:Just copy and paste the displayed JSON into the Serial Monitor ""Send"" field.  The debug prints will display what gets parsed.Here's my changes, merged into your second sketch.A few notes:WiFi shield not present
  You're connected to the networkSSID:
  IP Address: 0.0.0.0
  connected to server
  PUT /api/myhue/lights/1/state HTTP/1.1
  Connection: keep-alive
  Host: 192.168.0.50
  Content-Length: 65
  Content-Type: text/plain;charset=UTF-8

  {""on"": true,""hue"": 50100,""sat"":255,""bri"":255,""transitiontime"":22}
  connected to server
  PUT /api/myhue/lights/2/state HTTP/1.1
  Connection: keep-alive
  Host: 192.168.0.50
  Content-Length: 65
  Content-Type: text/plain;charset=UTF-8

  {""on"": true,""hue"": 65280,""sat"":255,""bri"":255,""transitiontime"":24}"
21592,"Ordinarily, posters are expected to say what they've tried so far, and to show the code they've written.  However, with a problem as difficult as this one, it seems reasonable to illustrate a complete program.Note, this program assumes that one side of each button goes to Ground and the other side goes to a digital pin with its input pullup turned on.  (If you connect one side to +5V instead of to ground, you will need additional circuitry to sense button presses.)  The digital pins that are used are selected by changing the values swA, swB, and so forth, in the third line of the program.Edit: Note that triggering messages on button-release instead of button-press would be relatively easy if buttons didn't bounce.Before explaining that, let's look at why the above code should work.  Assume the cycle (buttons A and later E getting pressed, and possibly some of B, C, D too) lasts at least a couple of seconds.  Assume we have ordinary button hardware, and that contacts can bounce for several milliseconds at each make or break.  When you press a button the Arduino sees a lot of pin-turning-on events, eventually settling at pin-is-on.  When you release a button the Arduino sees a lot of pin-turning-off events, eventually settling at pin-is-off.  And finally, assume each button press is long enough that at least one digitalRead() happens while contacts are closed. Under those assumptions, the very first time in each cycle that we see a given button closed, we know that button has just been pressed.  Also, we can plausibly expect closure of button A to register before closures of other buttons, and can expect the closure of E to register after that of other buttons.  So we can ignore bounce.On the other hand, with on-release triggering we need to distinguish whether a pin-turning-off event is due to contact bounce of a button just pressed, or is actually part of a button-release bounce sequence.Here's a method worth considering if you want to implement trigger-on-release:
 • First, add a delay(1) call, in loop().  This will make the code timing less processor-dependent, so it can run on a 48- or 72-MHz system as well as on 16-MHz Unos.
• Each time you detect that button b is on, execute buttonBusy[b] = 40 to start (or restart) a 40-ms timeout.  That is, while a button is held down, we keep setting its timeout to 40.  (40 ms may be overly conservative.  20 ms should work ok with most switches, and 10 is ok with a lot of them.)
• When you detect that button b is off,
 • if buttonBusy[b] is zero, do nothing.
 • if buttonBusy[b] > 0, then decrement buttonBusy[b] and test if it now is equal to 1.  When it's equal to 1, regard b as released, so do its action."
21915,"Your main issue (the cause of your symptoms) is the fact that you have no size for your _candleStatus array.  Without specifying a size you end up with no memory allocated to the array, and hence no valid content.In your class definition the line:should be modified to:and NUM_LEDS should be defined in the header, not in the CPP file. (By specifying it in the header file, since the header file is included in the CPP file, the definition ends up in both files).Aside from that this line doesn't do what you think it does:You are copying the content of an anonymous bounce object created just for the occasion into a pre-existing Bounce object.  You don't want that line to exist since the Bounce object has already been instantiated by the construction of your CandleRack object.However there is something you need to be aware of known as the Static Initialization Order Fiasco which can bite you on the rear end if you are not aware of it.  This is basically when you use objects in other objects and those objects haven't yet been properly created since you cannot predict the order in which objects are initialized. This may or may not be an issue in your system - it all depends on how the other classes you use behave.One way around the issue, if you find it does become a problem (or if you just want to avoid the problem altogether) is to use pointers and what is known as Construct On First Use.  This is where you don't instantiate any objects in your constructor or the class definition - instead you just have pointers to them and use the new keyword to construct the object from within a member function (such as begin()).For this you change your class definition object entries to be pointers, such as:(Note that not all versions of the compiler will support that assignment in the class definition. It's a modern addition to C++ and depending on your version of the Arduino software may or may not work. If it doesn't you can move the assignment into the constructor by removing the = NULL from the definition and adding _debouncePushButton = NULL; into the constructor.)Then construct a new object in the begin() function (if it hasn't already been created):Now you have to access the _debouncePushButton as a pointer to an object not an object, so change all your accesses to use the pointer dereference operator ->:In case the class should ever go out of scope or be used in a dynamic way you really should create a destructor to delete any objects that have been created:Note that you should only ever try and delete objects that have actually been created - hence the test to see if it's not null.Excessive use of new and delete though is discouraged, so it is best to use objects in a static context if possible. Too much new and delete or malloc and free can cause heap fragmentation which can lead to you running out of memory and all the associated stability problems that come with it.Of course, all this is optional and chances are it won't be needed if the other classes behave well."
22175,"Use the F() macro for all double-quoted strings you print.  Change lines like this:...to this:This will save about 100 bytes of RAM.And as BrettAM suggested, put that table into PROGMEM:This requires changing how you access the array, from this:...to this:Note the cast, the function call and the ampersand wrapped around the desired array element.  You must replace all uses of the array with this sequence.  You can also read it once into a local int and then use it normally:This saves almost 1000 bytes of RAM!  The reported binary sketch size goes up by the same amount[1].  I had to pull the table out from inside getTempFloat, to the file scope.  Here's the complete sketch with those mods:Note the technique for declaring the LUT_Therm array, using the empty [] brackets (line 135).That's followed by the const int array size (line 182) that is ""calculated"" from the array declaration: (Total array size) / (size of one array element).  If you ever change the lookup table, you don't have to count the elements by hand.  Let the compiler do it for you!  :)
As you can see, the 862 bytes for this table move from the data section to the text section.  The uploaded HEX files are identical at 93,737 bytes."
22357,"Why does it have to be in Intel Hex format? You could write out the EEPROM to the serial port one byte to a line, or something. Something like this:I'm not personally aware of a library that happens to write out/read in, Intel Hex format from/to the EEPROM.I have code that uploads and downloads files to the Arduino. Inside that is code to read/write Intel hex format. However it isn't a library.Inside File_Utils.ino are some comments that show the format:In that file is code to write Intel Hex format (reading from Flash, not EEPROM):That should give you some tips about how to write out the file. Look in my code to see the reading code as well. However as I said, you don't necessarily have to use that format if you just want to manipulate the data yourself."
22408,Try using the following code you need to use String and concatenate that
22739,"As noted in Paul's comment, you could use NeoPixels instead of ordinary LEDs for the display.  Each NeoPixel contains RGB LEDs and a microcontroller that accepts a serial stream of bits in, cleans up the waveform, and passes what it doesn't need on through, to the next NeoPixel.  This would reduce the necessary number of pins by 8, since a string of NeoPixels uses one signal pin, independent of the number of NeoPixels in the string.For the touch-sensitive (capacitive) buttons, rather than two wires per button, you can use one sense wire per button, and one drive wire per set of buttons, thus 10 pins to sense nine buttons, rather than the 18 pins mentioned in the question.  A sketch is shown below that samples nine capacitive buttons about 1300 times per second.  Here is some sample output from the sketch:Each entry like “level 278” shows the value of a running average of counts for a button; since the program is using 270 as a threshhold value for a button being on, it's reasonable for the numbers to be slightly above 270.  (Note, if the call to secondlyReport() were uncommented, one would see that the running averages go on up into the 300 to 500 count range when a button is pressed.)  The strings of o's and x's show which buttons are on and which are off.  The numbers after nr= are the number of button readings taken so far.The program implements smoothing (via a running average with exponential decay), debounce (via “holdoff” counts, as explained in detail in a previous answer), and hysteresis (going from off to on at a high count (270) and from on to off at a lower count (170)).The program may need tuning to work with a given set of capacitive buttons.  The tuning variables used here (such as ButtonIsOn = 270, ButtonIsOff = 170, usSettle=60, usPreWait=5, and nsamp = 40) work ok with my nine-button setup where each capacitive button is attached to an input pin (like 4,5,...12) and to a 619K resistor (a size I have a number of).  The other end of each of those resistors attaches to Uno pin 13.  By changing ButtonIsOn and ButtonIsOff, one should be able to accomodate resistor sizes from a megohm on up to perhaps 4 or 5 megohms.Note, to install Streaming.h (which doesn't increase code size) unzip Streaming5.zip from arduiniana.org in your sketchbook/libraries directory."
23279,"For one thing, you are using the variable state without defining it. Moreover, you have not declared the functions CheckEntrySensor() and throwRelayAndCheckStatus() . When you define a function without first declaring it, the arduino preprocessor builds its own declarations, but often does so in a defective way. This is one of the idiosyncracies of the arduino environment versus a plain C++ compiler.The following compiles:Or, if you want to avoid the use of typedef, you can use the following:"
23742,"Like the datasheet says, its best if you implement writing in software and use the hardware SPI for reading. The steps for writing to the registers are as follows:In Arduino-speak:For reading, you use the hardware SPI like this:The connections are:Each call of SPI.transfer() yields 8 serial clocks i.e. a clock for each bit, so 32 serial clocks is merely 4 SPI.transfer() calls. Your code is actually producing 32 x 8 = 256 serial clocks. I suggest you read up on SPI.I didn't include some of the delays in the datasheet because digitalWrite() on an Uno takes about 5us which is more than enough for this case. Of course, the code is untested so...I've done most of your work already, almost feels like I should be getting paid or something..."
24751,"Since microcontrollers typically only have one ""core"" or ""thread"" they can only do ""one thing at a time"".A microcontroller will step through your code and do everything in order (if you don't call interrupts).Basically, when you put in a for-loop (or any other type of loop) or a delay, it will only continue with the rest of your code when that is done.To solve this, and ""do two things at a time"" (or actually rapidly switch between things) you'll need either interrupts or non-blocking code (or both).InterruptsI see you're doing some direct port manipulation, which is really nice. You're writing bytes directly to the control registers of the microcontroller. You can leverage on that, to set up a timer (check the ATMega328P datasheet). You may make this timer give an interrupt each 100ms, and execute a ""frame"" of your animation at that point. And the next frame at the next interrupt. So that the time between each frames can be used for other code.Non-blocking codeArduino has built-in millis(); which is basically an interrupt that fires every millisecond to keep track of the passed milliseconds. So you can use this instead of fiddling around with the timers (which may very well cause some of the Arduino's functions to fail (like millis() or the servo library).To write non-blocking code, you'll not use delays, since they effectively throw away ""processor time"" by doing ""nothing-instructions"" all the time.But if we take out the delays, the for-loops will run too fast. And a for-loop also doesn't really work without the delay. Because even if you use millis and wait for half a second, you can't do anything in between.So we'll have to break up your code (specifically the animations) in chunks of code that can be executed withouth a delay. With only the need to delay in between these chunks.FramesLet's split up your animations in ""frames"". One of your animations same() works by PORTH&PORTB = A for 100msec and low for 100 msec.So based on the frame of the animation, the port will go high or low.Now we look at the complete code, we have to change the motor every 500ms and have to change the animation frame every 100ms. And check a button.We could put these in an interrupt that fires every 100ms, which would get reliable timing and minimum software overhead.
Or use the millis(); (checked against the previous milis) to check if the last update was 100ms ago.My go at the code is below, but you should be able to figure it out yourself.The buttonChecking the button every round isn't really needed. You can use an interrupt on that pin, so that the code to check it's state and go to the next frame only happens when the button is actually pressed. (interrupt triggered on rising edge?)."
25180,"I suggest you consider as “top value of the falling edge” the maximum of
the values you have read during a specified time window before the edge
is detected. This means you have to compute the maximum at the time you
detect the edge. If you instead continuously compute a running maximum,
then you are going to get a global maximum. Amended source:Notice the line values[i] = 0;. It is intended to avoid the reading of
one falling edge being seen on the next one."
25272,"This is wrong on a number of levels. First in the class declaration:That gives you a pointer to an array of zero length.This gives you an array of char, of zero length. This is not useful.That does a new into a new variable content - not the class variable. Then you assign (overwrite) the passed pointer into content (discarding the memory you just allocated). That pointer is then discarded when the constructor ends. Perhaps using strcpy would be better. I made up a small example based on your code which prints the correct result:Can you explain to me why it was making a new variable content and not using the class variable?Small example:In this example there are two variables named content. The one in the function ""shadows"" the global one. However the code below only has one variable:In the destructor, when you delete the pointer to the array, does this free up the memory allocated to the array? It's now free to be assigned again by something else? Or does it sit there still initialized as that array, not being able to be used again?You aren't deleting the pointer. You are deleting the memory it points to. The pointer is now pointing to freed memory, so using it as a pointer at this stage would be wrong. You can do another new to make it point to something else.they delete pointer and then delete[] pointer.You misinterpreted that. You either delete pointer or delete [] pointer depending on whether pointer is an array or not. I reworked content to not be an array, thus deleting it without the brackets is correct however as it is allocated using new [] it must be deleted with delete [].on the link posted above they say to use delete this way: delete pointer if it was a single element allocated with new or delete [] pointer to release memory allocation for arrays of elements allocated with new and a size in []'s. So in my case I want to use delete [] content_? No, you don't want to be setting up an array in the first place. Take a look at this small example:That prints:The variable bar is a zero-length array. Thus the entire struct foo is also zero length. It isn't even a pointer (that would be two bytes on this platform).It is wrong to use an array of char like that, when you want to dynamically allocate memory. Look at this:That allocates 4 bytes of memory for foo. You can't later on make it longer by doing a new.What you want is:Now you have allocated a pointer and can do a new, like this:And then delete it:You use the brackets on the delete, as you used them with the new.If you allocated one char you wouldn't use brackets. eg."
25280,"As has been mentioned before, in comments and in jwpat7's answer, your
main problem here is the time taken to compute the sines. I already
provided a link to a faster fixed-point implementation of
sin() but, since you have an Mega2560 with loads of RAM, I
would go to the simpler look-up table method. I would not even bother
optimizing the size of the table.For controlling the timing, you can use the canonical method described
in the Blink Without Delay Arduino tutorial, with one twist: times
should be measures with micros() instead of millis(). Here is a
first version of the program:A few things worth noting:This should give you, in theory, a frequency of 50.08 Hz, i.e.
0.16% too fast. The discrepancy is due to SAMPLE_TIME, which should be
39.0625 µs, being rounded to 39 µs. You could fix this by
counting time with a higher resolution, but given the poor accuracy of
the ceramic resonator clocking the Arduino, this is probably not worth
the trouble.A potentially worse problem is the large jitter you have with this
approach, on the order of 10 µs. This is due both to the time taken
to run through the loop and the occasional timer interrupt taking some
extra time. You can get rid of this jitter by using a timer interrupt
instead of micros(). Here is a second version of the program that uses
this approach:Again, a few notes:"
25615,"I figure out the issue , I just add a small delay in ISR and my code is running fine now. I don't know reason behind it but anyway my code is running now. Here is my new code:-"
25727,"The problem with your program is that it does not loop fast enough. Each
call to delayMicroseconds() should take roughly the requested time to
execute, but the CPU also needs time to execute the rest of your code,
including the time needed to return from loop() and call it again.
The period of the signal ends up being considerably longer than the
desired 10 µs.The simplest software-only approach would be to get rid of the delay
using the technique described in the Blink Without Delay Arduino
tutorial. With one twist: instead ofyou would useThis way the small timing errors do not add up: you get, on average
the correct period. Oh, and obviously, you track time in microseconds,
not milliseconds:This may somehow work if you have a fast enough Arduino, maybe a Due or
a Zero. If you have an AVR-based board (like the Uno and actually most
Arduinos), you will not get anything faster than ≈ 50 kHz with
this. This is because digitalWrite() is sooo slooow, it cannot cope
with your 100 kHz. You can improve things by using direct port
access[] instead of digitalWrite():Now you have roughly the requested frequency, but with some terrible
jitter: testing on my Uno I could see each level being held for
slightly less than 5 µs. Then, from time to time, one level is
held for ≈ 9 µs. Things could still be made faster by wrapping
the if inside an infinite loop, instead of relying on the Arduino core
to repeatedly call loop():And now the signal looks still worse: with the program running faster,
levels are held most of the time for only 3.5 µs, and then one out
of every ≈ 4 levels is held for about 9 µs. The average
frequency is probably right, but the jitter is absolutely awful, which
is likely due to the 4 µs resolution of micros() noted by user
Talk2.The conclusion from these tests is: your only hope to get a somewhat
clean signal at this frequency is to generate it in hardware, not in
software. Choose one of the timers and have it generate the signal you
want. I would avoid timer 0, as it is needed by the Arduino timing
functions (delay(), millis()...). Here is how it can be done with
timer 2:And now you have a perfectly clean 10 kHz square wave, while your
program is free to do other stuff at the same time. Notice that the
output is now on pin 3: the pin choice is limited when using the
hardware-based approach. Notice also that you loose the PWM capability
on pin 11, since it depends on timer 2."
25785,"Thank you all for helping me out.  This is what I ended up using (ESP8266 1.0 12E with Arduino IDE):It's probably longer than it has to be but I pulled stuff from other sketches I've worked on and prioritize function over form.  This writes a ""-1"" to the first 1000 bytes and then prints the first 128 bytes.  Since I am only concerned about the first 50 bytes or so this was sufficient for my needs."
26439,"Arduino is universal platform, lot of wrappers to hide real hardware and it is slow. For example digital write is about 100times slower than direct access to hardware.For example for AVR Mega328p based Arduino analogRead looks like (without macros):There are no extra function calls, no much extra actions and ADC is enabled in the startup code (as most of hw).On the other side there is ARM based arduino with SAM3X8E:As you can see there is little bit more actions to do single measure using HAL (Hardware Abstraction Level) so you have another level of abstraction here.If you want faster actions, you can access hw directly, or use HAL and skip unnecessary steps. It would be much faster then."
26492,"I've converted first four bytes to string, and then to int :"
26952,I believe that CTS would be fairly easy to implement:I'm not sure about RTS.
28137,"The Arduino 1.7.x series from Arduino.org uses the old build system that is severely broken when you try and do anything more complex than simple types.It adds prototypes to your functions to the top of the program so you don't have to get the order right, but it puts them in completely the wrong place.  The result is a C++ file that looks like this:As you can see the prototype involving Dir has been placed before the definition of Dir, and so it fails miserably.There are some hacks you can do to force it to place the prototypes after your definition, but I can't recall what they are off hand.The simple answer is to ditch Arduino 1.7.10 and switch to Arduino 1.6.10 from Arduino.cc instead. This uses the Arduino Builder system which does things much better, including placing the prototypes in the right place.Despite the numbering 1.7.10 is not a newer version than 1.6.10 - it is an older version renumbered. It's all part of the schism between the two halves of Arduino.Even better is to ditch the awful Arduino IDE entirely and use one of the many far better IDEs that exist."
28138,"You have to define a new enum type:without typedef your Dir is just static enum variable, it can't be used to define other vars."
28613,"Personally I wouldn't be putting too much effort into optimizing away your timers. millis() is pretty fast - the work needed to calculate the result is done in the background anyway (by interrupts). I tried some test code:Results:You can see that the digitalWrite() (which you weren't worried about) takes 5.2 µs, whereas calling millis() (which you were worried about) takes 1.88 µs.Are millis() and micros() timing patterns using more operations (setting value to variable, computing the difference between 2 values and than comparing it to a period you have set) instead of decrementing and comparing to zero with my pattern?Yes, just adding one to a variable and then comparing will be faster. Whether it is worth the effort is debatable."
29060,Another way is to declare a function. This method will give you more chance of using it in various ways.
29137,"KennetRunner already explained what is wrong with your code. Here I will
try to give advice on the proper way to implement the automatic door.First thing is to get rid of delay(). While your program is inside a
call to delay(), it can do nothing but wait until the delay is over.
This is acceptable if the program has only one single task to perform,
like blinking an LED. As soon as you have two tasks, delay() is a
nuisance because it blocks all the tasks.Case in hand: after keeping the door open for one minute, your program
would close it, irrespective of whether there is someone in the way. It
could not see the person come because it was busy delaying the closing
of the door.The standard way to get rid of delay() is to never wait inside
loop(). Instead, if there is something to do right now, do it; if
not, just don't do it, but do not wait. Pseudo-code:You would use the millis() function to know when the time has
come to do some task, as explained in the Blink Without Delay
Arduino tutorial. This is really the second tutorial every Arduino user
should read, right after learning how to blink an LED.Next, you have to learn how to implement a finite state machine. I
recommend the Finite State Machine tutorial by Majenko,
a regular contributor to this site.Your problem can be very naturally mapped into a machine with four
states: CLOSED, OPENING, OPEN and CLOSING. You then write the rules
about what to do in each state, and when to transition to another state.
For example:A few things to note here:And here is my proposed implementation. Warning: not tested. As
usual with FSMs, it is based on a big switch/case statement going
through all the possible states. However, to avoid repeating rules, I
factored the “if there is someone, start OPENING” rule out of the
switch. I also folded “if there is someone, reset the timer” into the
same rule."
29140,"Ok, thanks to the responses in this thread, I believe I have the solved the problem. There is a problem using sizeof(char*) when passing through arrays, so I used strlen(char*) instead. This code properly stores the messages of various sizes coming off of Serial3 and correctly compares them to the expected responses. The F() macro in Arduino is very useful in keeping the buffer free and, in general, I use it to print constants during debugging."
29644,"Generating a linear frequency ramp with accurate timings is not an easy
task. I am providing here only a partial answer, where I first go
through the math of the problem, then give some ideas for the
implementation.We are dealing with a frequency-modulated signal, with the frequency
ramping linearly from f = 0 at t = 0 up to a
maximum f = fM at
t = tM. Specifically, we have
fM = 48 kHz and
tM = 10 s.
Then, the instantaneous frequency isf(t) = a twhere a = fM/tM = 4.8
kHz/s is the “acceleration” of the pulsed signal.Let's define the “integrated frequency” asn(t) = ∫ f(t) dt = a t²/2This quantity can be interpreted as the number of cycles completed at
time t, except that it is a continuous variable. The first cycle
starts when n = 0 and ends when n = 1, the next
cycle starts when n = 1 and ends when n = 2, and
so on. The output signal would be high when the fractional part of n
is between 0.25 and 0.75 (or maybe between 0 and 0.5, depending on your
choice of initial phase).From here, we can calculate at what time each cycle should start:t(n) = √(2 n/a)and, by successive differences, the length of each cycle:In the table above, all times are in microseconds. The lines are:The columns are staggered because each cycles spans the duration between
two successive values of t, and duration differences are computed
between successive cycles. The approximated formula is based on the
Taylor expansion:T(n+1) − T(n) ≈ dT/dn + 1/2 d²T/dn² = −aT³(1 − 3/2 aT²)where T = 1/f, the instantaneous period, approximates the
length of one cycle. The approximation is not good for the very first
cycles, but it converges pretty fast to the correct value.I did not write an implementation, so I am giving here only some ideas
on how to do it.I would use Timer 1 of the Arduino Uno, in one of the modes that allows
frequency-modulation, i.e. a PWM mode where the counter TOP is set by a
register (mode 8, 9, 10, 11, 14 or 15). I would set the prescaler to 8
in order to allow for the maximum required period length. The period
resolution would then be:It could be noted that single-cycle resolution is possible with the
prescaler set to 1, but the first 5 cycles are too long for this
setting. Maybe the prescaler could be changed after the fifth cycle, but
it would be tricky to do so without any glitch.The timer overflow interrupt would fire at the end of each cycle, and
it's ISR (namely TIMER1_OVF_vect) would be responsible for updating
the timer period in order to make the next cycle shorter than the one
just elapsed. It would do something likeThe period should be computed with 32-bit arithmetic, because the
changes get tiny by the end of the ramp. Only the 16 most
significant bits of the computed period would actually be written to the
timer register. The delta() function should be inlined and fast. I may
try the approximation from the previous section implemented in
fixed-point. Or maybe just a table lookup using only the most
significant bits of the period as an index, with the table in PROGMEM.For details on how to actually program the timer, see
the datasheet of the ATmega328P, section 16.Update: The following algorithm seems to work well. At least in
simulation, I did not put it inside an ISR. It assumes fast PWM, i.e. a
0.5 µs timer resolution. It remembers the current value of delta
and divides it by 2 each time the period falls below some threshold. The
computed f(t) is almost as smooth as you can expect given the
limited resolution of the timer."
30335,It is pretty easy to send data with the help of NodeJS. Here i attach the code.
30354,"There is code inside the standard library that loops waiting for certain interrupts to complete transmission. If the transmission fails in the middle it can hang.See my page about I2C. On that page I mention that there is an alternative library. That is written a bit differently so it times out if the transmission doesn't complete in time. An alternative download to the library is here - I2C_Rev5.zip - 6.6 KB.As hinted by KIIV in a comment, maybe you don't have pull-up resistors. Make sure that you have pull-up resistors from both SDA and SCL to the +5V line. A reasonable value would be 4.7k (each).would like a few more examples to show a similar setup to replace my current requestFromBorrowed from my page about I2C I am using the same slave code as on that page.The above code responds to requests to send one of:The master from my page was this:The beginTransmission() ... write() ... endTransmission() have been replaced by simply write() and the requestFrom() by read() like this:"
30709,"It's likely the problems are in your code somewhere; but not enough information is available to say for sure.   Your first step toward debugging the problem probably should be taking any ESP-12e issues out of the mix.  At the beginning of getNtpTime() temporarily add something like return 1477897101UL + millis()/1000; to get a sync-time that advances at the correct rate and is repeatable for testing.  If the display suddenly begins updating smoothly, look for problems in your time code, else in the display code.The technique of duplicating a whole bunch of individualPixels[116]=1; lines (with different pixel numbers) is crude, tedious, verbose, error-prone, inflexible, etc.  You might instead create some arrays and use a loop to set pixel data.  For example:You could also create an array of addresses of number-data arrays, to get rid of the crude, tedious (etc.) switch/case statements in print_numbers().  For example:If your matrix is logically organized, all of the 1's in R0 are at constant offsets from the 1's in L0 (for example, 12 more), and similarly for other digits.  If that's the case, you could modify loadDigit() to take a second parameter, offset, which indicates where to place the digit in the matrix, ie, tells loadDigit() how much to add via a statement like individualPixels[offset+pixelList[j]] = 1;.  Then you could leave out the R0 ... R9 arrays (and digitsR[] as well) and use code like the following:A drawback to using const byte arrays like L0 ... L9 and R0 ... R9 is that when your program starts they get copied from PROGMEM into RAM for access.  It would make sense to declare them in PROGMEM, and use them directly from PROGMEM by appropriate changes.  [Edit: See example program, below]Note, a string of 224 WS2812B units takes about 6.7 ms to update:  224 units x 24 bits x 1.25 μs/bit.  Each time you update your matrix of lights, the millis() counter, timer0_millis, will lose 5 or 6 ms because pixels.show() runs with interrupts turned off.  To compensate, you could add 5 to timer0_millis after each update.  To make the loss always be 5 ms instead of sometimes 5 and sometimes 6, add the following code just before pixels.show():  unsigned long now=millis(); while (now==millis());, which will stall until the end of the current millisecond.  To see how to change timer0_millis, see the  “Better Alternative” section of my answer to “How to keep accurate millis() while using ADC_sleep mode?”.I'd remove the pixels.show() call from turnOff() because you will (I think) always be calling pixels.show() shortly after that, after loading number images, to turn on a bunch of other pixels.  That is, clear the array, fill the necessary 1's, then show, without a show between clearing and filling.Following is an example program that illustrates storing a constant array of bytes in PROGMEM, and accessing its entries via pgm_read_byte() calls."
31109,I wrote a simple sketch to read a KY-040 encoder with an Arduino UNO (or nano) board and to display the output in the Arduino IDE serial plotter (CTRL + SHIFT + L).Here is the pinout:Here is a screenshot of the output in the serial plotter:Here is the picture of a project I am doing now (you need only the Arduino and the encoder for the sketch to work):And here is the code :
31263,"You need to keep track of multiple WiFiClients - declare an array of them, for example, and each time server.available() gives you a new one, store it in the array.Then you need to make sure your code doesn't stick waiting for data from each item.  You could service each WifiClient in turn: if it has data waiting (client[i].available() is true), read the data (client[i].read()) and store it. When you get a \r from a client, you know you have a whole line, and you can process it.Here's a nearly-complete (but untested) example so you can see what I'm talking about.  Naturally it's not the only way to do it."
31422,You can use it using bubble sort algorithm (which is most simple but inefficient)    
31506,"||-----PWM Register Explanation-----||It will be easier to explain with an example.
Here is a sample of Timer setup on ATMega2560 (assuming that is the one you use due to the tag ""Arduino-mega"") based on  datasheet section 20 : 8-bit Timer/Counter2 with PWM and Asynchronous :Operation:COM2A1, COM2A0 set the Timer2A on non-inverting mode, and COM2B1, COM2B0 set the Timer2B on inverting mode. OCR2A and OCR2B is the duty cycle value of PWM. Because timer2 is 8 bit, so the value is ranging from 0-255. Its also the answer to your questionHow i can program the MCU to generate PWM signals ?PWM Signal frequency is defined by its duty cycle :  Duty cycle of Timer2x = (OCR2x/255)*100%for example :Timer2A will work on 39.2% duty cycle and OCR2B will also work on 39.2% duty cycle. What? Because Timer2B works on inverted mode (100%-60.8%) ==> 39.2%     ||-----PWM topic closed here-------||I've seen several people losing several hair while trying to control analog servo without manually  (well, some even move to Arduino only because of its servo libs).
You can check this Servo Library which is (maybe) the most common library used to control servo using Arduino (which also mentioned in @st2000 answer).
But, it will be better if you also post a detail about your ""motorservo"". At first I though it was a motor DC (by its PWM - Dir configuration). ||-----Additional-----------------------||
In your while(1), there are several if that can be optimalized by using simple if-else if-.. statement. So this one would be better (also minimalized ""bug"" chance) :--EDIT--
After reading several page of the PDF, I assume you have to make your own library (not Arduino). Perhaps this will give you something : "
31790,"Since you're using a Grove Display, I believe it will be using I2C.For better debugging, try using the actual I2C pins on your Pro mini, which are A4 and A5.I2C: A4 (SDA) and A5 (SCL). Support I2C (TWI) communication using the
  Wire library.
  https://www.arduino.cc/en/Main/ArduinoBoardProMiniI2C may need pull-up resistors on your data lines.(https://en.wikipedia.org/wiki/I%C2%B2C)It can also be nice to use ""verified to be working"" code, like example code from the manufacturer.You will need to adapt the pin numbers.But after these steps it should work just fine.Source: http://wiki.seeed.cc/Grove-4-Digit_Display/"
31796,You can use 2d Array for this and send all data at once in 5 Sec. It Read all 3 Axis data each 100Ms and make a matrix of 50 X 3 = 150 Values and then Print it in Serial Port. You can use this in your code to send data to server in desirable format. 
31798,"All,My Arduino is not reading interrupts across the interrupt pin:I am getting a high of 1.456V and a low 1.07V through the interrupt pin 2... But the pulses counter still remain 0....Any idea why?"
32272,"There are a few issues in your code.First, you have if (ARD_ESP.available() > 0) to check if the data arrived but what is going to happen if the data still haven't arrived? Instead of waiting for the data to arrive the program will continue through the loop and it will send a request every 10 seconds even if there is no data.Second, you initialized previousMillis to zero. You should initialize it to millis() so you can count from the present moment in time.Third, in the loop where you are reading the input:when something arrives, you are reading it twice so the second read indata = ARD_ESP.read(); gets -1 (no data available) when there is less than two chars in the buffer. Even if you sent more than one character there is no time for new data to arrive in the buffer and even if there is more than one character you miss every second one because of the 1st read.Fourth, you cannot send the number greater than 255 (one byte) with mySerial.write(randnum); because write() sends only one byte. And even if you could in a such way send more than one byte, you cannot display these bytes as a string representing the number. You could send all bytes using:but, as I said, these bytes are not a string representing the number contained in a variable. For example, if randnum = 1000, that is 0xe8, 0x03 and ""1000"" is 0x31, 0x30, 0x30, 0x30. 0x31 is ASCII for 1 and 0x30 is ASCII for 0.So, you have a lot of things to improve.EDIT:
Try this, I don't have a time to check the code but it should work:EDIT:
Unfortunately I don't have Arduino (I've even never had one :-)) so you'll have to try the code and report back if it works. I have a few ESP8266s but they are all logging some data at the moment.Now for the ESP8266 code:You have at least two choices when deciding how to read the data. The first choice would be 'your way', something like:The second way could be:There is a significant difference between these two ways of reading the incoming data. When reading the data as in the first example then in every pass through the loop you either read or don't read exactly one byte. Since there is a possibility 10 seconds will pass before we received some data, there has to be a check if the data in the meantime arrived or not. If there was some data then every 10 seconds everything received until that moment would be sent - even if that was in the middle of the string. You probably don't want to send just one part of the string to the server.In the second example there is a while loop waiting for the data from serial port. When the data arrives there is another while loop to read all bytes one by one. Without delay the loop would end before receiving the second and all subsequent bytes so the received string would be cut in 1-character chunks. Now, when the whole string is received, we don't have to check if something arrived because we already know it did.I've left 10 seconds delay between sending the GET requests but you have to decide if that is what you really want. You have to be aware that if the next data arrive in between sending the GET requests, the next string (number) will be concatenated with the previous one - and you do not want that to happen because such data wouldn't be meaningful. To avoid concatenation of the new with the old data, you have to remove if which is checking millis() to send the received data immediately.Note:
As I said, I can't test the code so I cannot guarantee it is 100% error free but you can check if it works so I can correct the mistakes if there are any."
32358,"Even without the real code, I think the problem is with the function First::Second().You need to understand what happens in C++ when values are passed as parameters.  The are passed by value by default, this means a COPY of the value is passed into the function, you can modify the parameter all you like but when you return those changes are lost.There are two exceptions to this, the first is pointers.  When you pass in a pointer you can modify what is pointed to but you still can't modify the pointer, because that is a copy.  If you want to modify the pointer then you need a pointer to a pointer int** ptr_to_ptr.The other exception is a reference.  In this case the function can modify the parent function's variable.  This is more efficient in terms of memory.So you have:So why it is First::Second() causing the problem?  Well the same rules apply to return values as to parameters and you are returning a copy of the value widget so you then modify that copy and then dispose of it.  So this is what you need to fix the problem.EDIT : Its not clear in the preceding text but you don't need getSecond() to return a reference if you are not altering the value of widget so getDouble() will return the expected value because it is working form a copy of the original and not storing any changes.  However update() will not work as expected because the result of getSecond() goes out of scope (gets disposed of) once the call is complete.  The changes its made are not save to the original because it is working on a copy."
32575,"I have a page about rotary encoders - in that I show how you can detect encoder changes (and direction) using one interrupt pin and another pin, like this:In the main loop you just need to test the boolean fired to see if the encoder changed, and up to see if it went up (otherwise it went down).I receive random of these values ...I think with your code you need to detect a change - that is, if the encoder pin is now HIGH but was previously LOW.The problem is I am working on four encoders ...I have reworked my code to use pin-change interrupts instead of external interrupts.The code is general enough to handle 1 to x encoders (eg. 10 encoders) - within reason! You need to have 2 pins spare per encoder (the third pin goes to ground). One of the pins needs to be capable of pin-change interrupts (on the Uno that is all of them).The code sets up to detect an interrupt on the ""A"" side of the encoder and tests the value on the ""B"" side to see if it was turned clockwise or counter-clockwise.I am getting results like this (with 2 encoders connected):The other two are showing as ""1"" (that is, not turned yet)."
33039,"You are assuming that Serial.readString() will magically know how long a string you meant to send, and wait until it's all there.  It doesn't guarantee that.If your PC uses Linux or Mac, you can use Serial.readStringUntil('\n'), which will read until a line end, and send on<ENTER> as your command.If you use Windows, the line endings are \r\n so it's a bit more awkward.  Build up your string piece by piece, perhapsBrief description of how it works:The string SerialInput starts empty.  We do the following repeatedly:"
33317,I took your code and did a bit of an edit. You had some useless variables and you where redefining DUMPTIME and LOT in a wierd way. I also define some of your constants as #define's because thats the way you should always do it.A different version with a BUTflag variable to keep track of the button press and release. I have not dealt with the DUMPTIME variable but hopefully this will give you an idea of how to use flags so the logic doesn't fail.
33584,"The following code was from a rejected suggested edit, by an anonymous user, to the original post. See also Rejected edit results in loss of constructive code modification.I have reproduced the code here - it may be of some use to someone:"
33809,"Perhaps the easiest way to take in at least 10 readings before beginning to output results is to set a counter to 10 and count it down, as illustrated in following code.As hinted at in a comment to the question, declaring all your variables volatile isn't necessary.  You should declare variables that are shared between threads, or between an ISR and loop(), volatile, but to declare other variables as volatile is in general a coding-style error that will confuse whoever maintains the code.  Spurious volatile declarations also may increase code size slightly, as it prevents one-time evaluation of expressions that are used exactly the same way multiple times, and it prevents code motion like moving constant expressions out of loops.The following code rewrites severak parts of your sketch.  It uses some pointer arithmetic to avoid the tedious assignments and shifting found in your code.  It removes several extraneous casts because many of the type promotions and conversions coerced by your casts happen automatically anyway.  This code has not been tested; if it has problems, please point them out and I'll edit accordingly."
33834,"The only issue in your code is due to the delay in the pin control. You can solve it this way:So you turn on the output, then after 20ms you turn it off.There are just a couple of things not clear for me. What is the last picture? What are the yellow and pink traces? Why is it not behaving correctly? What are the readings on the serial interface?And most important... What is the time scale? Is it really 10ms/div?"
34070,"Your problem is that you are basically saying ""while the pin is HIGH toggle the relay"" rather than ""When, and only when, the pin transitions from LOW to HIGH do I toggle the relay"".To do that you must remember what state the pin was in during the last iteration:"
34514,"If you have in your constructor this:then you are trying to assign something into the element at position [16][4]. Thats why it's telling you cannot convert '' to 'uint8_t {aka
  unsigned char}'Anyway - you don't even need that second dimension. You can use binary representation like  0b00001000 ...And if you'll think about previous line, you don't even need any array, you can do it with simple counter value and getting its bits.However if you want to rely on this array, the constructor should look like:(maybe one more {} enclosure, I'm not sure right now exactly)EDIT: I'd go this way (if you need only one or two instances):"
35257,"You start out with a variable named Tare initialized to zero float Tare = 0.0; put in a conditional like if (millis() > 2000 & Tare == 0.0) Tare = voltage; and always report voltage - Tare. If you want to make it smarter, add a button for tare and maybe if you have a calibration weight, add a button for calibrating."
36005,"Read the analog input and store it, continuously. If the switch is off, also write the value to the ""freeze"" value:This doesn't take into account possible bouncing of the switch. That may or may not matter depending on the actual rate of sampling the analog input and what you intend to do with the frozen output, as the switch bouncing will be shorter than human perception but long enough (10s of msec, perhaps) for the MCU to notice and react to changes."
36078,"Edgar answers your first question about String and printing very nicely.  Majenko also has a nice description here of the pitfalls.Regarding your second question about GPS/efficiency/speed:NeoGPS has a FIFO of fixes, unlike other libraries.  This avoids ""sampling"" the GPS at some rate defined by millis().  The Arduino crystal is not as accurate as the atomic GPS clock, so your logging rate should be based off a fix becoming available, at exactly one per second.  Your sketch will ""drift"" against the GPS updates, losing a fix periodically (depending on the accuracty of the crystal).2.  Perhaps the single greatest improvement you could achieve is NOT to use SoftwareSerial.  It is very inefficient, because it disables interrupts for long periods of time.  At 9600, it disables interrupts for 1ms while each character from the GPS device is received.  The Arduino could have executed ~10000 instructions during that time, but instead it twiddles its thumbs while waiting exclusively for each bit of a byte to arrive... -_-Instead, you should use AltSoftSerial, as you have connected the GPS device to the required pins, 8 & 9.  If you were using two other pins, you could have used my NeoSWSerial.  Both of these libraries are much, much more efficient than SoftwareSerial.3.  If you want evenly-spaced MPU samples, put the device in the FIFO mode.  It will write the selected registers into a FIFO at a selected sampling time.  This also gives you a little flexibility in reading the sample: you just have to read it before the 1024-byte FIFO fills up.4.  You are using an old version of the SD library.  I strongly suggest that you use the latest SdFat library.  It has many improvements and bug fixes.5.  Some SD cards will occasionally take a longer time to write.  The 47ms write time is not unusual.  In fact, 100ms is fairly common.  As long as the MPU FIFO does not overflow during this time, you will not lose any MPU samples.If you find that an SD write occasionally causes the FIFO to overflow, you may have to modify the SDFat library to call a yield function while it's waiting for the write to complete.  This yield function can read from the FIFO during that time, saving the samples into an Arduino RAM area.6.  I would recommend that you close the logFile when some event occurs.  Perhaps a button press?  You can use the LED to indicate that logging is active or inactive.  You could also watch for inactivity for some period of time (no speed, MPU zero values).
Your original sketch used 24114 bytes of program space and 1690 bytes of RAM.
The NeoGPS version uses 21198 bytes of program space and 1400 bytes of RAM, a significant savings.Minor points:"
36134,"I think @Mazaryk was correct, HSV is the way to go for this.  RGB's 16+ million colors include brightness, and some of them just won't display on the strip, so I found a way to at least better fade thru:"
36480,"hello @kaisar Great you have not mentioned which flow sensor are you using. I am assuming that you are using flow sensor YF-S201 or YF-S401(Hall Effect).You have to do Little calculation for measuring water flow.
In order to measure the quantity of water being passed in particular time through the water flow sensor it was first passed through the water flow sensor which was taken as input interface in the flow. Formulas are applied in order to measure the number of rotations/pulses in a minute of rotation.Here I have determined flow rate by change in velocity of water. Velocity depends on the pressure that forces the through pipelines. As the pipe’s cross-sectional area is known and remains constant, the average velocity is an indication of the flow rate. The basis relationship for determining the liquid’s flow rate in such cases isQ=VxA, where Q is flow rate/total flow of water through the pipe, V is average velocity of the flow and A is the cross-sectional area of the pipeCalibration Factor = The hall-effect flow sensor outputs pulses per second per litre/minute of flow.(check your datasheet) here I have taken 4.5.Flow Rate(litres/minute) = ((1000.0 / Total time) x Pulse Count) / calibration FactorFlow Rate(MilliLitres/Second) = (Flow Rate / 60) x 1000There you have to calculate the total water flow in a given time by adding flow rate for each second.
There after you have check your set point value(400ml)..if condition satisfied you you can turn off your Solenoid valve.and the code is"
37340,"You don't need to revert to sending single bytes. Line oriented
protocols work well with both Arduino and Node.js. The only difficulty
is that you have to decide what line terminators you want to use, and
then consistently use them.I tend to use CR for the PC → Arduino stream and CRLF for Arduino
→ PC. Using different line terminators is kind of odd, but this
convention plays well with terminal emulators: the emulator usually
sends CR when you hit <Enter>, and expects CRLF in return. Also,
Arduino's Print::println() sends CRLF.Here is a simple test demonstrating this convention. Node.js side:Notice the different line terminators in readline() and write().The Arduino side:Here you may notice that Arduino has no equivalent of
parsers.readline(), so I had to implement it (comparing the incoming
character to '\r'). Note that explicit buffering of the incoming
message is a standard way of handling line-oriented protocols on
Arduino. Stream::readString() does not work well for this purpose, as
it waits for incoming bytes until it times out.
Stream::readStringUntil() may work better, but I prefer to avoid it
just because it returns a String, which relies on heap allocation."
37714,"There are some good answers here but I wanted to add a method which hasn't been mentioned yet, one very well suited to computing trigonometric functions on embedded systems, and that's the CORDIC technique
Wiki Entry Here It can compute trig functions using only shifts and adds and a small look-up table.Here's a crude example in C. In effect, it implements the C libraries' atan2() function using CORDIC (i.e. find an angle given two orthogonal components.) It uses floating point, but can be adapted for use with fixed-point arithmetic.But try the native Arduino trig functions first - they might be fast enough anyway."
37727,"First of all your question is so basic it means you didn't spend any time to look any example out there, not even after Majenko has clearly pointed out you can find the answer to your question in the many examples out there.Once that is clear here follow the code you are looking for, but using it as it is without knowing what you are doing is not going to help you. Not to mention not many will be willing to help somebody with the attitude you are demonstrating."
38542,"My original answer was probably over-kill....Just keep track of how many leds are lit:Then, on button press, increase the count:Then to turn the leds off with the other button press:------------------------- Original answerThere are a few ways to do it. One way would be to use a bitmask. I would write a function to turn the leds on/offThen, on button press, set the mask:Then to turn the leds off with the other button press:"
38754,"Thank you gilhad and Jot for your time, I really appreciate it. However, my best friend who happens to be an electric guru as far as I am concerned, proposed an ever more elegant solution to this multi-tasking problem. 
He proposed to use timer settings in the void setup, like this:So the portion in void setup:rotates the step motor WITHOUT any code in the void loop, void loop is only used to change the rotation direction of the motor by using the buttons that I incorporated (GO_PIN_L and GO_PIN_R) and to measure the acceleration with the accelerometer.I hope this helps to anyone that might have similar problems.
Kind regards,Luka"
39514,"First of all, that way of writing the displays is quite horrible to me ;) Better to use a matrix (and, please, no ints for small variables like pin numbers, and make them constant). This is the code fixed with these improvements:You can further improve it by not having seven variables but only an array to iterate over, but .. ok, let's keep this.Ok, now you want to do a ""slow movement"". In order to do this you can use a variable to track the current position, and let it move towards the target value once every XX ms. This is the approach used, for instance, in CNCs and 3d printers movements.The delayBetweenMovement constant makes a delay between the readings. With this method, if you quickly turn it to 9 and then to 0 you will not arrive to 9. For instance you put a 9, the display starts doing 0..1..2..3, then you switch to 0 and the count will not reach 9, but start going back to 0. Reaching 9 will require some more structures; if you need it ask and I'll make some modificationsEDIT: as requested, here is a version that can memoryze up to 20 states and reproduce them. If you need them just increase the FIFO size.Note: I haven't tested these programs. In the other two I was pretty confident I hadn't made any major bug, but this one is a bit more complicated. There can be some bugs left.."
3954,I fixed my problem by changing my sketch to this:And also by changing my webpage to this:I also include the zepto.min.js Javascript file.
3978,"There are two problems. 1) you are trying to have the Arduino's single UART talk to both the SIM900 and the PC. 2) disp needs to be an array of char's, as to compare for words phrases.Try the following. It implements a 2nd Soft serial port to which you can connect the SIM900. Along with building an array char at a time."
39841,In this piece of code you have a strange mix of upper bounds:The first looks correct at 3.  The second loop has an upper bound of sizeof(int) which is 2.  The third loop seems to be sizeof(char) which is 1.Unfortunately non of those values match up with the results you are getting.  What I would try is refactoring whats inside you function to this.And then call it to populate your values:
40174,"There are, obviously, a great number of ways that this can be achieved. The simple brute force way would be to have a series of if statements, looking for a sequence of eight consecutive 0s and/or 1s, and loop through the string containing the response.Or you could loop through the response, using strcmp(), similar to what is described here: how to do like a grep in a sketch?However, a more intelligent method would be to use pattern matching and regular expressions.From New regular expression library released, Nick has provided a Regexp library. It uses Lua for the expression syntax, see string.find, for more details.I am still playing with this code, but your sketch would need something like this:This code assumes that you are looking for a line beginning with < and captures an eight digit binary thereafter - as determined by the expression within the inner (), in the line:So, it should output:Obviously, instead of just outputting the captured binary digits to the serial monitor, you need to save them for your relay control.For neatness, you could replacewith Note the use of the backslashes at the ends of the lines. I've included them here, in order to get the test sketch to compile. You probably will not need them as you would be receiving the response from the server, and not providing an example string for testing.Here is a working version, along with multiple test strings (input_str) and example match strings (match_str):For the match_str line,you may or may not need the caret (^) to match at the start of the line, and the [\n]* or [\n]?. See which combination works for you."
40316,Finally got the solution. My method of capturing Serial string data is a little bit faulty. And also remove maximum strings and try to declare maximum local variables And use ArduinoJson library for parsing the data.This is my modified code:I'm also trying to capture response as char array but not able to capture it. Please guide me about that otherwise this one string may not cause any heap fragmentation. I am so glad if someone helps me out for this.
41863,This works 
42974,"Summary: I tested @noospy project (with some modifications) and it works flawlessly. I had to rename Button.h to ButtonM.h due name conflict with another button library. Also, I'm using new version U8g2, so I had to change some types and eliminate some calls. Finally, I used the I2C version of the OLED screen.This is my adapted code:HardwareSo, I don't know what your problem is, but your code is impecable."
43486,I think this should work fine:
43561,"I've looked through your code and can't see anything obvious that is causing the problem, so I have refactored it a bit in the hope that the problem becomes more obvious.What I have tried to do is to reduce the number of lines of code.  If there are less lines then there should be less bugs :)You used a bool to record the on off state, I changed that to an enumeration because that adds a bit of clarity, and when working with mains voltages I like things being clear.I changed your while loop into a for loop, I think it looks cleaner.  This was also the reason I changed your if statements into a switch statement.The guts of the if statements have been removed and placed in a function ChangeRelay(), it returns the new state of leds or lights.  I could have gone with a reference to make state an in out parameter, but decided a return was simpler.ClapCount() and GetVolts() are relatively unchanged apart from a bit of const'ing of variables to make things easier to read.  Also you might have noticed I, j and N have all been removed, because single letter variable names are my nemesis, who knows what q means and why r and t are being added to it to make z?ControlRelay lets you route all you relay switching through one function, if there was a copy and paste bug in your code (which I don't think there was) then they will either all work or not work now.There is a big difference between ""my"" code and yours, you won't be able to switch both on at the same time because the switch statement won't let you.  So in a way you problem is solved.  If you really wanted to you could add:"
43565,"The three 255 values for RGB colour space  (255^3) is 16,581,375 colours. These include for brightness level.  The reason you're experiencing brightness issues is not to due with your arduino board but, with the RGB color space.  And by breathing, and i'm guessing here, that you are trying to transition thru RGB:You may have more success or find it easier to use a HSL or HSV colour space. HSV uses Hue, Saturation and Value instead of RGB. FastLED has optimized it's implementation of HSV to use a 0-255 addressing for Hue (instead of 360), keeping it fast for animations run on microcontrollers:https://github.com/FastLED/FastLED/wiki/FastLED-HSV-Colorshere is a similar effect using the HSV color spectrum:"
43628,These values mostly come when you are unable to communicate with any UART device on proper baud rate. Best is to change the baud rate of ESP8266 from dafault 115200 to 9600 using And then use the regular program. And you will get what you want. 
43738,"IEEE 754 is the specification for floating point values. Integers aren't floating point values so this function of yours can have nothing to do with integers.On an Arduino (8-bit):To convert 4 bytes into a long you can use:An int value is just the lower two bytes of the same kind of conversion:You can use the same method (albeit backwards) to get the bytes to put in your payload:You can also use the same technique as your existing function with different datatypes, since all you care about is the byte content not the format or meaning of the bits within it:"
43901,"From network, seems to me, it is not that easy to find the right answer of the maximum value of micros() of my own arduino boards, too.
In my case, seems that micros() rolls over about every 17 seconds.
Finally, I wrote the Setup() for myself to catch 0x1111111 as the maximum value of micros() as follows."
43983,"Your signals are slow enough that you may not need any timer. You can
just use the Arduino micros() function to handle all your timings. Of
course, micros() itself relies on Timer 0, but you don't need to
access any timer directly.I would use the external interrupts in CHANGE mode to measure the duty
cycle. For example:For handling two inputs, you can duplicate everything that has a 0 in
its name and name it with a 1. If your signal is no slower than
60 Hz, you can also replace all uint32_t by uint16_t to make
the code slightly faster.For generating the outputs, do something similar to the Blink Without
Delay example:Again, you can handle two outputs by duplicating the code and replacing
0 with 1. Note that you cannot replace uint32_t by uint16_t,
as it would not work for the slowest frequencies.Edit: Now we may ask the question whether it is possible to use some
timers to make all this more accurate. The answer is yes, you could
achieve maximum accuracy by using four 16-bit timers:For reference, micros() has a resolution of 4 µs. The 16 µs
resolution of the timer-generated output seems poor in comparison, but
the timer has the advantage of having zero jitter.Now, for doing that that, you would need an Arduino Mega 2560. The Uno
has only one 16-bit timer, so it could help with only one of your two
channels.There is still something you can do with a single 16-bit timer. Set it
to normal counting mode, with the prescaler at 8, and use it
instead of micros() for timing your inputs: in setup()and in the interrupt handler, you replace uint32_t now = micros(); byAnd now you have input_0_high_time (which should also be uint16_t)
in units of 0.5 µs."
44154,"The problem is that when the device is unlocked with the correct code, you turn the green LED on wait for 0.5 seconds and then you don't turn it off again. So the simple answer would be sempaiscuba's answer.Personally, I like the fact that the red LED indicates that the device is locked and the green LED indicates that it is unlocked.The problem that I see with your code is that if the user enters an incorrect number, it doesn't reset, allowing any amount of wrong numbers until it sees the right number. This means that I could come along and press the keypay randomly and after a while I would have pressed every digit in the secret code and it would unlock.Think of the problem as a state machine. You start with 0 digits correct (ie position==0). If at any time the user presses an incorrect digit (or the * or #), the state machine will reset back to 0 digits correct state. If the user enters the first digit correctly then it progresses to the 1 digit correct state (ie position==1). And so on until all of the digits are correct and the device is unlocked. Due to the simplicity of this state diagram it can be accomplished using a few if statements.Once unlocked, all you have to do is press any key to lock it again.Resources:
http://playground.arduino.cc/Code/Keypad"
44510,"Here's a pretty definitive list for you:Note that non-simple const values, things like arrays and strings, depending on the architecture (i.e., if it's a Harvard architecture or not) may be copied into a block of global RAM for simpler access. See PROGMEM in the Arduino Reference Manual for more information."
44892,"This will not fix your problem!You said you were inexperienced, so I have taken you code and with no knowledge of what it does (that mean I may have made mistakes) I have refactored it slightly.What I have tried to do is group similar variables into arrays (Colour).  I have also created a structure to hold your LED data, it makes it easier to read if it all appears on a single line.  I have added loops to some of the functions to reduce the line count.  And if you aren't changing a variable make it const, it will make no difference to the compiler, but its easier to read and understand.I haven't compiled this, so there is probably a howler in there, but hopefully it will give you a different perspective on your code and a different (not better) way of doing things.  Oh and it should still have the problem you are asking about, which I think is you need to add an else into that function."
45499,
45941,"I'm assuming you want to run each colorWipe for 200 ms, one after another.You need a state machine to timing each colorWipe, like this:In each loop you will be waiting 200 ms before doing anything. When the times comes, you will enter the if with state==0 and you will execute the first 'colorWipe'. After that, you advance the state by adding 1 to state variable.Then you will be entering loop and doing nothing for another 200 ms. When that time pass, you will enter the ìf with state==1. Now the second colorWipe will be executed.When the last colorWipe is executed, you set state to zero and begin again."
45942,Assuming the commented out delay in colorWipe should still happen then you need to nest the state machines: 
46017,"Your data has 11 channels and a single value for each channel. The values will be presented in graphic format, so it fits in the range 0-255 without degrading the presentation. You always can scale your readings to your display's resolution.You then send these 11 values in binary form. One byte per channel plus one byte to separate one data set from another. You don't need to send the channel number, just the values.At the Arduino end you read 12 bytes and then loop thru it converting the bytes to ints.This code doesn't have any error-detection. For that you can add an extra byte with the checksum of the whole dataset."
46270,"Have a look at the compiler output.The Loop optionThe first alternative produce a preface (setting things) and the loop itself.PrefaceloopThe unfolded optionWhile the unfolded version is:So, the loop execute 4 instructions per each array element, while the unfolded version had only 2 instructions per array element.But you are trading speed for space and and risking an error while coding the same repetitive thing.However, GCC (the 'Arduino' compiler) can unfold the loop by itself, so you still can write a loop but execute a sequence. Look at Tell gcc to specifically unroll a loopReal numbersI run a sketch (Arduino UNO) to time loop vs unfolded. The times for 1,000 execution of each method are:Quit a difference!Sketch"
46294,char is signed so 0x80 is really -0x80 (==-128). When promoted to a higher width the sign gets copied into the new bits 0xffffff80 (still ==-128).if you put unsigned in front of char you won't get that issue (though may encounter others).
46361,Solved simply by condensing code and getting rid of unnecessary variable declarations.Corrected program:
47381,"There is one big problem with your program, and it is here:delay(100);Using delay() is bad practice. The Arduino does nothing useful while
delaying. Quite importantly, it cannot respond to user input. And to
make matters worse, you have this delay inside a loop. This means your
program will be stuck inside the loop for 1.4 seconds. And during
this time it will not take care of reading the button, nor drawing the
player on the screen.The solution is to use millis() to manage your timings, and never
block your program while waiting for something. The approach is well
explained in the Blink Without Delay Arduino tutorial. In a
nutshell: on every loop iteration, you check the clock and, if it's time
to do some particular task, you do it. If it's not time, well, you
simply don't do it. Most importantly: you don't wait. If you don't do
something on this loop iteration, no worries, you will do it on some
other iteration.With this approach, there are some pieces of information (e.g. arrow
position) that will have to be remembered from one loop iteration to the
next. This can be done by storing that in global variables. I prefer to
to use static local variables though, to keep the information confined
to where it belongs.Here is my try at your loop(). Notice that both the arrow and the
player are managed through the same pattern:
if (it needs to be updated right now) { update it; }"
47455,"First, you have to understand what “hex” means. Basically, you are
representing binary data as text, where each byte is represented as
two characters. For example, the number 42 is represented as either “2A”
or “2a”. In C and C++, you can write this number as 0x2a, but I assume
your serial stream sends the raw hex data, without the “0x” prefix.
Thus, on the serial stream you may receive the character “2” (character
code 0x32 = 50 in decimal) followed, some time later, by “a” (charcode
0x61 = 97).What you need is a conversion routine that takes these characters and
reconstructs the binary data out of them. Here is one such routine I
use. You have to provide it with an input string in and an output
array out large enough to store the resulting binary data. The
function will return the number of bytes filled in *size:As a mere convenience, the function above accepts spaces within the
string, but only between bytes. Notice however that it does not attempt
to do any error checking. You may want to improve it in this respect.Next, you have to devise a way to frame your messages on the serial
line. Serial does not provide any framing per se: it only transmits byte
one by one. When dealing with text, a common scheme is to send a
carriage return (\r) to indicate the end of a message. With this
convention, you sketch has to buffer the bytes it receives until it
sees a carriage return. Then it can process the whole message as a
whole. This approach is nicely explained in the blog post Reading
Serial on the
Arduino,
by Majenko, a regular contributor to this site.Here is an example that reads an hex string, converts it to binary, and
then sends it back as hex again:Notice the lines with the comment “echo”: they are meant to help you see
in the terminal what you are typing. You can remove them if you do not
what the Arduino to echo your typing. I tested it by sendingand it replied"
47503,"way too complicated:note:
 1. ""* 26"" can be further simplified;error checking could be built-in here, or somewhere else (better).better structuring could get rid of one of the temporary variables."
480,"I wouldn't normally put two answers to a question, but I only just found this today, where you can use printf without any buffer. This still has the floating point limitation.edit: I thought I would do a little testing on this, and it works quite well. I added a better test to the loop with formatted output. "
483,"I am playing on a Arduino UNO, you would have to compare the datasheets to determine differences.For my research on this answer I am looking at:Also:First, let's see what happens when we set an arbitrary PWM on pin 11results in:This first point I will make is that with the given 490Hz the PWM duration is actually 2ms which seems to be close to what you want (you said between 1-2ms), maybe my misunderstanding there.From several of the links posted above, you will see that you have different pre-scalers available depending on which timer you are using: eg.Pins 5 and 6: controlled by Timer 0 in fast PWM mode (cycle length = 256)Pins 9 and 10: controlled by timer 1 in phase-correct PWM mode (cycle length = 510)Pins 11 and 3: controlled by timer 2 in phase-correct PWM mode (cycle length = 510)These are relatively simple to setup and use (the setting is at the bottom of each of the above code blocks), but you have to be mindful of playing with the pre-scaler of timer0 (which controls millis() and delay()). So if you have a choice, steer clear of timer0, or pwm pins 5 and 6.Example of using just the inbuilt pre-scalers without any additional libraries:I know you can manipulate the frequency better than that, and I have been playing with this for hours and then I finally stumbled upon the final link (which believe it or not, I found via YouTube!).To use the PWM library you will need to download it from Google Code, save/import/get it into your library folder, and restart the IDE. Once you do that, you can explicitly set the frequency (within limits, 333Hz is within those limits), and you should be set.Code example:There is even a pwmWriteHR which allows for higher resolution, but that does not work with timer2 (which is only an 8-bit timer).The matching, non-safe (ie initialises and uses timer0 as well) functions are:The only limitation I have found so far is that it doesn't work with PWM pin D11. I have tested D3, D9 and D10 (they all worked fine), but I did not get around to testing D5 or D6.Good luck, I hope this helps."
48446,Method using the number of letters.
48493,Try this code.
48544,"Think of it like this. Any time you use a while loop your code has the rains until its done its job. It's important to remember that the loop() function in Arduino should not be blocked. This line:while (sensorState == 1)will block forever. The condition is never changed from within the while loop. Theres a simple way you could fix this which would be to set sensorState and update it inside the while loop. But lets not do that. Because thats inefficient and you'll likely run into this problem again in more complex programs and that solution here won't still be a solution.What you're trying to do is called concurrency. Your program should have obvious units of execution. Your two units are: ""run a buzzer for 5 seconds"" and ""set off an event when a sensor reads true."" where the first is depended on the second. So its conditional. That sounds like a job for ifWhen you code in { and } it is a block. It's not quite a context but is a distinct mode of execution.So technically this:Is two modes of execution. Since loop() is executed repeatedly. With that in mind when you program you can then use a variable to control the what gets executed as needed. So:We could stop here. But the use of delay is also blocking in the loop function and it is only for perception. So here's the whole thing without delays using a check against the modulus of diffTime.No need for delay >:3 And all for free you got a new feature which is that if you set off the event again (the light goes off) the buzzer is extended another 5 seconds. If you don't want that all you have to do is add && buzzer_enabled == false to the first if."
48548,"You have two major issues here:The first is that you never re-read sensorState. The second is that you are comparing stopTime before setting a value to it. Try re-arranging like this:In your example, the buzzer does not sound when the light has been switch on and then back off again.Good point. Well, we can simplify somewhat:"
48654,"The information from Rubber Duck is correct but incomplete.I need a huge amount of digital PWM output for hobby train control.So I connected 4 x 74HC595 to my At Mega which must be fed with a 2 kHz bit pattern through 0,5 ms. interrupts.My serial shift function that shifts 32 bits into the registers takes 562 us per cycle. Impossible.I made an optimized version of digitalWrite and Read, which takes 328 us. Now it is possible to PWM with 2 kHz. The trick is that my optimized function remembers the last 2 Pins including its bitmasks and outports;  and  I skip the Timer check. It is thread safe. For a single digitalWrite this takes a tiny bit more time. With repeating writing to datapin and clockpin it improves the standard Arduino digitalWrite with about 42%. By the way: With the digitalWriteFast library the result is 45,8 µs, a really enormous improvement. But this library handles only writes, if the pin number is known (and thus fixed!) at compile time. That is not the case with my LiquidCrystal library, where either 4 or 8 bits parallel are written to the shield via 4 sequential pins. I got my optimized digitalWrite only working for my application including the LiquidDisplay when I copied the C:\Users\Dell\Downloads\arduino-1.8.5\hardware\arduino\avr\cores\arduino library to a subfolder in the folder of my application, called C:\Users\Dell\Google Drive\ …\…..\AppFolder\libraries. When I replaced in both folders the wiring_digital.c with my optimized version, it worked. I could not get it at work, when I only replaced the wiring_digital.c in the Arduino library (the LiquidCrystal took the standard function somewhere else). Adding only wiring_digital.c in de subfolder of my application generated a mass of linking errors. Thus I copied the whole Arduino folder (which is not that large) to my subfolder in the application and it compiles without any problem. Not a very elegant solution, because there is a replication of the whole library; but it works.Conclusion to override a core Arduino function:•   Put your changed function(s) (.c and/or .h) in the Arduino library, and copy this library entirely to the subfolder ""libraries"" in your application folder.  Then all other libraries will also use your own changed function.Conclusion performance digitalWrite in a real 32 bit serial shift :•   An optimized  generic digitalWrite and Read easily outperforms the standard one with 42% if 2 pins are used in repetition.
•   digitalWriteFast (with determined pins at compile time) outperforms the standard digitalWrite in a real 32 bit shift application with 92% (is 12,2 times faster).Hope this helps other Arduino users….."
48694,
48771,"On my answer to the question you are referencing, I state that “If
you use the heap like a stack (last in is first out), then it will
behave like a stack and not fragment.” This seems to be exactly your
usage pattern, thus you should not fear fragmentation. Of course, the
caveat written in Michel Keijzers’ answer applies: you should make sure
that no other part of your code, including libraries, is using
malloc() and free().Just to give some evidence, the avr-lic documentation provides some
implementation details about malloc:When allocating memory [...] If nothing could be found on the
  freelist, heap extension is attempted. [...] When deallocating the
  topmost chunk of memory, the size of the heap is reduced.All this can be seen in action in the source code of malloc() and
free(), which is abundantly commented and quite readable.Edit 1: From the same section of the avr-libc documentation, we learn
about how realloc() grows a memory chunk:If [...] the old chunk is at the top of heap, and the above freelist
  walk did not reveal a large enough chunk on the freelist to satisfy
  the new request, an attempt is made to quickly extend this topmost
  chunk (and thus the heap), so no need arises to copy over the existing
  data.Based on this, I would suggest you use an array, rather than a linked
list, and use realloc() to adjust the size of the array. A linked list
of n objects of size m has a memory cost n × (m+4):
each objects has an overhead of 2 bytes for the linking pointer, plus 2
bytes for malloc()'s internal bookkeeping. The cost of an array would
be only (n × m)+2.In this case, however, it is essential that no other part of your code
uses malloc(), otherwise realloc() could end up allocating a whole
new array, which would be very costly.Edit 2: I wrote a small test program that randomly grows and shrinks
a memory buffer. Running the test on an Uno shows that the allocated
memory chunk never changes address even though its size varies wildly."
48990,"I've written a code for NRF24L01+ based on the datasheet.run them on your arduino and test them.CE pin is PIN7 in arduino and CSN is PIN8 in arduino.
NRF_monitorRegisters() shows all Registers of NRF.It's nice to test your NRF
maybe it helps:for transmitter:for receiver :"
49155,"Majenko has correctly diagnosed your problem, and the blog post he
linked to is definitely a must-read. The suggested solution, namely
buffering the input until you can read a complete message, is presumably
the most standard way of dealing with an input stream.It is, however, not the only option. Your idea of building the number
digit by digit can work, if implemented properly, and it can save you
the memory cost of the buffer. The key is to only read bytes when they
are available.Below is a non-blocking implementation of a number reader that works
along the lines of your own code. This function only reads positive
numbers. It returns the number it just parsed upon reading a non-digit
character. In every other case it returns -1 to tell you there is no
input number available:And here is how you would use it:"
49261,"Not quite the question that was asked but part of the problem.This is a simple introduction to pointers.&x get the address of x*y dereferences the pointer y, which means it 'turns it back to a variable' (this is simplistic view which isn't really true, but will do for now). 
So you could, if you wanted (which you wouldn't) do this *&z which would be the same as doing z.Basically think of & and * as a pair of complimentary operators like - and + or * and /.  (They aren't operators, but to start with it might help).The next problem is when you do thisAll function parameters in C/C++ are passed by value by default.  This means the function gets a copy of them not the actual value.  So if you had:If you pass by reference then you will see 99 printed, to pass by reference you can do it one of two ways.FunctionTwo only works with C++ (It will work with an Arduino).FunctionThree might cause a segmentation error if NULL is passed in and the function writes to it.If it helps in my opinion pointers was one of the hardest concepts to grasp in classic C/C++ so don't worry if you don't understand it just have a play with it and see what you can do.Calling MethodsAs for *object.&method() I've never come across that one, but that doesn't mean it doesn't exist. :)"
49293,"Use state change detection and hysteresis for counting pulses in an analog signal.This sketch basically applies a software Schmitt trigger to the analog input signal, and increments the counter on each falling edge. (Rising edge of light intensity, because your LDR configuration inverts the signal.)
The red waveform is the analog input from the LDR. The gray rectangular wave is the state (and the state of the LED). The counter is incremented at each black, vertical dashed line."
49302,"Here is a solution:The count variable controls when to blink and how many times. While it's zero, no blinking.When not blinking, it keeps comparing actual time with the last time it blinked. When the time exceed 20s, it puts count to five, and in the next loop, the blinking start.Variables are declared static so they keep their values between loop executions."
49319,"I got it working by initializing and  deleting the pointer to the GPS and GSM object. Initialization and freeing of the objects are made in the loop function. I initialize the GPS, run it in a loop for sometime, destroy it and initialize the GSM and same procedure as GPS.Though I don't know if it'll have any effects but its working perfectly"
49320,"From what I understand, you want to read two ADC channels
simultaneously. First, you have to understand that you cannot read them
exactly at the same time, as you have a single ADC. What you can do,
however, is read them one after the other: you read the V channel, then
the I channel, then the V channel again, etc. This means you will have
to change the multiplexer setting (the ADMUX register) in between the
readings. The most convenient place to do this is within the ADC ISR,
the logic of which becomes:Example code (not tested):Note that this example assumes you do the readings in the (V, I) order.
Thus, within setup(), you have to initialize the multiplexer for the V
channel, as in"
49691,"It would seem you managed to solve your problem with
Serial.parseFloat(). This is probably the easiest solution, but it has
one serious drawback: it is a blocking function. Which means, during
all the time needed by the serial port to transfer the number, your
Arduino does nothing but wait for the incoming characters. This is an
issue if your program has other task to do like, e.g., manage a PID
regulation.I suggest you consider reading the serial port in a non blocking
fashion instead. This should make your PID happier, as it won't feel
neglected while you read the incoming data. Look Alterno's answer is a
good example of a non-blocking function that combines reading and
parsing. However, I would like to point out that you do not need to
implement your own number parser if you don't want to. A very common
pattern is to instead store the incoming characters in a buffer and,
when you see the character chosen as a terminator (e.g. ASCII LF), you
parse the buffer at once using either strtod() or atof(). For
example:"
50135,"The fillRoundRect function format is (initial_Xpoint,initial_Ypoint,length,width,corner_radius,color)Therefore, you already have the information about the location of the button itself. Next, check if the x and y value is within the button area."
50682,"randomSeed(analogRead(x)) will only produce 255 sequences of numbers, which makes it trivial to try all combos and produce an oracle that can couple to your output stream, predicting all the output 100%. You are on the right track however, it's just a numbers game, and you need a LOT more of them. For example, taking 100 analog reads from 4 ADCs, summing them all, and feeding that to randomSeed would  be much better. For max security, you need both unpredictable input and non-deterministic mixing. I'm not a cryptographer, but I've spent thousands of hours researching and building hardware and software random generators, so let me share some of what I've learned:Unpredictable Input:Potentially Unpredictable Input:External Unpredictable Input:collecting 
The last thing you want to do is spit out entropy as is comes along. It's easier to guess a coin flip than a bucket of coins. Summing is good. unsigned long bank; then later bank+= thisSample; is good; it will roll-over. bank[32] is even better, read on. You want to collect at least 8 samples of input for each chunk of output, ideally much more.Guarding against poisoning
If heating the board causes a certain max clock jitter, that's an attack vector. Same with blasting RFI towards the analogRead() inputs. Another common attack simply unplugging the unit thus dumping all the accumulated entropy. You should not output numbers until you know it's safe to do so, even at the cost of speed.This is why you want to keep some entropy around long-term, using EEPROM, SD, etc. Look into the Fortuna PRNG, which uses 32 banks, each one updated half as often as the one before it. That makes it difficult to attack all 32 banks in a reasonable amount of time.Processing
Once you collect ""entropy"", you have to clean it up and divorce it from the input in a hard-to-reverse way. SHA/1/256 is good for this. You can use SHA1 (or even MD5 really) for speed since you don't have a plaintext vulnerability. To harvest, never use the full entopy bank, and ALWAYS ALWAYS add a ""salt"" to the output that's different each time to prevent identical outputs given no entropy bank changes: output = sha1( String(micros()) + String(bank[0]) + [...] ); The sha function both conceals inputs and whitens output, protecting against weak seeds, low accumulated ent, and other common issues.To use timer inputs, you need to make them indeterministic. This is a simple as delayMicroseconds(lastSample % 255); which pauses an unpredictable amount of time, making ""successive"" clock reads non-uniform in difference. Do that semi-regularly, like if(analogRead(A1)>200){...}, provided A1 is noisy or hooked to a dynamic input. Making each fork of your flow rather difficult to determine will prevent cryptoanalysis on decompiled/ripped output. Real security is when the attacker knows your whole system and is still helpless to overcome it.Lastly, check your work. Run your output through ENT.EXE (also available for nix/mac) and see if it's any good. Most important is the chi square distribution, which should usually be between 33% and 66%. If you get 1.43% or 99.999% or something edgy like that, more than one test in a row, your random is crap. You also want the entropy ENT reports as close to 8 bits per byte as possible, > 7.9 for sure.TLDR:
The simplest fool-proof way is to the uthe ESP8266's HWRNG. It's fast, uniform, and unpredictable. Run something like this on an ESP8266 running the Ardunio core, and use serial to talk to the AVR:** edithere is a bare-board HWRNG sketch I wrote a while back, operating as a not just a collector, but a whole CSPRNG spitting out of the serial port. It's built for a pro-mini but should be easily adaptable to other boards. You can use just floating analog pins, but it's better to add stuff to them, prefereably different things. Like microphones, LDRs, thermistors (trimmed to max spread around room temp), and even long wires. It does pretty well in ENT if you have even moderate noise.The sketch integrates several notions I've mentioned in my answer and follow-up comments: accumulating entropy, stretching by over-sampling less-than-ideal entropy (von neumann said it's cool), and hashing to uniformity. It forgoes entropy quality estimation in favor of ""gimme anything possibly dynamic"" and mixing using a cryptographic primitive."
51810,I got it working using the code below:
51936,So I finally succeeded to read a register value. I don't really know where was the problem. Here is the code if it can help someone (the scanner still does not work btw) :
52070,"Basically, you have written this code:Try something like this:and for the implementation od anyCardPresent refer to this discussion - if more consecutive calls of PICC_ReadCardSerial fail, you can consider this as card being removed"
52241,"There are too many String copies in your code. This is asking for
trouble, as it can lead to memory fragmentation and, ultimately, to
memory exhaustion. That's why I recommended in a comment to buffer the
data in plain byte arrays.However, it appears your Node.js script is going to do the buffering
anyway (that's what the Readline parser does). Thus there is no point
in buffering also on the Arduino, which has one million (or more) times
less memory than the computer running the Node.js code. If the Arduino
just outputs the bytes as it gets them, the program becomes very simple:Note that, upon receiving an “end of text”, the program terminates the
current line (by sending ""\r\n"") and immediately sends the preamble for
the next one (""BEGIN:""). On the receiving side, the readline parser will
take care of delivering only complete lines.If, for whatever reason, you do need to buffer inside the Arduino, then
remove the Serial.print(""BEGIN:""); line from setup() and change the
loop as follows:Note that the buffer is sized at half the RAM of your Uno. This is safe,
as it is a very simple program that uses very little dynamic memory
(stack only, no heap) and has no risk of fragmentation. Note also that
your original program stores both the raw data and the formatted hex
(which is 4 times larger) in memory at the same time, which means your
buffering would be limited to 1/5 of the available RAM."
52585,"As explained by goddland_16. Using Software Serial library will solve the issue. Code is given below. By Initializing other digital pin as communication pin, Interupption between Tx and Rx and to ESP8266 is seperated. Arduino UNO / Nano Code :ESP8266 Code :"
52689,"You could use chainable RGB drivers like these:They are based on the P9813 chip and can be used with the FastLED library.
You can find them on Aliexpress or eBay, if you search for ""STM32 rgb"".Wiring:Example code:"
52708,"The HttpClient object must be instantiated with a Client object which will handle the underlying connection. Source:Requires a networking hardware and a library that provides transport specific Client instance, such as: Refer to the following code:In the above example, it is done like Which means that for your code, you might want to pull out client as global object and instantiate it as:You should also use the example code to see how to print the response after executing client.get():The example code is pretty much example what you want, you just have to give it a Adafruit_CC3000_Client as the Client.Full code:"
52925,"Majenko’s answer is spot on: you just have to count the sentences you
read and repeat one every ten sentences. And you don't need two copies
of the sentence you are reading: one is enough. But I would add that you
don't even need a single copy: you can just echo back the characters you
read, without ever storing them, until you hit a '*':As a side note, if your program doesn't read input from the computer,
and if it doesn't send anything to the transducer, then you may consider
getting rid of SoftwareSerial and using only the hardware serial port:Yes, it is perfectly fine to use the receiver and the transmitter for
different links. The only caveat is that you will have to use the same
port configuration on both sides: if the transducer talks at
9600 bps, then the whole port will have to run at 9600 bps."
5357,"It does seem possible, check out this thread on Arduino forums, where cpixip worked directly with the NRF24 SPI interface to accomplish that.Here is the code he published, in case the link won't be available:The pinout seems to match the NRF24 library pinout.
Please note that it seems this project does not implement the WiFi stack, but only check a high enough signal ( > -64dBm) for a given channel. In order to create a WiFi hotspot, implementing the 802.11 stack is inevitable, and it seems like the Arduino core chip (atmega328) is not suitable for implementing it using software and bit-banging, so a dedicated hardware will be necessary. "
54093,Here's the correct codes. 
54686,"Answering this question based on the help from above. It works with this code. Thank you all for the help. The clock does not reply the newly set time instantly, but after a few seconds."
55045,"If you can configure the PWM to run at 111 Hz (I don't know how
this is done on the Teensy), then “gating” it is as simple as turning
the PWM on and off at the desired frequency:"
55265,"Here is the user manual for the BH-MSD-2A Micro stepping driver.Page 5 shows the two tables giving the connections:You have already connected P2, and that leaves P1 remaining.The timing diagram below shows the state of the, PUL, DIR and ENA signals required.So, the ENA input can either be held high, by connecting to VCC or connected to a digital output pin of the Arduino, to provide  basic ON/OFF control.This thread, arduino uno with stepper motor, the OP is using a very similar controller to yours, except that theirs is the 6 A version (BH-MSD-6A). Their code, in the thread has a lot of unnecessary code, and apparently has a number of issues. A stripped down version, of the same code, is as follows:Note that while this should get you started, as the OP states in the thread there are issues with it, that will need fixing.(I have to go now to fix some Marlin firmware, but I'll come back to this answer later)"
55266,"This is not complete without sscanf.I took the sketch by @Juraj and declared seperate integers to be sure that every %d would match with an integer.Marcel Stör, there are now four good solutions. In my opinion they are equally good."
55516,"Updated 26-08-2018: added tx(false); at the end of send.  Without it, the TX pin could remain high, flooding the 433MHz band and making any other communication on it almost impossible!!!Although these are all pretty old posts, I've still been struggling to get VirtualWire or its successor RadioHead working on an Attiny85.  Typically the problem is that VirtualWire uses timer 0 and thereby breaks other stuff.Now, for RX you typically don't want to spend all your processing cycles waiting for bits to come in, so you want it to be interrupt-driven, but for TX you can often do without that ...  So, I did a bit of reverse-engineering of the VirtualWire TX code and implemented it as a simple send routine which can be used without needing a dedicated timer-interrupt.  Using the code below on Attiny85 and an Arduino Uno as receiver with the normal VirtualWire library and the same baudrate, works just great for me, so if someone else can benefit from it, then here it is (including some code to read out an ultrasonic distance sensor and driving some leds - up to the reader to strip out what he doesn't need):"
55765,"I was able to get the ESP8266 to read all DS2413 devices without errors as well as blink each LED connected to the DS2413, individually, down the chain.Here are animations of it working.

I owe all the credit to mortonkopf on Github. His sketch DS2413_button_array_test, was exactly what I needed to be able to read the addresses on all DS2413 devices connected and blink each LED. Here is a link to his OneWire_DS2413_array repo.https://github.com/mortonkopf/OneWire_DS2413_arrayHere is the code I am using to make this work.Here is a link to the Gist I created for this sketch.
https://gist.github.com/orbitrod/51eb10c1a88f5747dc79298030e4480c"
55894,"If you are confident with the device you connected to your Arduino Uno in terms of it has a reliable serial communication firmware running on it, You might need some buffering before relaying your commands;"
55910,"Ok, thanks for all your help, found the solution to make it stable.
I think I got thrown off by the fact the led = 144 did (magically) seem to work outside the loop but led == 144 didn't work at all.turns out i was counting the leds wrong (it's from 0-143 instead of 1-144) and that made all the other pieces fall into place.tnx"
56049,"The while() loop in setup() is what gets hung up. Instead of calling odb.init() until it returns true, just call it once just to get it initiated, then call/check in loop() and react accordingly:"
56109,"There could be few reasons but, firstly I would like to ask you to check if your write command is working at all. Try to disable reading mode and leave just write mode:Try above code and if it will not work change RF24_2MBPS to RF24_1MBPS and RF24_PA_MIN to RF24_PA_LOW on both modules (transmitter and receiver)"
56667,"i found another library ultrasonic solve my first problem(Ultrasonic.h: No such file or directory) but then have another error... it say(class Ultrasonic' has no member named 'Ranging')....
in this time i changed some of my code and now working goodmy code after solve"
56734,"Creating a few boolian variables could help with this.These new variables are set when the code is ran the first time. Therefore, no looping."
56805,"I need a code to pause arduino code until a button is pressed. I wrote a simple function to do this. This code assumes that you have a pulldown resistor, but you can easily modify it to work with a pullup resistor instead, if you feel the need:simulate this circuit – Schematic created using CircuitLabSee example code here!"
57562,"Since the frequency is so low, you can generate the signals in software.
That would not be as clean as timer-generated signals, but it will be
much easier. And probably clean enough for the intended purpose.In order to generate a tone, you have to repeatedly switch the pin
connected to the piezo. This is very similar to blinking an LED, only
somewhat faster. Blinking an LED is the very first thing you learn to do
with an Arduino, but you may notice that blinking two LEDs is a
little bit trickier. The problem – and the solution – is
discussed in the Arduino tutorial Blink Without Delay. Building on
that tutorial, here is an example program that generates two 100 Hz
signals in quadrature:If you compare this with the above mentioned tutorial, there are a
couple of differences worth noticing:There is a little trickery in the initialization of last_B_toggle,
which is an unsigned number initialized to a negative value. The
initialization is valid and works modulo 232. Using a small
positive value would have the ill effect of now - last_B_toggle
overflowing to a very large positive number on the first run of
loop(), putting last_B_toggle effectively in the distant past."
57798,"For anyone else who comes across the same problem, this worked for me: "
57867,"This is actually a lot harder than you might at first think.Your ""sound sensor"" is little more than a microphone and amplifier. It gives you an audio waveform - whereas what you are interested in is the peak power. An audio waveform goes both positive and negative:The ""peak"" of the waveform can both be positive (above the line) or negative (below the line).To get that peak you have to rapidly sample over a short period and find both the maximum and minimum values, and get the difference between them.  However, the Arduino can't see negative values on the ADC - so you only get the upper portion of the waveform, which is less than ideal.  Really you should add a DC offset to the output of the sound sensor to bring the signal up to the middle of the ADC range (adding a 10kΩ + 10kΩ voltage divider across the input pin to +5V/GND would do the job).If you don't add a DC offset then you can rapidly sample for a short period of time and work out the maximum value:Now to get the maximum over, say, a 10ms period, you can:However, if you add a DC offset it gets a little more tricky, but the results will be better:Now that you actually have your peak-peak value of your waveform over a short period you can use it to work out when the sound goes above a threshold and when it goes below, and how long it's been above that threshold.  The basic method is:The thing here is to know that you are looking for changes in the ""above the threshold"" state to start your timing.  A simple implementation may look like:Note: all code untested."
58256,there are nice functions inherited from Stream class
58283,"First of all you only need to include once. Including anything more than once is pointless and could be bad, if the header doesn't have include guards (yours do, but still it just makes the code harder to read).Let's take a look at the MQResistanceCalculation function, well... It's simply broken.I'm not sure what you expect to happen, but as soon as you reach a return statement that block of code stops and the result is returned, so basically that function executes the first return and then stops. You probably want to pass a sensor type and then use a switch to make it return for either the MQ5, MQ7, MQ8 or MQ135, because right now it only returns the MQ5 value.Then let's take a look at the MQCalibration function. So same thing as above applies, as long as you reach a return the function stops. Your MQCalibration function currently only does:And then the MQGetGasPercentage function can be re-written with switch statements to be way easier to read and understand. Oh and also that accuracy == 0 check is also pointless it has nothing in it.From reading this I see you've just copied code you don't understand and hoped it'll work, but as expected it didn't. And well copying code without atleast having an idea about what it does is stupid. So just read it, understand it and write it again, but by yourself. Your code has many pointless variable declarations and it just isn't well ""written""(or copy-pasted should I say).Also I've never worked with that sensor myself, so I was looking at the code aspect mostly, just so you know."
58314,"About the number 4294967295To my surprise, the sketch produces indeed the number 4294967295. That is not okay.
It turns out that the compiler knows the numbers and tries to do the math itself (instead of runtime).At runtime, the 50 / 0 results into a signed integer of -1.
When a byte is used, the 50 / 0 results into 255.
The result of that calculation is a variable with only 1's. That is 0xFFFF for a 16-bits variable. That results into 65535 for a unsigned integer and -1 for a signed integer and 255 for a unsigned byte.So far, that is okay. It makes sense.However, when the compiler tries to do the math itself with 50 / 0, it turns the result into a 32-bit variable of 0xFFFFFFFF. The compiler does not put the math into the binary result, but calls the Serial.println() directly with a 32-bit unsigned long of 0xFFFFFFFF, which is 4294967295.The reason is not the variable type of the variable 'result', but the division with 'p/x'. The compiler thinks it is better to make a 32-bit integer when the math is done with two 16-bit integers.I think that when the compiler optimizes, the result should be same as a runtime calculation.
There is an interesting discussion below this answer. @EdgarBonet calls the compiler behaviour weird but not a bug.Below is a test sketch that produces 4294967295 with Arduino 1.8.7 for an Arduino Uno:The code outputs normal results when 'x' or 'p' is calculated, for example the result from a function, or when one of the three variables is made volatile."
59972,"Not an answer, but I thought some of you may be interested in the C coding standards of some projects in the 1990s (based on the EDS standards, if I remember correctly).A summary of the rules is:An example program:Bit different to the way K&R wrote UNIX, and perhaps not too relevant to embedded? I'm not sure which I prefer, I guess both styles have their place depending on the makeup of a team :)"
60282,"Hi Lefteris the builder,
StackExchange is about questions and answers.
Arduino is about learning and fast prototyping.For guidance with your project, the forum at http://forum.arduino.cc/ is more appropriate.I suppose that a number of us have read the code that you use. We really do read code.
That code is not bad, but there are a few weak spots in that code:It seems that your hardware is working okay.It is hard to confirm that the code for the Holt-Winters algoritme is working.All this together is too confusing for us at the moment.I have changed my answer, the hardware seems to be working.Below is the changed sketch to test it without extra hardware.
I use the serial monitor. The sadw keys (followed by enter) are the cursor keys and the space bar (followed by enter) is select.@Lefteristhebuilder, you have selected that sketch, but the sketch might not handle problems very well.Anyone can write code for Arduino and put it online.
At least at Github it is possible that others can write an issue (as you did). The project at Github has 9 stars and the creator showed the project at the Arduino ""Project Hub"". That is all good, but I'm not very happy with the code itself."
60631,"If I correctly understand your question, then please try following code:"
60841,"Here is what i found for JPEG image file display on any TFT -i used JPEGDecoder library and instead of tft.pushColor , i used tft.drawPixel  method.For BMP , we need rgb values to render each pixel on TFT screen.But in case of JPG , first  we need to decode and create MCU tiles on TFT.
Then we paint those MCU tiles by color which we receive from JPEG stream decoder. 
Here *pImg is the pointer which hold the color information. 
As we increment *pImg++ array , each time we receive new color code of type uInt8_t type . Within MCU tiles , these color have to be injected . 
Each MCU tile is colored and drawn in the given sequence by considering where the border line of TFT screen is. It automatically create a JPEG image ."
60865,"You can’t print an array in that way.If you want to print an array of hexadecimal value (with two digits), you have to use sprintf function and change declaration of b array.The output produced is:7E001C900013A20041581CCBFFFEC17C000F0001000037464646000000E7
  7E001C900013A20041581CCBFFFEC17C000F0001000037464646000000E7
  7E001C900013A20041581CCBFFFEC17C000F0001000037464646000000E7 "
60892,Here is some ESP8266 example code to store and read strings from EEPROM data:
61130,"This is an overly broad question which borders ""write me the code"" - this isn't a coding service - and if anything belongs on StackOverflow since it regards processing.  That being said, this question would be flagging as overly broad there too. I'm providing an answer because I believe it may help others here as it speaks to some fundamental programming concepts.  This is not a perfect solution by any means, for example it doesn't take program size into account. See the end of the post for a sketch.There are two main problems you face:Modeling the input data means structuring your expected input in a meaningful way.  Looking at the input data provided, I see this formatNow think of each line as a packet of information.  In that sense, let's create some data structures that describe the data of the packet.  Given the basics above, let's model a Packet:OK, so that's a basic model of the input data.  How to process?  Always break down big problems to the smaller, manageable units to provide a solution.Now there's a huge number of possibilities to parse/interpret your data packets.  I am providing a bare bones, brute force approach that you may learn from, and hopefully improve upon.  For example I am not providing much in the way of array overruns which can crash a program.Here's the main processing function, which takes a string of input data (a line) and produces a Packet.  In all I am only going to provide for the Type 'G' and leave the rest to you.OK that's not a lot.  The logic isIt's important to breakdown these steps in smaller, manageable functions.  First, the code for getting the packet Type.So processType sets up the packet Type and adds information about whether to look for Unit information later.If processType() found a valid Type, the next step is to get the value based in that type with the function processValueGreat. Now, let's look at a way to get the value for a float:Finally if all went well, the code should look for the Unit if expected (based on the Type)Here's a GIST of an arduino sketch using the code above.Good luck, hope this helps.  In the future, pose questions regarding processing on StackOverflow."
61141,"Even though this is not elegant by any means, for now this is what I've came out with:Basically by using int a, the program decides the sequences of the name. Although it will not repeat the sequence after the 2nd input (ie 1st>2nd>1st>2nd), at least the sequence is not randomize anymore. Btw thanks for the tips @chrisl!"
61306,You have tried to define void midi() {...} inside the loop() function. But you cannot nest function definitions. Your definition (implementation) of midi() should be outside any other function.Like this:
61477,This is the code that worked for me:
61602,"Maybe for the second function you want something like this:This code is also avoiding the millis overflow issue if you run your board for a long time. Still, apart for a improved timing, there is no gain in using millis(), you still have to wait for millis to change, you might want to use a timer interrupt to do the job in background."
61804,have a look my example program below for you reference. 
61865,TX code Rx codeit is fully working now with both outputs on the same size
62238,"Ok, so I was able to do this. Here's the workaround.Let's say the GET response is a flat string containing large .json file with all the commas and curly brackets. The idea is to read it byte-by-byte and instead of storing it just find the key you need and extract its value.We want to find the field containing, say, ""97.5 FM"" from http://data.nba.net/data/10s/prod/v1/20190223/scoreboard.json (that's at the very end), skip 3 bytes (which is just "" | "") and then read and Serial.print 4 bytes (which is ""1280"")*. We would do something like this (of course make sure to connect to wifi and include <ESP8266HTTPClient.h>:where the getValue() function is defined as follows:You can call this getValue() whatever many times you like, but the strings you're looking for need to be only after each other, because the response to GET is read byte-by-byte just once.There is probably (i.e., most likely) a better way of doing this, but this approach works and it's pretty fast, so...* This, of course, is just an example, and you can overload this getValue() function definition to, say, read until it gets a curly bracket or whatever."
62338,"I have found why !!!1st: buf[8] instead buf[7] in declaration
2nd: reinit byte buf[8] before EC request part.So the code who works fine is:"
62458,"Since you are trying to distinguish tree different colours, I assume you are using SEN0147 in analog mode. That means the sensor output is between 0-5V. I do not believe that this will always be exactly a value of 894.I suggest to change your comparison check in a way not to check if values are identical but to check if values are in a certain range. (additionally to all the answers @RamblinRose already suggested)Here is a modification of the comparison loop of @RamblinRose with the change I propose. Check with different values of threshold, starting from high to lower values."
63116,"version using String (not recommended, but it makes simpler to understand the following C-string version)the version with C-string: "
63357,"Some guidelines for programming:Start each statement on a new lineUse brackets and align them.. so each pair of { and } is on the same column and align code with brackets to be indented 2, 3 or 4 spacesRemove superfluous bracketsAs you can see, you are having some superfluous/missing brackets. What you want is probably something like:Remove duplicate codeIn the if statement, you perform twice the same code (both you send an analogWrite with the same value, so the code (from the for loops can be reduced to:UnclearWhat is unclear why you first write an analog value, and directly afterward (in each if) you write the same value. I'm not sure what you really want here. Either you want to write to a different pin, or you want a delay (to have the value having some effect), I'm just not sure."
63466,"If you look at Arduino.h, you'll see true, false and bool defined as:Using a simple test sketch, it appears that comparing true or false to anything besides a 1 or 0 does not ""work""."
63608,"Taking the information that people have kindly offered to me, I have re-written my code to use the AltSoftSerial library and I now have my small app working fine.  Thanks.  AltSoftSerial uses pins 8/9 in an interrupt driven manner, leaving the 'standard' pin 1/2 serial comms for a debug channel.  I have it running at 19200 baud.
I have remove String variable from the code and my final improvement will be to use malloc() to allocation data buffer in place of the current statically declared buffer.
The purpose of my test app is to connect to my home wifi network a to print out the IP address allocated.  All output goes to an LCD display, but the serial monitor could be used instead.Here's my code :and here is the ESP822_cmd.h header file that I created :"
6448,"assuming your circuit works, your code has some serious issues. I rewrote the code for you and also provided a simplified circuit that I have tested and know works.  Instead of getting the pulse from the heartbeat detector circuit, we will simulate it on the Arduino by pulsing pin 2 periodically. "
64833,"Rather than using delay, use millis() and a variable to check if the some time has expired"
64932,"First align your code:Than the statement count = count assigns a variable to itself which is not needed, and for increment you can use count++, so you get:In the loop, you do not count pulses, but only the measurements where a pin is HIGH and when the pin is LOW anywhere within the second, it is set to 0.What you instead want to do is (assuming you want to count the LOW -> HIGH transients: Make a global variable called e.g. previousState. Now, if the previousState == LOW and the current state of the GPIO is HIGH, only than increase count with one. Also, within the loop, each time update the previousState with the current state.I leave the implementation to yourself."
65012,"byte* means ""pointer to byte(s). It is usually used to point to a byte buffer, and usually will also have a length value so you know how many bytes are in the buffer. It looks like your function does have a length value.If you're certain that the data in the payload parameter is a single int, and the length is correct for an int (2 bytes on Arduino I believe) then you should be able to cast the pointer to int* type and then fetch the value from the buffer:"
65462,"I think the issue is with the menuChoice() function. Try replacing it with this:
Of course, you could use parseInt() instead of the char buffer and atoi(), but the compile size is 50 bytes more."
6549,I haven't tested this but it compiled with no errors other than my not having TrueRandom.h. But it should get you a lot closer to (what it looks to me as if) you intended.
65502,"In your Sketch current, power, Bat_Volt are local variables define in loop function. Bat_Volt in not even defined in your sketch that's why they are not printing anything in draw function.Initialize then as global variable in your sketch and in place if Bat_Volt you had use voltage here float voltage = ((5*(voltage_average)*(R1+R2))/(1023*R2)); //convert unit value of voltage_average (0-1023) to actual voltage, substract voltage average value when not voltage should be read in your sketch. Correct that to.Your code after edit:"
65794,"If you can skip using interrupts, your Tiny could still do the job and not miss any pulses, as long as loop() can be executed at >40Hz, and the pulses are not be extremely short ""spikes"" but have a reasonable duty-cycle (or if short, you can sample faster):"
65816,"Use a TCS230 photo sensor and a 6500K light source to color correct your objects.This hookup will get you startedThis sketch, courtesy of Best-Microcontroller-Projects  will get you going.  Read the tutorial and dont forget to calibrate."
65929,"Thank to Jot, your answer actually helps me.
Now I am using this code and it is working very well.By the way, the code on https://github.com/jarzebski/Arduino-HMC5883L should add in the begin of setup."
65960,"This is your code without unnecessary brackets:Using the ternary operator you can write some if statements easier:Some remarks to think about that helps you solve your sketch (and is the reason why your GPin may blink):The line part (distance <= 25 || distance <= 0) can be rewritten to (distance <= 25) since if a value is less/equal than 0, it automatically is less/equal than 25.You set based one a condition a pin to HIGH or another pin to LOW, I would expect both pins to change, or the same pin. But I don't know your requirements.The 'edge' values (e.g. 25, 50, 75) fall in multiple conditions, you probably want to exclude the end edge. It is a sort of guideline to include the start and exclude the end, e.g. if (distance >= 50) && (distance < 75). In your case you probably are best of checking the distance like this:or do it the other way around:e.g. when you want the GPin to be on when between 0 and 25:"
66106,"Using a slightly modified version of your sketch, I receive the following output in the serial monitor when I enter the number 2.Current Conversion Mode: Enter your mode of Conversion (number 0 - 3): 
  Number recieved: 2Current Conversion Mode: Enter your mode of Conversion (number 0 - 3): 
  Number recieved: Conversion mode unsuccessfully set - Please enter a number 0 - 3
  Current Conversion Mode: Enter your mode of Conversion (number 0 - 3): 
  Number recieved: Conversion mode unsuccessfully set - Please enter a number 0 - 3
  Current Conversion Mode: Enter your mode of Conversion (number 0 - 3):If you change mode to an int then retest, you'll see the second and third ""Number recieved"" are 10 and 13. That would be the New Line and Carriage Return characters. When you send data via the serial monitor, do you have ""No Line Ending"" selected or something else?Here is a test sketch:"
66196,"I figured this out.
send code is Arduino Uno sideESP sideThen connect to wifi and upload to ThingSpeak.I had to get rid of Softwareserial and connect the RX on the Arduino Uno to the TX on the ESP8266-01 and the TX on the Arduino Uno to the RX on the ESP8266-01.Everything worked great till I changed from an Arduino UNO R3 to an Arduino Pro Mini for size and energy conservation.With the wiring the same (I think) and the code the same the string (f) doesn't get sent over to the ESP.  I don't see the TX led flashing on the Pro Mini when it should be transferring string(f) and nothing gets uploaded to ThingSpeak.  Not sure why but I will post another question for that one.  Thanks for everyone's help."
66433,"For strings with a fixed format like that (I assume it's a fixed format...) I normally just do a manual strtok of the whole thing into a set of pointers. No need for a loop.  You can then just test the last one to see if the whole thing tokenised properly, since if anything before that fails then all other subsequent ones will fail and the last one will have failed.As an aside: if there is ever a chance any of the fields could be empty (""flag,,category"" for example) then you should use strsep() instead of strtok() as I detail in my tutorial on splitting strings in C."
6662,
6706,"The code you presented does not fit for working with the RF 433Mhz. I'm not sure what you think this code should do, but this is not the way to go with a 433Mhz transmitter.I would suggest using a dedicated library for transmitting information using the 433. There are many libraries out there for doing that; two popular libraries would be the ManchesterRF and the VirtualWire, both includes code samples.For example, sending data with ManchesterRF: In addition, there are many other blogs around going step-by-step how to use 433Mhz Tx/Rx with ATtiny85, google is your friend :)"
67155,"Actually he isn't really converting float to int. He never uses float since he don't need it. The datasheet of the DS18B20 shows at page 6, how the data is formatted:So the data bytes 0b1111100001010000 will represent a temperature of -123°C and 0b1111100001011000 -122.5°C.The author from the link then shifts this data 4 bits to the right, so that all bits representing values under 1 vanish. You can convert the received value per hand to float by also using this.As float does not have the same structure, as the data, we need to convert them. So I calculate first the number of whole degrees analog the your code. Then I add this up with the values of the lowest 4 bits. ((data[0]&0x8)>>3) and it's siblings will be 1, when the corresponding bit is set, and 0, if not.So you get the full precision of the sensor (12 bits). Please note, that for this to work, you should not configure the sensor to less resolution. In that case you would have to ignore the corresponding lowest bits. But the sensor is in 12 bit mode at power up anyway and your code does not configure it otherwise.Note: I'm unsure about the line result |=61440; in the original code. This sets the 4 highest bits of a 16 bit value to 1. I don't see, why this should be correct here, since a normal 16bit integer does only have 1 sign bit. In my understanding the original code would lead to false readings (way off), when reading temperatures below zero. I instead simply multiplied the resulting temperature with -1.The whole code would look like this (I also added the statement for printing out the pure received data as binary, as I requested it in my comment. These statements are currently commented out):"
6725,I don't know that you need all that - just an Arduino and a piezo speaker and a pot if you want to play with the volume.
67493,"This is added 15 months after the OP but there is very little information on this sensor.You have not included your schematics which would be useful. For this setup TI gives you four options: transistor level shifting, isolation, multiple devices to one MCU pin, and common ground with high-side signal. Kevin Darrah uses the transistor level shifting method in his videos. Please refer to the TI datasheet for connections, pages 3 and 21 are relevant in setting that up. There is also this sample code supplied with a video that shows setup using the comparator. NOTE: Ensure you do not have your sensor reverse biased or it will not work and may wreck it. Diodes are a good idea here.Try commenting this out:}I found this sensor gives very low pulse readings if you have something setup incorrectly which will come out around -50C and this line may be causing it to read a fail. If that is the case you will need to rewrite the getTemperature() function, possibly using the comparator method supplied by TI which will require you to rewire, see their training code which includes a video. TI notes the first couple of readings may be incorrect. In my code I have my function perform several throwaway tests before spitting out a reading.TL;DR If you use the TI comparator method, you can use the digital pins for power instead of the +5VDC like they do but use a diode (needed also for multiple sensors) to isolate the sensor to prevent reverse bias. If you do this you can shut the sensor off by switching it to INPUT but be aware, OUTPUT mode goes to ground by default which can cause reverse bias and fry your sensor. Use digitalWrite(pin,HIGH) prior to switching to OUTPUT to change default behaviour to +5V rather than GND (true, the diode should protect you here but adding this line is necessary anyway so do it in this order, safety first). I needed multiple sensors in my build so this is what I found, I used the Arduino-based comparator method quite successfully.I don't have the necessary components to connect with transistor level shifting and actually test this at the moment but you could try this code if you want. I trimmed it down, eliminated most of the ESP8266 stuff you weren't using anyway and modified the getTemperature function to resemble what I have working right now."
68437,
68471,I added int btnPress which gets set on each button press.  Then an if statement runs according to btnPress number.  Thanks jsotola for the point in the right direction!
68873,"You don't want to stop the loop! You want it to run fast and often. Eventually you want it to not change the current state of a LED, but in your case, I rather do not see enough defined states of LEDs.I want to first ON LED1 then ON LED2 then OFF LED1""if then means an amount of time, remember that loop runs fast and does not take time by itself. You will have to notice the starting point in time and compare that with the current time and your desired intervals. (And you do not mention what should happen to LED2 after the second then )This code contains a couple of guesses about states you did not mention, and a slightly different behavior (sorry), but I hope you get an idea...  "
69026,"I see two issues with this program. The first one has already been
pointed out by Majenko in a comment: you are doing too much floating
point calculations. The second has to do with the way your Phasor
manages the time.If you take a look at the Blink Without Delay Arduino tutorial, you
will see something along these lines:In this code, interval is the minimum time between toggles. Whenever
the program gets a little bit late and currentMillis - previousMillis
is strictly larger than interval, this extra time is lost and the
program will be late for all the subsequent LED toggles. If instead of
the minimum you are interested in the average time between toggles,
then you should write:Now, previousMillis is no more the time when the last toggle was
performed, it is the time when the last toggle was scheduled. With
this version you can still have some jitter, but at least the average
frequency should be right. If the program is so busy that it can get
late by a full period, then it would be better to replace the if by a
while, in order to catch up all the missed periods.Your Phasor::process() method is a little bit more involved than the
tutorial above, yet the lineis going to get you out of schedule for exactly the same reason.That being said, here is my take at your phasor idea, completely
untested:I changed a few things from your implementation:Note that the unit chosen for the phase is the most natural one when
dealing with 16-bit arithmetics. Note also that storing microseconds in
16-bit variables only works for frequencies higher than 15.3 Hz. A
very low frequency phasor (your “LFO” for instance) would need 32-bit
arithmetics."
69476,"You have two issues going on - noise pickup, and a potentiometer with imprecise stops at one or both ends.The pot is the easiest to fix: What are the lowest low reading and highest high reading you can reliably get when you turn it to its stops? Use those in place of '0' and '1023' in your map() function.Improving the noise is only slightly more involved. An exponential average is an easy filter to write and quite effective at quieting noisy data, as long the signal to noise ratio is fairly low. The basic idea is you add only a fraction of each new value and keep (1 - that fraction) of the old average; so if your chosen fraction is 0.1, you only consider 10% each new datum, keeping 90% of the current average. avg = f*avg + (1-f)*new_value The output of this averaging filter can be slow to respond to changes if your fraction is too small, but less effective at quieting noise if your fraction is too large.I usually use .25, or 25% of each new point and 75% of the current average, when I'm just trying to clean up minor noise, which is what you probably have.Here is my 25% averaging filter:As you can see, I do the arithmetic in Fixed Point - just like integer arithmetic, but with an assumed binary point 2 places to the left during the computation. And I choose a fraction that represents ""nicely"" in binary - 1/4 in this case - to keep the arithmetic faster (since multiplication and division can be replaced by shifting).The function just multiplies the current average by 4 and subtracts the old average (effectively multiplying by 3), adds the new value, and divides the sum by 4. (That extra ""+2"" rounds the fractional bits just before we shift them away). The end result is: (3*avg + newData)/4 (== 3/4*avg + 1/4*newData).If you were to only sample the pot every second or two, you could probably observe the delay as the filter falls behind while you turn the pot and catches up when you stop. If you're sampling at 10x/sec or less, you shouldn't be able to notice.Update:You need to add the function xpavg() to your code, and call it each time you read a new pot value (that is ""newdat""), passing it the old average as well. It returns a new average pot value, now less affected by noise. You use that new average value instead of the raw number you just read from the pot, in your hue calculation. As Duncan offered, you can - and I do - initialize the average with a raw value from the pot. You could also start it at zero but it will take a few samples to converge on the current actual pot reading. The downside of using one raw sample to start it is that if that one value is terribly noisy, i.e. way different from the pot reading, it will still take a few samples to converge."
69577,"I think there might be two issues in the engineering garage code. delay() function parameter in both codes is not matched. And another thing might cause problem is""Arduino Serial monitor hardware serial is already connected with another usb-serial converter ic which you are using for code uploading, so you cannot use this serial port for rs-485. So using software serial of Arduino pro-mini is a safe option. Finally you have to connect the software Serial pins with rs-485 converter. I have modified the code a little bit and attached the code herewith.Arduino Mega codeArduino Pro-Mini Code"
69644,"There are multiple issues with your program. The most obvious is that,
if you define a variable multiple times, you end up with mutliple
different variables that share the same name. For example:Another issue I pointed out in the snippet above is that a semicolon by
itself is an empty (i.e. do-nothing) statement. Thus you for loop is
empty.There is no point in defining a constant such as analogPin = A0 if you
don't use it.The value returned by micros() is not an int, it's an
unsigned log.If you store a voltage in volts in an int, you get a very poor
resolution of one volt. You could store in a float, but that would
fill up the memory of your Arduino. I would rather store the raw
readings, and convert to volts only for printing.Serial.println() takes time, and you are doing this during the timed
part of your code, which is probably unintended.Here is a version of your program that may better reflect your
intentions. It takes 512 analog readings, stores them in an array, then
prints them and reports the time taken to do the readings. Then it waits
for one second and repeats the whole thing again.If you really want to run only one iteration of the process, then you
can just replace delay(1000); by exit(0);. Alternatively, move the
body of loop() to the end of setup(), and keep an empty loop()."
69663,"The speed seams to be defined by a an analog write to SpRMotor and SpLMotor. You did that once (with value 170)  in the setup. If you use variables for that (e.g. speedValueL and speedValueR) you can change their values as you need it and write it to the PWM channels on each forward, backward, left or right statement.A short example:"
69785,"@jonas I had a similar problem not quite exceeding the limit.  One item you can do is move the strings to Flash.
<pgmspace.h> there is the definition of PSTR which will place the literal in flash
the patternname, which we normaly just use strcpy, we need to use strcpy_P.
strcpy_P states the string will come from Flashmemory and copy it into SRAM space.  Once it is in SRAM sapce we can maniputate it all we want.
for example:This should have a significant reduction in mem usage."
70083,"Note, this is not an answer to your question, but I like to show some programming improvements, making your sketch  much shorter and easier to maintain.Instead of having all functions one, two, etcetera, use a parameter to pass the number. So you get this: (I couldn't test it as I don't have an Arduino IDE at hand). Also you can use a for loop in the loop function to set the output pins.You can also remove turnOff if you treat it like digit 10 but that is not so clear (or put the implementation of digit to another function and call it from digit and turnoff.To solve your problem, print the values of each pin to the serial monitor. If they are correct, there is a problem in your circuit. If they are incorrect, there is a problem in your sketch. In the latter case, add more print statements until you found the exact problem.UpdateIf the digit function is never called, it means:So check the value of pressVal, also add (lots of) print statements, especiallya after each if and else so you know exactly the flow of your sketch. You will see it's very easy to find the error. If you pinpoint the problem to a digitalRead that is not the expected value, THAN there is high likely a problem with your circuit (a button that is never going to be LOW or HIGH). In that case, you probably forgot a pullup/pulldown resistor."
70949,"The first thing I would try is to get rid of the Arduino core, and program instead at the avr-libc level:Also, use int8_t for all small ints (especially in arrays), and uint16_t for time management if you don't need to handle durations larger than 65,535 time units.Edit: Here is my attempt at translating your code to plain C +
avr-libc. Note that, as I don't know the pinout of the core you are
using (what is pin 6?), I am making one up. I also implemented Michel
Keijzers suggestion about factoring duplicated code into a function,
which I called set_pin(). Completely untested:Compiling with avr-gcc 5.4.0, I get 642 bytes of flash and 31 bytes of
RAM (data + BSS, not counting the stack)."
70967,"Combining this code is all about synchronizing the reading of the sensors with the control sequences that are sent from the Java program. The second program reads the Serial port continuously in the loop method. A better way would be to use a serial interrupt for this. Let me give you an example. My code is written without an IDE so it is just an untested example. But hopefully I did not include errors ;-).I use the first program as a base:EDIT:I changed the code a little bit according to Juraj comments. I also 
commented the `Serial.println' s that had reported the LED 13 state.  "
70970,"The speed of your servo is controlled by the pulswidth of a square wave signal. According to the datascheet of the servo the motor stops on a pulsewith of about 1500 µSec (+- 5 µSec). From 1500 to 900 μSec the motor turns clock wise. And it getting faster with decreasing pulsewidth. From 1500 to 2100 μSec the motor turns counter clock wise. And it getting faster with increasing pulsewidth. Next we have to check whether your shield and the library can handle that values and which value you have to give to the servo[i].write(?) function. I can read cyrillic but I do not understand russian good enough to read the f. manual. So I have to look into the code on GitHub (https://github.com/amperka/Multiservo/blob/master/library/Multiservo ).Et voila: You can define the min and max pulseWidth, that's great. Let's do it:Ah, of cause I have not hte hardware, so I can not test the program. Use it as an example."
70985,This worked! Thanks for the help! <3
71141,
71255,"I found this post, I don't think it will switch between hardware serial and software serial but it certainly works for just software.I'll keep reading to figure out what I've done but if anyone would like to explain, I'd be very appreciative.This is the post I got the method from.https://forum.arduino.cc/index.php?topic=605453.0Thanks"
71369,"You should always comment your code, so that you will know what your code does when you look at it 6 months from now.For beginners, you should not leave out the braces {} from any part of the code as you did in the for loops.Here is your code correctly formatted, followed by a more cleaned up version which may be easier for beginner to follow.Main question is whether the for loops are written as you intended.Also, the use of if {} else { if {}} makes the code listing somewhat convoluted.The second listing shows the if {} else if {} version."
71425,Try using this code:
71522,"Although I can not verify my code, I tried to modify your program. Probably it does not compile and you have to do some corrections. I changed it in a way I would expect it to work and hopefully I understood your intentions. At least we could use this version as a base to elaborate a working one together.EDITThis edit is related to the updated version of your program.If you close the box with a key press you also stop the client with the last line. Please remove the following line from the program."
71618,"I didnt try this method but; when i check the data sheet, i found this code on last page:Here is the pulse counting method i think. So if we are using I2C IC,  we must get pulse datas over it to our MCU and count them. But before this scaling method; we must calibrate loadcells and tare them absolutely. 
And i found a link that pointing i2c with hx711. They used sparkfuns IO expander(communicating via I2C) to fix low io problem and connect loadcells to this expander and how read scalings completely. 
Here is the link: if you can check, maybe find a solution for your problem.
Sparkfun's I2c Expander with Hx711"
71995,"Put the stuff before setup() together, fix any duplicates:Put the stuff in setup() together, fix any duplicatesPut the stuff in loop() together, then check the desired functionality:"
720,"There is no way to change the frequency, however there are other ways of doing what you want to accomplish. I think the best thing to do is stagger the timing of the pings so they don't happen at the same time.Example code, modified by me:
Sources:
"
72078,"The Arduino IDE uses the C and C++ programming languages.  Some string comparison basics using C:In the C programming language, a string can be thought of as an array of 8 bit values.  One way to compare two strings is to compare each 8 bit value and consider the strings different (not equal) upon finding the first not-matching 8 bit value.  Here is an example from programmingsimplified.com: There is a common function called strcmp() which can be used instead.  Here is another example from the same web page which uses strcmp():Note that in both cases the array of strings is assumed to end with a NULL or zero value byte.  If you do not wish to follow this format you can use an alternate version of the function called strncmp() where the number of characters to be compared is passed along with pointers to the 2 strings.Some string comparison options using C++:There are C++ ways to compare 2 strings which make coding Arduino Sketches easier.  But C++ string manipulation usually requires more RAM.  And RAM is usually in short supply on inexpensive embedded processors.As the code in the question is written using type String we can explore that approach. And, as there is some concern the strings may have unexpected trailing characters, we will continue to check only the necessary number of characters. In this slightly modified code example from geeksforgeeks.org string s1 is compared with string s2.  But only the first 6 characters are compared:The number 6 was chosen because ""yellow"" contains 6 printable characters.  In this way, we can avoid the uncertainty of what character(s) follow the characters that make up ""yellow"" as received from the serial port."
72364,"My version of the data sheet has a flowchart (Figure 10) for doing a ""read-modify-write"".  In there is a clue - there has to be a dummy read before the actual read is done.  Here is my function for plotting a pixel, which requires a read-modify-write to add a pixel to the existing data.  It's not clear dummy read is needed before every byte read, or just on the first of a sequence of bytes, but that's easy enough to test.This is woefully inefficient for plotting one pixel, but it's a start.Edit: I've subsequently confirmed that only 1 byte of dummy read is needed, even if the reads are stopped/restarted.  As long as you're only doing RAM reads, no further dummy reads are needed."
72589,"I tested your first code line and it outputs a right aligned 136 without colon at my display. (Said I have only a colon at the middle and no decimal points)The 5 at the fist digit (and also the A at your third code line) must have been set somewhere beforehand. The function does not change the unused digit, so it will stay whatever you set it to beforehand (Even from before the last reset of the Arduino. The display doesn't reset with the Arduino). You can set the segments for that digit to zero (or set all segments to zero, to clear the complete display) before you show the decimal number.About the colon: Here it is important on which position you start the printing of the number. The colon/decimal point bitmask, that you provide the function with, is seen from the starting position, that you provide. The middle colon of a 4 digit display is wired to the second digit. When providing 1 as the starting position, you start with the second digit. Thus the colon bitmask must set the most significant (""first"") bit, to enable the middle colon, since it belongs to the first digit, that is processed by the function. Meaning:The 0x80 >> 1 is just a different representation of your binary number. 0x80 is the hexadecimal form of the binary 0b10000000. The >> operator shifts the byte to the right, here by one digit. Thus:So the code, that you found, enables the colon/decimal point at the second digit.tell me an easier way to construct a timeEasier it relative. I used such a display in a project to display a time and used two showNumberDecEx() calls; one for the minutes and one for the seconds:Having directly minutes and seconds may make it easier for you. About the no-leading-zeros: Since the library always prints left to right, you need to handle that by yourself. But that is rather easy. One if statement to check, if the minutes are greater than 9 or not. Depending on that you set the position to 0 or 1.You could put that into a function, so that you don't have to write this code multiple times.Note: For my last code snippet to work, you should first clear the display (or optionally only the first digit), so that no number from before will be displayed there."
72652,See if I understand this correctly: For a given time period you want to find the peak. Hope this helps!! 
72696,all of your problem can be solved through a simple trick ... Just follow it...follow below code ... it works with LORA AND SD both togetheruse this trick ... your system will work perfectly ...
72757,"I installed a library from within the IDE as StarCat suggested.https://github.com/Makuna/RtcI am able to get and use the time, and the LED output works."
73263,"I have no access to a compiler, so there might be errors.EditPlease note, that this code only works if you connect the software serial pins D2, D3 to the respective RX and TX pins on the Shield. You have to bend the pins (P0-P3) of the shield to disconnect them from the Arduino. Then you have to connect D2 and D3 to P0 and P1. This is described in step 1 of the instructables you linked to in the question. See the picture at the end of Step 1. https://www.instructables.com/id/ESP8266-ESP-12E-UART-Wireless-WIFI-Shield-TTL-Conv/ "
74704,"Welcome to the I forgot to empty my buffer char club (I lost some days finding a simlar problem)but you have no (for me) visible routine to empty received_chars
Do this either by setting or orafter you used the buffer content. By using you just set the pointer and then start to write, as a safequard you should first reset the end terminator and then start to write. This is probably the reason you see characters even if no key is pressed due to a still ""full"" charbuffer.To prevent heap corruption define your received_chars as a fixed arraybefore setup:if you use malloc you have to use free, but doing that with a lot of dynamic data causes heap fracturing -> crash in the endEDIT
The program does now the following You do not need strtok here as it deletes chars I use a modified substring routne for char arrays.
Here is the code working as described above:If you could describe what you really want in the end I'm sure we can help with some basic routines."
74718,"The problem was that, in the variables I wanted to keep (i.e.: text in the code below), I was assigning the value of a pointer to the parsed string which is reused the next time a command is found, rather than copying the string.Fixed code below - see comment Fig#1. There's also a second fix, although that wasn't causing the problem behavior.Thanks to Codebreaker007 for the help."
74785,"I read heap and stack memory are facing each other and if heap or stack gets full and reachs another strange things happen.Indeed they do. And such things can be a pain to track down.So i am wondering if can we use ESP.getFreeHeap() to get free heap and conclude usage of stack.No, you can't.  The ""free"" amount of heap does not equate to the top address of heap. Heap can (and generally does) have holes in it. The ""free"" space is the sum of all those holes plus any extra ""heap reserved"" space above the highest heap entry.To get the current stack usage you need to know two things:Item 1 will be a fixed value, though what that value is I have no clue, but some reading will surely give you that value.Item 2 can be obtained by allocating a local variable in a function and getting the address of that variable.If all you care about is the change in stack imposed by your code you can record the ""starting"" stack point and use that in point 1.  For example:Then you can use that to get the current stack size compared to the start of your program:one tiny question here: can Serial.println(""asd asd"") cause memory fragmentation?No.  Use of String and other dynamic allocation is what causes memory fragmentation."
75014,"Thanks for the help, this code is closer to what I was looking for. This is for a water level pump, when the trigger is high it turns on, when the water rises the trigger goes low and stays on during the timer as a failsafe and then turns off with when the elapsed time is greater than the set time and also not in my code it turns off with a additional trigger. Here is my working code."
75259,"ADC doesn't show the same value againYou are not reading the ADC correctly, so ADC_READ() can return
anything. See the comments in the code:The big issue is avrdata not being initialized. Its initial value is
whatever was left there (in the stack or some CPU registers) by the code
that ran before. The value returned by the function is then hard to
predict and depends on what the rest of the program is doing.The other remarks I left in the comments are not that problematic,
although they are revealing of some lack of attention to detail. Same
for some badly named variables. Here is how I would implement this
function:"
75312,Here is some untested code that uses a non-blocking timer to flash the leds.
75454,So here is code to get you started:the + method is replaced byconverting numeric values to chars:itoa initilizes a char array so we need the helper array:to convert float we useto convert chars back to int useto convert chars back to floats useA working IndexOf for char arrays:To compare char arrays you should look into the strcmp function and if you want to checkthe first n char tomatchyou use:Hope this comprehensive intro to char arrays helps you for your current and future projects. How to find out - convert to char arrays and if its runnibg stable that was it. Before that conversion you can never rule out String class as culprit.
75610,"Your ""working logic"" is quite unlogic:In sender you define a char array:char leds[6] = {'H','0','0','0','0','F'}; which should beHere each '0' represents a led as can be seen in subroutine Boton Enviar
Instead of assigning a state to each position 0/1 so leds[2]='1' would be e.g. led blue ON you write a number to it (example walk through for blue):so if blue and and you send (if using the terminator)On the receiver side the following happens:so your led2 looks like Solution define array as follows:The light logic should go for the space a value is and not the value:To get the mix of different logics apart place both progs in an editor (eg. notepad++) side by side and look for differences in the logic. There is more than one error in the programs, fix them as proposed and it wll work (Read the comments in my code for further details).
EDIT 
The OP had still problems with his code. I tookthe example and let it run hardware based on two UNOs, it worked but SoftwareSerial is very bad. No problem on the hardware with AltSoftSerial.h. In TinkerCAD no chance, the moment I switched to HW-Serial it worked like a charm, so here is the refined code for SENDER:and the code for RECEIVER:Working code looks like this - change to HW-Serial 0(RX), 1(TX) to 1(TX), 0(RX):

So as a result DO NOT USE SoftwareSerial.h in TinkerCAD - its not working at the moment, use HW serial for communication examples or you will get crazy if working code suddenly outputs garbagge. When using real hardware use AltSoftSerial (full duplex mode). If you plan to use your design with real hardware use resistors for the LEDs (search for resistor calculator LED) as different colored leds need different resistor values."
75768,"Kind of an answer. After the advise from @Kwasmich I have converted to aes-256-gcm.
Upgraded to UTF-8 thanks to Edgar Bonet


Based mostly on GCMTest example comming with Arduino Cryptograhy libraries:-----------------------------------------------
Shared between Encryption and decrition
First need to define parts which will not change:Now create a global buffer (easier to understand then pointers)
EncrytpionIt is important to clear memory of any ciphering before doing one:Decryption-----------------------------------------------
full example:simple key generator in PHP:"
75937,"There's lots of misunderstandings here, but here's the gist of it.What you want to do is a perfect application of an Arduino. No need to buy a coulomb counter, instead, you should make one with your Arduino.I would then add this amp/second value to a variable. First correction, it's an amp*second, NOT an amp/second. You are multiplying amps by the number of seconds that current value existed. amp*seconds / 3600 = amp*hours. Read about that here: https://en.wikipedia.org/wiki/Ampere_hour. Multiply that by the voltage over that same time period and you've got amps*hours*volts = (amps*volts)*hours = Watts*hours = units of energy! Remember, your house electricity it purchased in units of kilowatt hours, which is kilowatts*hours, or kWhr. And in engineering units a joule is  the standard unit of energy, and it is simply Watts*seconds. So, you can convert kWhr to joules like this, where units are in square brackets [].So, 1 kWhr x 1000 x 3600 = 3600000 Joules = 3600kJI would also increment another variable for each second.That doesn't make any sense. Don't do that. You've already captured the seconds by adding your new bit of amps*seconds to your old sum of it. DO account for voltage too! What you're really after is energy, which can be expressed in units of joules or kWhr, as already described above.Is it too much a stretch to poll the amperage every second and call it amp*second? (my corrections in bold)No, absolutely not! That's exactly what an amp*second is! It's the current, amps, times the number of seconds that current existed. That's a coulomb counter!How can I make this more accurate? This is the part where the engineer and programmer (you) determines the quality of the result. The merits of trapezoidal integration can be argued, and it's probably not as important as I originally made it sound, but it is super easy to implement, so why not!? Also, it is most important when: Here's a full coulomb counter example in code. You just need to implement a few functions to read samples and do calibrations is all. I'm borrowing the timestamp-based cooperative multitasking part of this code from my answer about cooperative multitasking here, so go check it out for more information on that. As written, this code compiles, but I haven't wired anything up or tested it. Here's the compilation output:Sketch uses 3750 bytes (12%) of program storage space. Maximum is 30720 bytes.
  Global variables use 262 bytes (12%) of dynamic memory, leaving 1786 bytes for local variables. Maximum is 2048 bytes.coulomb_counter.ino:Jump to the bottom for the setup() and loop() functions. They are both really short."
76182,"Edgar beat me to it by a few seconds, but my answer is pretty much the same as his, so read that first.  I will however add a few extra notes and pointers:Here's my variant of the same code. Note the colon and space in the format that is used to add more formatting to the output (this could be enhanced by adding a % before any format characters as printf does). I also like to use a separate pointer to iterate over the format string instead so that the original start pointer is still available if I should ever want it.Also note the difference between c and i: use c to print a letter from a char, and i to print the number in a char instead."
76183,"I recommend to use printf if you don't need float support in printf. This code produces a little smaller compiled code then the one in Majenko's answer and has the full power of the printf except of float.With StreamLib you can of course print float with normal single print function for floats, the same as for Serial or network Client, with second parameter for the number of decimal places.If you want to create a formatted C-string you can use the CStringBuilder of the StreamLib. It too builds the string with print functions and has 'printf' too."
76241,"As @Majenko suggested, i created solution with pulse counter.Here is working code, based on espressif PCNT Example. Arduino studio, Olimex ESP32-POE board. Each water meter uses separate pulse counter unit. Now I am testing this code and after several days i will accept answer if all works like i want :) "
76256,"After a night of continuous tests i figure out how to control correctly the LED strip using the following : 1- To apply any RGB value (a pixel) you have to send a compete frame of data to all the pixels. In my strip i have 12 pixels ,so to turn for example the first pixel into red , i have to send 11 zero pixels then the red pixel.2- The delay and timing as mentioned above by @Majenko was the key, you just set the data and pulse the clk , that easy.3- the protocol used isn't SPI or I2C , it's a custom protocol based on a custom driver developed by a private company (not a driver for general use or market , it was dev for a big wall lighting project)."
76380,@ Duncan Cthink i have a solution not sure if it's your way but it does work so not bad for a newbie lol
76410,"There is only one rule to follow, really:Never read a variable before writing a defined value to it.You don't need to write explicitly into a variable, because the C++ language distinguishes between two kinds of variables:Static variables are defined outside any function or method, or with the keyword static.Automatic variables are all others.Example:All static variables are initialized exactly one time, before main() is called. Or in the case of Arduino, before setup() or any other method or function is called.Oh, another quite important rule: Know, what you are doing, don't guess, be sure.You might need to read the standard, or at least some good book.If you use some rare feature, make it explicit or comment.Additional notes:The Arduino uses C++. This is a really different language than C.You can think of main() as:"
77181,"The main issue with your code is the formatting. It seems that you have managed to 'comment out' some of the necessary { or } for some of the functions and/or if/else blocks, hence the failure to compile.e.g.The } at the end of that particular line is the closing brace for the void setup() function... but because it's after the // for the comment, the compiler won't see it, so it is effectively missing.This code should now compile on your system... once all the missing { and } were un-commented.In future, when posting a question, please also list WHICH libraries you are using. e.g. there is more than one LiquidCrystal_I2C library... and probably only one right one. Also, that will only be part of the error message. Give the entire message - as the end bit isn't of much use!"
77351,Finally the HTTP Get request with Arduino Uno + ESP8266 Wifi shield which is working is below:// This is a demo example using a public http server for testing both GET and POST requestsOutput:But one issue I am facing is after few call the HTTP invocation is getting stopped probably memory being full. Will check this.
77364,"There is a bug on the library example webclient.ino on getHttpPacket() and getHttpResponse() that it didn't free the memory correctly, causing memory leak. I've updated the code on github repo.Specifically on your getHttpPacket(), here is the corrected code:If you have further issue regarding the library, you can raise an ""issue"" on the github, and I will take a look."
77525,I used the FastLed library and it works now. For some reason the adafruit library only works when I am not using the WiFi. This code works:
77629,"Simple codeAssuming that you are mentioning a squrewave this code mesures the time that squrewave pulse stays in HIGH and prints out in computer serial monitor.You should send the signal to digital pin 7 (or put any pin you won't modify code int pin = 7;) 5 V HIGH and 0 V LOW.The time unit measuring in here is in microseconds.
If you won't to measure low then pulseIn(pin, LOW);I took the example from Arduino official site you can refer more herehttps://www.arduino.cc/reference/en/language/functions/advanced-io/pulsein/Remember this is the basic example there are other good methods than this...Analog wave is bit too complex."
777,"You can use the functions provided AVRGCC: Monitoring Stack UsageThe function was intended to check the stack usage but what it reports is the actual RAM that has never been used (during execution). It does so by ""painting"" (filling) the RAM with a known value (0xC5), and then checking the RAM area counting how many bytes have still the same initial value.
The report will show the RAM that has not been used (minimum free RAM) and therefor you can calculate the max RAM that has been used (Total RAM - reported RAM).There are two functions:StackPaint is executed automatically during initialization and ""paints"" the RAM with the value 0xC5 (can be changed if needed).StackCount can be called at any point to count the RAM that hasn't been used.Here is an example of usage. Doesn't do much but is intended to show how to use the functions."
77972,"I changed it, so it at least compiles."
78070,"The if statements (plural) you posted on GitHub are a lot different to the one you posted above. They contain a lot of of print commands to the LCD, so I think this is what is slowing your code down. It's a fair effort at nicely formatting the output on the display, but is rather convoluted.Here is a simplified version which writes to the LCD as little as possible (2 cursor moves and 2 prints). The formatting of the string is done in Arduino memory before sending it out to the LCD as one complete string.I couldn't understand your variable names, so I've renamed them.I moved the analogReadResolution(12) from loop() to setup() for a slight performance gain.I've grouped the analogue reads together to give a smaller sampling window. Since it's for a control loop, these values should ideally be sampled at exactly the same time and synchronised to a clock (e.g. in hardware).I created a new function for displaying the data on the LCD. It's good practice to break the code down into smaller functional blocks."
78161,"i found itit is thetemp = register_array[packet->local_start_address + i]; // get the data
in the ccp fileregister_array[packet->local_start_address + i]its pointing to the wrong location... register_array??supersized no one has noticed this as long as the simple modbus master for adruino
has been used ?or i have a bad CPP file ?i have temp corrected this by replacing withworks (0 = off / 255 = on)modbus_construct(&packets[PACKET1], 1, 15, 1, 8, 0); // 1 thru 8 = offmodbus_construct(&packets[PACKET2], 1, 15, 1, 8, 255); // 1 thru 8 = on"
78269,"You method sound a bit more complicated that it needs to. What I would do is have the button switch between three colors, and have the potentiometer change the brightness of the currently selected color.For example, when first starting up, the red led is selected. Turning the potentiometer changes the brightness of the red led (in real time). Let's say you turn it 50%, so the red led is at 50% brightness. When you're happy with that, you press the button, and now green is selected. (Since the potentiometer is still at 50% from the red, the green led will immediately turn on at 50% brightness.) You can then turn the pot to change the brightness of the green led. Let's say you turn it all the way of to 0%. Then press the button to select the blue led. Turn it to 100% and the combined color would be a dark purple. Press the button again to select red again.Here is some proof of concept code:PS I left out the pinMode stuff in the setup.PPS make sure the led leads are connected to PWM pin on the Arduino (they have a ~ next to them on the PCB)."
78373,"Ok, I am using WS2812B with nodemcu and Fastled. Now all folks out there reading this need not worry about voltages if your led is not blinking at all. It was not working at D0, it worked for me when I changed to D1, I am not aware of issue though. Need to check that.
I did not use any other component and connected directly to nodemcu.
Below is the simple code for first led to blink."
78395,The code seems to have a few missing lines for logic. Here's a corrected version from my understanding.
78405,"The objective of the code is not clear. It seems the idea is to repeatedly blink 3 LEDs, connected on pins 5,6 and 7. To do so, the code needs slight modification-Also, since you wanted to know why the LEDs stay ON continuously with your code-
This is because there is no delay statement after any of the digitalWrite-LOW statements. If there's no delay, the LEDs may turn off for a fraction of a millisecond, which won't be noticeable."
78647,"It's easier to follow if you indent it properly. I'll do that, and add comments as I go:So you see it receives data through serial and stores it, byte by byte, in input until it receives \n at which point it looks to see if it starts with SEND, then effectively ""cuts off"" the SEND by only considering everything after the SEND. Then it slices the remainder of the string up by looking for the next space each time and convert each portion to an integer which it stores in an array.It then sends that array."
78983,Used like this
79160,"I don't have a normal Nano on a ATTiny84 on hand at this moment.For our purposes, I'm using the ATTiny44, which is essentially what you have, only with smaller memories.  The Nano that I'm using is Nano Clone that I have retrofitted with a ATMega328PB rather than the regular 328P.  To make matters slightly more confusing it is running the regular UNO (rather than NANO) bootloader.  The bootloader lies about the chip signature (saying it is 328P) and uses the UNO baudrate 115200 rather than the Nano's 57600.  So you will see in my screenshots/examples and menu selections ""UNO"" rather than ""Nano"", ""328PB"" rather than ""328P"", and ""ATTiny44"" rather than ""ATTiny84.""These differences are inconsequential.Remove all external circuitry from your Nano.  All means ALL.  That includes
whatever you did to defeat reset as well.Choose Arduino Nano from the Tools/Boards menu.
Choose your Arduino Nano's port from the Tools/Port menu.Upload the following sketch:The LED should blink rapidly for 6 seconds and then remain off indefinitely.The Nano's optiboot bootloader blinks the builtin pin 13 LED three times, but it is a very short event and maybe difficult to distinguish form SPI clock action (which also happens on pin 13).  By contrast, it's hard to miss the blinking that this code produces.Open (or Reopen) the serial monitor and see that it does this again.  Close and
Reopen the serial monitor however many times you want until you feel
comfortable that you're seeing clear indication of the board having reset.Unplug your board and install your choice of reset defeating circuitry.The typical suggestion is a 10uF cap between Arduino Nano RESET and adjacent
GND.  Make sure you don't have your electrolytic cap backwards.I frequently use a hard pullup of about 60 Ohms.Plug the board back in and you should see the LED Blink rapidly for the
power-on (not DTR) reset.Open (or Reopen) the serial monitor and see that the LED remains OFF.
Reopen the serial monitor however many times and see that the LED stays OFF.NOTE: At time of writing the current IDE version is 1.8.13.  Though, everything
said here should be find for old and likely future IDE/arduinoisp.ino releases.In the IDE, from menu File/Examples/11.ArduinoISP, choose the ArduinoISP
sketch.  In its current from in IDE 1.8.13 it requires no modifications for a factory-fresh ATTiny84(A) (or pretty much any AVR), that is with its default configuration fuse values.Break the RESET leg of whatever circuit you chose for defeating DTR reset.Upload the ArduinoISP sketch.You should see that the LED does NOT blink rapidly for 6 seconds as it had previously.
This should indicate that you have successfully uploaded the arduinoisp.ino sketch.Reconnect RESET leg of whatever circuit you chose for defeating DTR reset.Open a new empty sketch.Choose your target chip's settings from the Boards menu.  That is your D.
Mellis ATTiny84 ""board"" should be selected.  Or more generally: any compatible ""board"" from any board support package that supports whatever AVR you want to do this with.Verify that your Arduino Nano's port is still selected in Tools/Port menu.From the Tools/Programmer select ""Arduino as ISP"".  Barring some internationalization effort, it should say exactly that. It should NOT say ""ArduinoISP"" or ""ArduinoISP.org"".  Yes, the Arduino people are usually BAD at picking names.Choose ""Upload using programmer"".You should see a signature check error like this:You may need to turn on ""Verbose"" for uploading in preferences.Because you have not wired anything to the SPI pins the returned device
signature will be pure junk.  The important thing here is you got a device
signature failure and NOT a sync error.  A sync error represents failure of avrdude to talk to the arduinoisp.ino sketch's implementation of the STK500v1 programming protocol.  What you're seeing here is successful STK500v1 communication (to arduinoiso.ino) reporting a perfectly reasonable failure to identify the chip (that you have not even attached yet).Unplug your Nano and wire AVR to it.  With the exception of your attempt to use VIN, I didn't notice anything wrong with your wiring.The ATTiny84 should be wired as:Or more broadly for any ISP supporting AVR tiny/mega:You may want to add a pull-up resistor from the target AVR's RESET to its VCC.  This should be not needed for use with arduinoisp.ino sketch, but you might want it for running on the breadboard.  You may also want to add a decoupling cap between your AVR's VCCs and GND.  I've never needed this for just programming on solderless breadboard though.I don't typically use breadboard power rails when programming AVR devices with single VCC an GND pins.Generally keep your connection short in any case.  They should not be longer than 20 cm really, and can usually be less than half that. Keep them together with the GND where possible. Your SCK signal should probably receive the most care.  I don't see anything wrong with the length of your connections.Plug your Nano (and AVR wired to it) back into USB.Make sure you power light hasn't gone out on the Nano, that it doesn't drop off the USB bus, and nothing feels hot to the touch.  That nothing smells odd.Choose whatever you want to upload.  An empty sketch is fine for testing uploading.Verify that Tools/Port is the port of the Nano.
Verify that the programmer is still ""Arduino as ISP"".
Verify that the ""board"" is still whatever it should be for your target chip (not the Nano).Choose ""Upload using Programmer"".You should get a successful output, that would look something like:The above was generated using the process described with my slightly different setup.With everything being correct in the IDE, if you get SYNC error now you
probably have a wiring issue that's causing the Nano to fail, interfering with its ability to execute the stk500v1 implementation.  This was part of the thinking behind pointing out your VIN connection in the original post:"
79317,"You need to place the decleration outside of your setup() function. In other words, you need to move the following 3 lines and place then above your setup() function:Your code should look like this:"
79570,"One tip to prevent these kind of error: next time align the { and } and you see the error very fast:As you can see char s_name needs to be be declared in the front of the method as you need it in the second line, so you get the following code that compiles:Now you also can see that you process the s_num variable even if there is not a new value from the serial class, so you should put it probably inside, getting:The last statement s_num=10; does not anything.Now, to greatly reduce your code, all digits perform more or less the same code. You can combine this by calculating the delay time (0 -> 100, 9 -> 1000), and you get the following code:By subtracting '0' from a character digit ('0' to '9'), you get its value."
79740,"This is not a solution, however, by rafactoring it makes your sketch more maintainable as duplicated code is removed:Instead of the state integer, it's more clear to use an enumeration and use a switch statement."
79894,Thanks for all your help. I managed to log data in the SD card including date and time. The new code is the following:
80158,"The problem is that you check inside the two functions Sparkle and GreenYellow for another serial byte. Then when it's unequal, you move back to the while loop where you wait for the next serial byte, but I think you need to use the same one to decide to go to the correct function instead of waiting for a next serial byte.Probably the easiest is to not read serial in the while loop but check the incomingByte global variable  (containing the last read byte, and e.g. 1 initially), and ONLY in the two functions set that global variable. Then, when returning to the while loop, you check that global variable to jump to the correct function.So you make a setup function that sets the global variable to 1 (or you do it in the initialization itself):Then, in the loop function, you use:If you don't want to start in either one, then use 3 values (0, 1, 2), and ONLY in the loop function read the Serial byte, but don't read it in the functions.
This way it's a bit more cleaner as it separates the LED functionality with the Serial functionality.The result (using the last method), results in the following code (compiles, not checked).Comments:Used an enumeration for the modeSplit functionality of serial data, processing the mode and RGB routinesI added some initialization lines (i.e. constants) to make it compile."
80228,"I would avoid having multiple .ino files, because of the issues raised
in the other answers. If you want to split your code into multiple
files, the scheme that works reliably is to have:Within the .h/.cpp pair, the .h file declares everything the compiler
needs for understanding code that uses the feature: type definitions
(including classes) and function prototypes. The .cpp file holds the
actual implementation.Applying this scheme to your case would give:my-sketch.ino (actually, with the name of the containing folder):angles.h:angles.cpp:Note that including <Arduino.h> is only useful if the code uses the
Arduino core API. Otherwise you can omit it. The main sketch does not
need to include <Arduino.h> because it is implicitly included in the
.ino file by the Arduino IDE. There is no such implicit inclusion when
the IDE processes .cpp files."
80289,"I've upvoted @Edgar Bonet's answer, because it is correct.I want to add some more examples and explanations though.In C and C++, you can NOT have code logic outside of functions. The global context outside of functions is intended for declarations, definitions, and some initializations/constructors only. All code logic must be inside of a function. Code logic includes post-construction variable assignments, if statements, etc.Therefore, you can NOT do the following, since it attempts to do non-initializing assignments outside of all function scopes.Notice also that in C++ (which Arduino is), you don't need to use typedef for structs either, so I've removed that from the struct definition. I'm also using the stdint.h types, which are considered safer and ""best practice"" for data types, as they specify the exact type size in bits. Use uint8_t in place of unsigned char, uint32_t instead of the Arduino Uno's unsigned long, and uint16_t instead of the Arduino Uno's unsigned int. Also, in C++ in particular, constexpr or enums are preferred over #define to set variable constants.You CAN, however, have variable initializations outside of functions, so long as they occur at the same time as construction, so this is perfectly valid:Or, you can just move your reassignments into a function, such as setup():Here's a full, runnable example on a PC, with printing to verify the contents of the struct were changed:Run it online yourself: https://onlinegdb.com/MnEOQgCQT.Sample output:"
8036,"First of all, you have a while(true) in your loop, that makes no sense. The loop already loops for ever.You are also changing the number every time the loop() is run, making it flicker. If you follow the Arduino library example, you can see they only use setNumber every so often and use refreshDisplay every time the code runs through the loop().Also, you didn't setBrightness, which shouldn't be a problem since the library probably sets a default value, but I'd advise on including it in your code to eliminate unforeseen problems.Try this code and let me know if it works:"
80451,You are supposed to use a filter library on top of the output of the gyro as well as the accelerometer data (both is used!) to get angles ... https://www.arduinolibraries.info/libraries/madgwickHere is a working example that prints the pitch of the sensor from +90 to -90 degrees:
80545,"I think I found a workaround. It relies on the fact that on simple program architectures such as the one used on most microcontrollers, the heap grows upwards while the stack grows backwards.The method checks, on each attempt to allocate memory, whether the newly allocated block would reach into the call stack (+ some safety margin). If so, the pointer is freed again and null is returned.I tried with this a bit more demanding test, and it seems to work as expected (allocates a bunch of blocks until it fails at around 91k, then restarts)"
80606,So like this? And also what kind of serial speeds do I use? @Majenko This is the sender:And this is the receiver:
80658,"In addition to some of the above comments;Your Nano may not support the watchdog. Please check This post on the Arduino forumIf you are looking for ""There are many small programs..."" I'll just post the functions I use for getting free memory, heap and stack information below."
80731,"The best way to handle this exception is to identify what's using so much space on the stack and rewrite your code to avoid it.The three most common ways you'd use too much stack space are:Local variables are stored on the stack, so a large array of them will use up a lot of stack space.Each time a function recurses, its return address and its arguments and local variables are all stored on the stack. If it recurses too many times it will use more storage than is allocated to the stack.when you overrun an array on the stack you'll probably overwrite other variables and corrupt their values. Do it enough and you'll hit the stack guard. Remember that C strings (char arrays and pointers) need n+1 characters to store a string of length n because they're terminated with an extra null '\0' character.If you're using recursive functions, look at ways to limit the recursion or use tail recursion which the compiler may be able to optimize to avoid using excessive stack space.If you're using large variables, think about why and rewrite your code to be able to use smaller variables. For instance, if you're reading a large file, try to process it a line at a time rather than reading the entire file into memory. If you're downloading large JSON from a web server, try using a streaming JSON parser rather than downloading the entire thing and then processing it.A mistake in your code will be the hardest to figure out, given that it's a mistake. Be careful about pointers and memory allocation. Although memory is allocated from the heap and not the stack, if it's overwritten or reused after it's been freed using it as a pointer can still cause stack corruption. Also be careful to not return pointers to local variables inside functions:can also lead to stack corruption as the space occupied by the variable will no longer be reserved for it and may be used by something else."
81112,"I do not understand, how you initialize the DHT sensor object.
(I wonder why this compiles at all.)Your way:I would use:Don't forget to start the DHT object with:Now use the dht object instad of the DHT class.You did not specify what libraries you have used. But I tried all DHT libs I could find and none of them compiled with your code without errors.The following code compiles on my IDE for an arduino UNO having olivers ug8lib and adafruits DHT sensor library installed. BTW: You even did not mention the Arduino/ESP you used. So I guess it is an UNO.I do not have the time to assemble the hardware to try it.
So I can say it compiles, but I can not say it works.EDIT:Now I found adidax ""DHT11 lib"". your code compiles with this library. But you forgott to read the values from the sensor, before you read them from the variables.The following line is missing:"
81271,"I'm afraid your test program doesn't work as you intended. I tested it with a T4.1 without RAM soldered on and it gives the same result as in your question.Here a simple test program showing the effect. It always switches the LED on, even without external RAM soldered on the board.Here the disassembly of the setup function. It clearly shows that the processor tries to store 42 in the (non existing) external RAM and reads it back from there. Obviously the read back value comes from the cache line.
(comments added by me)"
81461,"Firmata.sendString does not send anything to the client in two cases:In this case, while you're sending methodName, you're manually assigning the terminator to the string; and the sender works:The only thing necessary to do to solve this argument problem is making each char variable end with a null terminator. Here you can see the solved code:"
81464,One way is passing external buffer to readLine() to fill:Big NO-NO is doing something like:Another NO-NO:
81975,%d expects a signed int. %u expects an unsigned int. Insert the l modifier to expect a long in each of those cases. So you need a format code of %lu to print a uint32_t.The following code:prints this:
82026,"With the help of Majenko and jsotola in the comments, I've got it fixed! It was the text I was displaying in the Serial Monitor that was slowing the display down. Here is the updated program that works:I'm leaving the program modifications here in case anyone else gets the same problem."
82124,
8278,"The library provides an example for a server.Here's what it looks like:Using the WizFiServer class, it seems to assign a WizFiClient instance to each HTTP socket connection. It can then call clientName.write( /* Data to be sent to client */ ); and clientName.read(); to get values.Once it is done with the client, it can free up resources by calling clientName.disconnect();."
83305,Found the Adafruit NeoPixel is the reason for the problem (or the way it is implemented above is not the best).Solved with the fastLED library as below:
83308,"So, I got carried away with my exams and I forgot to come back with an update and a solution. To take it short, I added a new source of power to the circuit and I am only turning the servo on when needed to rotate, then turn it off again. The code can be seen below:Also, here would be the layout of my final circuit:Basically what I wanted to achieve was sending and displaying the current temperature from an Arduino device to an Android one, then allow the user to adjust the temperature, simulating this with a servo commanded over Bluetooth. For those interested in the Android part as well (and the whole project actually), here is the link to the project repository on GitHub. The Android part is written with C# in the Xamarin Android framework. I hope this helps anyone landing here, good luck! :D"
83327,i searched in stack exchange Arduino but i dint get answer so i posted but when i searched in stack over flow i got link this is my final code
83936,I've got I2C to work reliability between Arduinos with different byte sizes. I have copied the test code below. Note that there is separate code for sending and receiving. It may need to be tweaked but contains the basic idea.One (or more) Arduinos sends to main I2C controller:Sender Code:Receiving Code:
84126,Heres a little sketch you can try.  It uses timing to accomplish the different servo speeds.  It won't give you the exact servo travel each loop but it sounds like you might not mind if it randomly is off by a few degrees each loop.
84423,"so I think I got it, the problem was that on a fail wire.read() returns an int -1
when that gets converted to a unint16 its a big number then it gets left shifted and overflowsthe solution was:This contains some extra error handling I added, but will leave in such as:I didn't do error handling as I would need to rewrite the whole library, and for my application repeating the last reading is sufficient."
84451,"This will work.
No Arrays or difficult stuff about cross blabla.
The code is in within 4-5 micros"
84623,Here are the modifications I have doneHere is the simulation outputObserve the onboard LED going HIGH and the buzzer going off. You can find the project link here where you can test with different Piezo buzzer frequency.CodeDisclaimer: I am not the Wokwi creator but I support it since it is open source and free to use
84823,"should I be declaring last_ms as a global variable instead of
static?Local static is better, as it limits the scope of the variable to just
where it is needed. Consider making it global only if the code is part
of a tutorial meant for beginners which may be confused by the keyword
static.should this code be at the beginning or end of loop?The conditional early return only makes sense if loop() has nothing
more to do once the sensor data is handled, thus this should go at the
very end of loop(). However, if loop() does more than just handle
this data, I think it would be cleaner to avoid the early return: either
put this in a separate function (which can return early), or condition
the handling of the sensor on ms - last_ms >= 10.My understanding is we are basically checking how long the previous
loop took.No. The test is looking at how much time has elapsed since the previous
time last_ms was updated, which could be many loop() iterations ago.But doesn't that mean that we might still get deviation from 100 Hz
due to the time it takes to complete loop (about 2-5ms in my case), so
effectively it's 10 ms + loop complete time?Indeed. With this logic, 10 ms is the minimum time between calls
to sensor_data(). If you want to ensure an accurate average polling
time, you should update last_ms by adding 10. You will still have
sole jitter though.A small note about millis(): since the value is updated every
1.024 ms, it occasionally has to jump by two units at once, and has
therefore 1 ms of jitter. For a period as short as 10 ms, I
would rather use micros(). For example:Edit: About why last_us has to be incremented by a constant
amount, consider this alternative:The code following the if ... return; line will be executed when the
tested condition is false, i.e. when now - last_us >= POLLING_PERIOD.
It may happen that we sometimes have strict equality (now - last_us == POLLING_PERIOD) but, since any code execution takes time, sometimes
now - last_us will be strictly larger than POLLING_PERIOD. Every
time this happens last_us will be incremented by more than
POLLING_PERIOD. This means that the small timing errors accumulate.If, instead, last_us is updated by adding a constant amount, we still
have timing errors (because of the time needed to execute any code), but
they are not cumulative. In other words, we have jitter, but the
average polling frequency is right."
85036,"ok, well there are some things I don't know about your code, and hardware, like if the LCD library can handle uint64_t datatypes. I know the Serial.print() function can only handle up to a unit32_t, so I'm using that.I think your length variable might not be the right length, you might want to add in a check for that in your code. Much of the Arduino code is 8 bit.I think this code will do what you want, at least as I understand it.
beware of what data-types your LCD library can handle."
85132,"Thanks for the answer from @tavisHere is the simulation of their code and it answers your questions aptly.
The code (same as above, except the sweep time change)Link to the simulation:
https://wokwi.com/arduino/projects/303847722463527490Here is another example with three Servo motors running at three different sweep times:
https://wokwi.com/arduino/projects/299552195816194570"
85288,"From the MPU-6000/MPU-6050 Register Map and Descriptions:Section 4.28, Register 107 – Power Management 1 PWR_MGMT_1, pages 40 to 41:Note:
When using SPI interface, user should use DEVICE_RESET (register 107) as well as SIGNAL_PATH_RESET (register 104) to ensure the reset is performed properly. The sequence used should be:Section 4.26, Register 104 – Signal Path Reset SIGNAL_PATH_RESET, page 37:Note: This register does not clear the sensor registers. The reset initializes the serial interface as well.Section 3, Register Map, page 8:The reset value is 0x00 for all registers other than the registers below.This means that the PWR_MGMT_1 register defaults to sleep mode after a reset so it needs to be rewritten to disable sleep mode after commanding a reset.In the following code I've:Modified readGyro() to implement 3 states (Request, Wait, and Read) and return true when 6 bytes have been read from the MPU-6050.Added Blink Without Delay to loop() to see whether the MCU freezes which requires changing the ADO pin from pin 13 (the built-in led) to another pin, i.e. pin 12.Added several Serial.print() statements for debugging to see where things go wrong.Tweaked the code in response to comments.Update based upon RowanP's answerWhile concentrating on the software issues I missed a crucial piece of information from the other datasheet (MPU-6000/MPU-6050 Product Specification), i.e. the electrical characteristics in Sections 6.3 and 6.4 on pages 14 and 15 showing a Vdd range of 2.375 V to 3.46 V:
6.4 Electrical Specifications, Continued
This will require level shifters  on the signals between the 3.3 V MPU-6050 and the 5 V Arduino."
85297,"Well. After searching a lot here's the way todo a ""RENAME"" for a table. It's a bit tricky...
Renaming table in ESP SQLite is very interesting because SQLite has very limited features for editing table. So you can't add field, remove and so on. The only way is to create a new tmp table, copy the content of the orginal one into this tmp table, drop the original one and rename the tmp with the name of the new one.
DROP TABLE is OK with the ESP version of SQLite, but as said in the question, ALTER RENAME don't work.So here is the way to do:1-What tables do we have?When we init the ESP, we calland then we give SQLite the file it will use for saving data with a call to sqlite3_open() giving the name of a previously created file.All our own tables will be saved into this file but also definitions of our tables. For that, SQLite create system table. So in the database we have our own tables but also the SQLlite system tables2 - The data base schema tableOne of the most important table is the database schema one. Its name depend on the version of SQLite. With the version we use on ESP8266 or ESP32, its name is sqlite_master .
This table has 4 fields:3-Check the schemaTo check the content of this specific table, just make a  CREATE TABLE then SELECT * FROM sqlite_masterHere is what I've done and the result:The CREATE TABLE CALL:create TABLE    IF NOT EXISTS     TAB_JOUEUR ('tjoueur_id' INTEGER,""tjoueur_prenom"" TEXT   , ""tjoueur_nom"" TEXT,   ""tjoueur_ville"" TEXT ,  PRIMARY KEY(""tjoueur_id"" AUTOINCREMENT))The result of the SELECT * FROM sqlite_masterand thenAs you can see the sql field relative to the table ""TAB_JOUEUR"" as the CREATE call but it's not a pure copy of the original CREATE call. The original one as ""create"" in lower case, had extra spaces and has a ""IF NOT EXISTS"" which we don't have in the sql field of sqlite_master. But the part between the () is exactly the same (single quote for tjoueur_id, double for tjoueur_nom, extra spaces...)4 - The trickIn order to rename a table, you just have to make a SELECT on sqlite_master in order to get the record of the table you want to rename. Then, change the content of the sql field to replace the ""old name"" by the ""new one"", and perform an update, using the rootpage as id.
So like that:It's basic and don't have test (you must add some!). I start by searching for the record concerning the ""old_name"" table. In the sql field I search for the ""("" and then I replace the first part of the sql field data with the new name of the table.
Then I update. Notice I don't escape the quote because I've previously make a CREATE call without any ' or "" (easier!)After that, I perform a sqlite3_close() then re-open with sqlite3_initialize(); If you don't do that, SQLite don't take change in account (maybe there is a cache for data).5 - Great but... not enought!If you try this, you'll get an error on the update call. That's because for you, ""user"", sqlite_master is a read only table. So you can't update it. In order to prevent writing on some table (like the sqlite_master one), when SQLite create it, it sets a ""read only"" flag. The trick is to edit the source code in order to give to this flag, the value of ""read and write"".
In the sqlite3.c of the LIB, it's a line 17420. You'll see:Just change it bySo when SQLite will create a system table, it will set a read+write flag and so, you would be able to update the sqlite_master table. You need to compile again de lib (on Arduino IDE, just select a wrong board, try to compile, get an error, select ESP32 and compile again and the IDE will perform a full compilation of the lib)If you have trigger, and some other specific feature, maybe it would be nice to check the result of the select * from sqlite_master in order to see if some records need also to be updated. But for basic table, this will do the job.Hope this will help.EditIf you add an index (or more than one) to your table, you'll have also to update 'index"" records from sqlite_master. They are like that:So just update the tbl_name value giving the new name of the table, and update the sql field the same way."
85328,"The short answer to your question is “yes, there is a way”. Multiple
ways actually. You could write a blocking function, which follows more
or less the logic of the example you show, blocking while waiting for
each new byte. Or you could write a non blocking function, which
always return immediately and, either gives you the complete packet,
or tells you that no full packet has been received so far.The non-blocking way may be a bit more complicated, but it is more
useful, because you program can do other stuff, and be responsive, while
waiting for a packet. Here is my take at it. It is based on a finite
state machine:It will be up to you to implement packet_length(). See jstola's
comment on why it is needed.You would use read_packet() like this:Edit: According to your comment, some commands have a payload which
is a string of unknown length, but seemingly NUL-terminated. I
edited the code, and added an extra EXPECTING_STRING state to handle
this special case. It is up to you to implement the boolean function
command_payload_is_string()."
85400,"Here is a sketch to quickly find out unsigned maximum values on any architecture and deduce the bit width from them (I had to use sprintf, because Serial.println(unsigned long long) did not work on my Due):On Arduino Due this gives (I expect it to be the same on SAMD51):Usually you could include ""limits.h"", but it seems that unsigned long long is missing (at least on Due). Hmmm, I didn't expect int and long to be the same, good to know."
85478,Here I have a simple example of cycling over 3 LEDs with the same 'delay' for every LED.
85518,"So I decided a little empirical testing was in order. This is using a nano (328P)Using a simple for loop in loop() (calculating the squares of 0 to 255) over 10 seconds with and without there being serial traffic and at different speeds.Note: this is without any inspection of the ring buffer on incoming data - just measuring the overhead of there being traffic on the wire. The traffic on the wire was the maximum an arduino mega was able to send at that baud rate.Code block as requested for the unit doing the timing (it includes calls to the libraries I am using for my environment, but I am sure you can abstract those away to something else and should not be significant to the stats)"
85940,"You have the right idea to debounce the buttons, but there is a 50 ms delay per button which blocks the loop for a total of 200 ms with four buttons.So consider using a non-blocking debouncer of which there are many examples on the internet, but here is a simple debouncer I put on GitHub. It could be implemented something like the following example:And here it is in action in the Wokwi simulator:"
8600,"Both NTP and milli() waste a lot of processing as it keeps the Arduino busy checking if the time is right. Your best bet is to use the Arduino timer. Set the timer to interrupt every 10 minutes. If you don't need to do anything aside from functions A and B, you can let your Arduino sleep and keep power draw to a minimum.Hope this helps."
8617,Well as usual it was something stupid (-__-) I changed the byte array for long and it worked perfectly.Here is the complete code working(): 
86238,"I do not know what the “frequencies” have to do with your problem, but I
would bet that you would get more reliable results if you handle one
NMEA sentence at a time, instead of trying to handle six of them at
once, and hoping to get the right ones.Below is a function that processes one complete sentence at a time. It
records the sentence to the SD file if its type belongs to a list of
“interesting” types you want to monitor:The way to use it is to buffer the incoming characters until you get a
complete sentence (identified by the final LF), then submit that buffer
to this function:Note that it wouldn't take too much work to get rid of the String
class and use plain C strings instead. Plain strings are way more memory
friendly."
86807,The problem is in the first loop IF condition.Try:
86902,"I kind of solved it, I was using malloc incorrectly and was accessing uninitialized bits, thus causing undefined behaviour. The code below should work correctly"
8978,"Well, if each boolean takes a full byte, as fuenfundachtzig says, then you might try some bitwise hacking to fit 8 bools per byte on your own.  Maybe something like this:As for the stylistic differences between my example and yours:"
9314,"See example at:
https://github.com/BenTommyE/Arduino_getStringPartByNr"
9539,"I'll tell you what worked for me, because I didn't find the schematics of this board. But your board may work differently, so it is always good to check the datasheet and the schematic (if you have one).Be sure to use an external 5V source that can supply up to 2A without dipping significantly. Open the serial monitor Arduino, set the baud rate in 19200 in ""Both NL & CR"". If not work, set to ""Carriage Return"". Type ""AT"" and wait for an OK.If you need help, these links were useful to me:"
9630,I guess I'll answer my own question for anyone else having this issue. What I did was:Python:Arduino:
9767,You have two serial connections. One for the main USB of the board and one for the XBee. So you need to read from the XBee and write to the serial USB?I don't know what speed you have configured for your XBee so I have set it to 9600.This example reads from the XBee and writes to the Serial/USB portNote: Your example also used Serial.write() with the wrong argument DEC which applies to Serial.print(). X-CTU and Arduino both send ascii which is also what the Serial.print() does. However the Serial.read() just reads the byte so we need to use Serial.write() to send the same bytes back to the other end.You can also make life a bit easier by replacing xbee.available() with Serial.available(). Then use the Arduino IDE serial monitor to both send and receive. This means that you just use the one USB connection to prove the code.
